// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`The file post repository gets all posts 1`] = `
[
  {
    "category": "react",
    "cover": "https://swcrafters.fra1.cdn.digitaloceanspaces.com/Categories/ReactJS_category.png",
    "date": "",
    "description": "Los desarrolladores llamamos arquitectura al conjunto de patrones de desarrollo que permiten definir unas pautas a seguir en nuestro software en cuanto a límites y restricciones.",
    "id": "arquitectura-hexagonal-frontend",
    "markdownBody": "Existen multiples definiciones para el término **arquitectura** dependiendo del contexto en el que se trate y de la vertiente del desarrollo de la que se provenga, por lo que es muy complicado llegar a un consenso y a una definición única que sea válida para todos los casos. Así pues, ciñéndonos al desarrollo de software en *frontend*, bajo un punto de vista personal la definición es la siguiente:

> Los desarrolladores llamamos **arquitectura** al conjunto de patrones de desarrollo que permiten definir unas pautas a seguir en nuestro software en cuanto a límites y restricciones.
Es la guía que debemos seguir con la finalidad de ordenar nuestro código y hacer que las distintas partes de la aplicación se comuniquen entre sí. 

Existe una gran cantidad de opciones a la hora de decantarnos por una arquitectura u otra. 
Cada una de ellas tendrá sus propias ventajas e inconvenientes. Incluso una vez escojamos cuál es la mejor que se adapta a nuestro caso, no tiene por qué implementarse de igual forma en los distintos proyectos.

Sin embargo, aunque el abanico de patrones es casi infinito, la gran mayoría mantienen atributos de calidad comunes, tales como: escalabilidad, responsabilidad única, desacoplamiento, mantenibilidad, etc.; por lo que, de manera general, es de vital importancia entender los conceptos y por qué se ha adoptado dicha solución, más que la teoría en sí.

Uno de los patrones de diseño de arquitectura de *software* más utilizados es el de la **Arquitectura Hexagonal** (*Hexagonal Architecture*), también conocida como arquitectura de **Puertos y Adaptadores** (*Ports and Adapters*), dada a conocer por *[Alistair Cockburn](https://en.wikipedia.org/wiki/Alistair_Cockburn)*.

La finalidad principal de este patrón es dividir nuestra aplicación en distintas capas, permitiendo su evolución de manera aislada y responsabilizando a cada entidad de una funcionalidad única.

## ¿Por qué se le llama hexagonal?

La idea de representar esta arquitectura con un hexágono es debido a la facilidad que presenta el asociar el concepto teórico con el concepto visual, puesto que dentro de dicho hexágono es donde se encuentra nuestro código base, llamado **dominio**, y cada uno de sus laterales es una interacción hacia un servicio externo, por ejemplo: servicios *http* de terceros, bases de datos, servicio de mensajería o renderización.

![hexagon](https://gist.githubusercontent.com/adrian-afergon/52d0f1cc95d7dcf3bcf33b98a4c688dd/raw/b20666a3be59156ab2fc26ee7b3c7816cf125b6c/hexagon.png)

La comunicación del **dominio** con el resto de actores se realiza en una capa denominada **infraestructura**, donde se encuentra la implementación específica para cada una de estas tecnologías.

![hexagon - infrastructure](https://gist.githubusercontent.com/adrian-afergon/52d0f1cc95d7dcf3bcf33b98a4c688dd/raw/b20666a3be59156ab2fc26ee7b3c7816cf125b6c/infrastructure.png)

Una de las preguntas más frecuentes entre los profesionales que ven por primera vez esta arquitectura, es: *"¿a qué se debe la figura hexagonal?"* El uso del hexágono no es más que una mera representación teórica. El número de servicios con los que podemos integrarnos es infinito y pueden ser tantos como necesitemos. En el lado opuesto tenemos el caso más simple donde sólo hay dos interacciones con el dominio de la aplicación y, obviamente, esta situación no puede representarse con una figura poligonal.

## Mismo concepto distintos nombres

Como hemos comentado previamente, este patrón recibe también el nombre de **puertos y adaptadores** (*Ports and Adapters*). Este nombre viene de una separación dentro de la capa de infraestructura, donde tendremos dos subcapas:

- **Puerto**: Es la interfaz que deberán implementar las distintas variantes de nuestro código para abstraerse de la tecnología. En ella se ha de definir la firma de los métodos que existirán.
- **Adaptador**: Es la implementación de la interfaz, en ella se generará el código específico para consumir una tecnología en concreto. Esta nunca se usará de forma directa en la aplicación, más allá de la declaración, ya que su uso se realizará a través del tipo del **puerto**. 

Así pues, nuestro dominio realizará llamadas a la subcapa que se corresponde con el **puerto**, quedando desacoplado de la tecnología, mientras que éste, a su vez, consumirá el **adaptador**.

De esta manera, en caso de realizar un cambio tecnológico, sólo se verá afectada la capa externa (adaptador).

Dado que el concepto de **puertos y adaptadores** está muy ligado a la programación orientada a objetos y por lo tanto al uso de interfaces, es probable que la implementación de este patrón en lenguajes de programación funcional difiera ligeramente del concepto inicial.

De hecho han surgido múltiples patrones que *"iteran"* sobre éste, como la *Arquitectura Cebolla* (*Onion Architecture*) o la *Arquitectura Limpia* (*Clean Architecture*). Sin embargo, la premisa es la misma para todas ellas: dividir nuestra aplicación en capas, separando el **dominio** de la **infraestructura**.

## ¿Cómo afecta en la mantenibilidad?

El hecho de tener nuestro código dividido en capas, donde cada una de ellas tienen una responsabilidad única, ayuda a que evolucione de forma distinta, sin repercusión en las demás.

Por otra parte, con esta segmentación también conseguimos una mayor cohesión, donde cada capa tendrá una responsabilidad bien definida y única dentro del contexto de nuestro software. 

Finalmente, debemos tener en cuenta que no todas las personas que se incorporan por primera vez a un equipo conocen estos términos o están familiarizadas con dichos conceptos, por lo que es responsabilidad de los equipos ser lo suficientemente genéricos y definir una estructura lo suficientemente robusta para que la carencia de dichos conocimientos no suponga una carga adicional al desarrollo.

## ¿Cómo afecta en el frontend?

En la actualidad hay una serie de carencias respecto al uso de metodologías a la hora de crear aplicaciones. La facilidad y la velocidad proporcionadas por las actuales herramientas han hecho que dejemos a un lado el trabajo de análisis e implementación de arquitecturas conocidas y sobradamente contrastadas.

No obstante, aunque estas arquitecturas puedan parecer más propias de otros tiempos donde los lenguajes de programación no evolucionaban a un ritmo tan vertiginoso como hoy en día, dichas arquitecturas han sido planteadas, y en algunos casos adaptadas, para que sigan proporcionando la escalabilidad necesaria para las aplicaciones actuales.

### Marco histórico

Hace aproximadamente dos décadas las aplicaciones de escritorio eran la herramienta principal en cuanto a software. En ellas, el grueso del código de la aplicación se encontraba instalado en librerías, dentro de la propia máquina, y el nivel de acoplamiento era elevado entre la vista y comportamiento de la misma.

Con la finalidad de continuar escalando las aplicaciones y llegar a un software con mayor mantenibilidad y unas base de datos centralizadas (no en un entorno local), muchas de estas operaciones se llevaron al servidor. Esto ocasionó que las aplicaciones de escritorio quedasen relegadas a meras interacciones de usuario que no requerían de acceso, persistencia o datos remotos. De necesitarlo, las aplicaciones tendrían la responsabilidad de hacer estas llamadas a través de la red a los servicios desplegados en servidores externos. Es aquí donde empezamos a ver la primera distinción entre *frontend* y *backend*.

En los siguientes años surgió el *boom* de la web. Muchas de las aplicaciones de escritorio saltaron al marco del navegador, donde las limitaciones tecnológicas eran notorias y la publicación del \`html\` bien era estática o tenía que generarse de forma dinámica en el servidor. Sin embargo, con el paso del tiempo \`JavaScript\` comenzó a dotar de mayores posibilidades a los navegadores.  

### Actualidad

La parte visual siempre se había limitado a la representación de datos y nunca había necesitado mayor funcionalidad hasta hoy. Con las necesidades actuales, las aplicaciones **frontend** tienen mayores requisitos que los existentes hace años, por ejemplo: gestionan el estado de la aplicación, seguridad, asincronía, animaciones basadas en interacciones, integraciones con servicios de terceros, etc.

Es por este crecimiento que nos vemos en la necesidad de comenzar a aplicar patrones en estas aplicaciones, que se han desvinculado en su totalidad del contexto inicial.

### Consecuencia

Como bien hemos dicho, la finalidad del *frontend* es en su mayoría visualizar datos. A pesar de esta percepción, **no es** el **dominio** de nuestra aplicación, sino que pertenece a las capas exteriores de la arquitectura implementada.

Los casos de uso de la aplicación si pertenecen al **dominio** y no son relativos a cómo se deben visualizar. Por ejemplo: *"Dentro de una cesta de la compra que no podemos añadir más de 5 productos de un mismo tipo."*

La petición de datos al *backend* pertenece a la capa de **infraestructura**, ya que es algo que escapa de la responsabilidad de nuestra aplicación, aunque seamos nosotros quienes gestionemos el backend (esta es otra aplicación y por lo tanto las necesidades de arquitectura serán independientes). Por ejemplo el esquema de datos en el **backend** puede cambiar en cualquier momento y no queremos propagar esos cambios por toda nuestra aplicación **frontend**.

Por otro lado, la gestión de los datos de la sesión (*local*, *session*, *cookies*) es otro ejemplo de código que pertenece a la capa de **infraestructura**, porque si bien tenemos que lidiar con ella, no pertenece al **dominio** de nuestra aplicación.

## Y con las librerías de frontend ¿qué sucede?

En la actualidad existe una cantidad ingente de librerías para renderización: *Angular*, *React*, *Vue*, *Stencil*, *Polymer*, *Svelte*, *Ember*, etc.; pero debemos comprender cuál es su finalidad, y que por tanto, **NO DEBEN** entrar en el **dominio** de nuestra aplicación sino que deben ser relegadas a la **infraestructura**.

Todas estas herramientas tienden a evolucionar rápidamente en el tiempo y por lo tanto debemos hacer que nuestra aplicación sea lo más resiliente posible. ¿Cómo podemos hacer esto? Una de las estrategias más usuales pero a la vez menos conocidas es la de envolver dichas librerías en funcionalidades creadas expresamente para tal fin. A esta estrategia se la conoce comúnmente como *wrapping* y su objetivo principal es aislar a nuestro código de los efectos secundarios que las librerías de terceros podrían tener.

El *wrapping*  es una buena práctica pero cuando la utilicemos deberá ser consumida a través de un **adaptador**, como ya hemos dicho previamente, con la finalidad de reducir el acoplamiento. No obstante &mdash; y esto es una opinión personal &mdash; el hecho de envolver estas herramientas mencionadas en una implementación nos hará incurrir en una sobre-ingeniería que nos acarreará un mayor mantenimiento y una penalización de tiempo que, en la mayoría de los casos, el equipo no podrá afrontar, por lo que debemos valorar cuándo aplicar esta técnica de forma eficiente.

Como argumento al por qué no envolver este tipo de librerías, podemos afirmar que la comunicación entre la vista (**infraestructura**) y el **dominio** es unidireccional, es decir, son un punto de entrada a nuestra aplicación para el usuario, pero nunca serán consumidos por el **dominio**.

Una vez comprendido esto, tenemos que asumir que las herramientas que se acoplan de forma extrema a estas librerías de *frontend*, por ejemplo *Redux*, deben ser gestionadas de forma conjunta a nivel de **infraestructura**.

## Ejemplo

A continuación veremos un caso de uso donde intentaremos plasmar todos estos conceptos sobre una cesta de la compra.
Primero desglosaremos las entidades que entran en juego, las cuales tendremos que recuperar de un servicio de terceros vía *http*:
- Producto 
- Cesta

Por otro lado estas entidades deberán mostrarse al usuario, de manera que pueda interactuar con ellas, por ejemplo: ver los productos y añadirlos a la cesta.

Finalmente añadiremos reglas de negocio, como por ejemplo, evitar añadir dos veces el mismo elemento a la cesta.

### Directorios

En el siguiente [repositorio](https://github.com/adrian-afergon/hexagonal-arch-example/tree/step-0/start) podemos encontrar un ejemplo de cómo organizar los directorios, tanto para una aplicación \`React\`, como para una hecha en \`Vue\`:

![folders](https://gist.githubusercontent.com/adrian-afergon/52d0f1cc95d7dcf3bcf33b98a4c688dd/raw/b20666a3be59156ab2fc26ee7b3c7816cf125b6c/folders.png)

En ambos casos hemos creado dos directorios: \`infrastructure\` y \`domain\` y hemos movido los componentes visuales dentro del primero.

### Dominio

A continuación definiremos los *modelos de dominio* \`Product\` y \`Basket\` que utilizará nuestra aplicación. Este paso es exactamente el mismo para las dos aplicaciones:

\`\`\`typescript
// /src/domain/models/Product.ts
export type ProductId = string

export type Product = {
  id: ProductId
  title: string
  price: number
}
\`\`\`

\`\`\`typescript
// /src/domain/models/Basket.ts
import { Product } from './Product'

export type BasketId = string

export type Basket = {
  id: BasketId
  items: Product[]
}
\`\`\`

Ahora definiremos una funcionalidad que permita añadir un \`Product\` a un \`Basket\`, teniendo en cuenta que el mismo producto no puede estar repetido en la cesta.

Dependiendo del patrón de diseño por el que nos decantemos, la implementación de esta funcionalidad será distinta. Para este caso optaremos por el más sencillo, un modulo, \`service\` que maneja los datos:

\`\`\`typescript
// /src/domain/services/Basket.service.ts
import * as uuid from 'uuid'
import { Product } from '../models/Product'
import { Basket } from '../models/Basket'

const hasProduct = (basket: Basket, product: Product) => 
  basket.items.find((item) => item.id === product.id)

const createBasket = (product: Product) => ({
  id: uuid.v4(),
  items: [product]
})

const increaseBasket = (basket: Basket, product: Product) : Basket => ({
  ...basket,
  items: [...basket.items, product]
})

const addProductToBasket = (product: Product, basket?: Basket|null): Basket =>
  basket
    ? hasProduct(basket, product)
        ? basket
        : increaseBasket(basket, product)
    : createBasket(product)

export const basketService = {
  addProductToBasket
}
\`\`\`
- *[GitHub - Creación de los modelos](https://github.com/adrian-afergon/hexagonal-arch-example/tree/step-1/models)*
- *[GitHub - Creación del servicio](https://github.com/adrian-afergon/hexagonal-arch-example/tree/step-2/services)*

### Acceso a datos

Por otro lado, necesitaremos recuperar el listado de productos. Como bien hemos indicado, realizaremos una petición \`http\`. Sin embargo ¿qué ocurriría si en lugar de esta petición, necesitásemos hacerla vía \`GraphQL\`? Tendríamos que cambiar gran parte de nuestro código. Incluso vayamos a una decisión más trivial, ¿realizaremos dichas peticiones usando \`xhr\`, \`fetch\` o \`axios\`?

El llevar esta decisión a nuestra capa de **infraestructura** será la opción más acertada. A su vez este objeto será consumido por una entidad \`repository\`.

> Hemos añadido un servicio \`api-example\` al proyecto de forma que tengamos un *backend* de pruebas.

En primer lugar definiremos la estructura del dato devuelto por la *API*. Este tipo de datos se les denomina \`Data Transfer Object (DTO)\`:

\`\`\`typescript
// /src/infrastructure/http/dto/ProductDTO.ts
export interface ProductDTO {
  product_id: string,
  title: string,
  description: string,
  price: string
}
\`\`\`

Ahora crearemos una envoltura a la librería \`fetch\` del navegador para los métodos \`http\`:
\`\`\`typescript
// /src/infrastructure/http/http.ts
const headers = {
  'Content-Type': 'application/json'
}

const get = async <T>(url: string) => {
  const response = await fetch(url, {
    method: 'GET',
    headers
  })
  return await response.json() as T
}

const post = async <T>(url: string, body: any) => {
  const response = await fetch(url, {
    method: 'POST',
    headers,
    body
  })
  return await response.json() as T
}

const put = async <T>(url: string, body: any) => {
  const response = await fetch(url, {
    method: 'PUT',
    headers,
    body
  })
  return await response.json() as T
}

const _delete = async <T>(url: string) => {
  const response = await fetch(url, {
    method: 'DELETE',
    headers
  })
  return await response.json() as T
}

export const http = {
  get,
  post,
  put,
  delete: _delete
}
\`\`\`

Por último crearemos nuestro \`repository\` en el directorio \`infrastructure\`. La finalidad de esta capa es hacer la petición y transformar el dato devuelto por el servidor a un *modelo de dominio* definido en nuestra aplicación:

\`\`\`typescript
// /src/infrastructure/repositories/product.repository.ts

import { http } from '../../infrastructure/http/http'
import { ProductDTO } from '../../infrastructure/dto/ProductDTO'
import { Product } from '../models/Product'

export const productRepository = {
  getProducts: async () => {
    const products = await http.get<ProductDTO[]>('http://localhost:3001/products')
    // we can extract this transform to a function inside this file to be reused by different methods
    return products.map((productDto): Product => ({
      id: productDto.product_id,
      title: productDto.title,
      price: Number(productDto.price)
    }))
  }
}
\`\`\`

[GitHub - Acceso a datos](https://github.com/adrian-afergon/hexagonal-arch-example/tree/step-3/repositories)

### Vista

Ahora bien, la **vista** y la capa de **acceso a datos** se encuentran en infraestructura. Sin embargo, no deben comunicarse directamente; deberán comunicarse haciendo uso de la capa de **dominio**. Por ello, crearemos un nuevo servicio que se encargue de consumir nuestro \`repository\` y dar disponibilidad de estos datos al resto de la aplicación:

\`\`\`typescript
// src/domain/services/Product.service.ts

import { productRepository } from '../../infrastructure/repositories/product.repository'

export const productService = {
  getProducts: () => {
    return productRepository.getProducts()
  }
}
\`\`\`

> Una buena práctica en este punto podría ser: en lugar de exportar un objeto, definir una función a través de la cual podamos pasar variables como parámetros y devolver como resultado de la llamada al método el objeto anteriormente definido. Sin embargo, no queremos elevar la complejidad de la aplicación en este punto. 

Ahora que hemos definido como recuperar los datos y la funcionalidad necesaria para añadir elementos a nuestra cesta, vamos a visualizar el listado de productos en la aplicación. Bien trabajes en \`React\` o en \`Vue\`, debes percatarte que el código hasta ahora ha sido el mismo para ambas plataformas, por lo que la llamada al método desde nuestro componente será la misma (salvando las distancias por la especificidad del ciclo de vida de cada una):

\`\`\`typescript
// React
// src/infrastructure/components/ProductList.tsx
import * as React from 'react'
import { Product } from '../../domain/models/Product'
import { productService } from '../../domain/services/Product.service'

export const ProductList: React.FC = () => {
  const [products, setProducts] = React.useState<Product[]>([])

  React.useEffect(() => {
    productService.getProducts().then(setProducts)
  }, [])

  return (
    <ul>
      {products.map((product) => <li key={product.id}>{product.title}</li>)}
    </ul>
  )
}
\`\`\`
\`\`\`vue
<!-- 
 Vue 
 src/infrastructure/components/ProductList.vue
-->
<template>
  <ul>
    <li v-for="product in products " :key="product.id"> {{ product.title }}</li>
  </ul>
</template>

<script lang="ts">
import { defineComponent } from 'vue'
import { productService } from '@/domain/services/Product.service'
import { Product } from '@/domain/models/Product'

type DataProps = {
  products: Product[];
}

export default defineComponent({
  name: 'ProductList',
  data (): DataProps {
    return {
      products: []
    }
  },
  mounted () {
    productService.getProducts().then(response => (this.products = response))
  }
})
</script>
\`\`\`
La gestión del estado de los elementos en la cesta es un punto interesante. Aun así, es algo relativo al cómo se visualizan los datos en la interfaz, por lo que nos centraremos en el caso más simple que es gestionarlo a nivel del componente raíz y que este se actualice mediante eventos.

Definimos el estado inicial en el padre y una función que actualice el estado de la cesta:

\`\`\`typescript
// React
// /src/App.tsx
import React from 'react'
import { ProductList } from './ProductList'
import { Basket } from '../../domain/models/Basket'
import { Product } from '../../domain/models/Product'
import { basketService } from '../../domain/services/Basket.service'

type AppProps = {
  msg: string
}

const App: React.FC<AppProps> = ({ msg }) => {
  const [basket, setBasket] = React.useState<Basket|null>(null)

  const handleAddToCart = (product: Product) => {
    setBasket(basketService.addProductToBasket(product, basket))
  }

  return (
    <div className="App">
      <h1>{msg}</h1>
      <ProductList onSelectProduct={handleAddToCart}/>
      { basket && <p>Items on basket: {basket.items.length}</p>}
    </div>
  )
}

export default App
\`\`\`
\`\`\`vue
<!--
Vue
/src/App.vue
-->
<template>
  <Main msg="Welcome to Your Vue.js + TypeScript App"/>
  <ProductList :on-select-product="handleAddToCart"/>
  <p v-if="basket">Items on basket: {{basket.items.length}}</p>
</template>

<script lang="ts">
import { defineComponent } from 'vue'
import Main from './infrastructure/components/Main.vue'
import ProductList from '@/infrastructure/components/ProductList.vue'
import { Product } from '@/domain/models/Product'
import { basketService } from '@/domain/services/Basket.service'
import { Basket } from '@/domain/models/Basket'

type DataProps = {
  basket: Basket|null;
}

export default defineComponent({
  name: 'App',
  components: {
    Main,
    ProductList
  },
  methods: {
    handleAddToCart (product: Product) {
      this.basket = basketService.addProductToBasket(product, this.basket)
    }
  },
  data (): DataProps {
    return {
      basket: null
    }
  },
  mounted () {
    this.basket = null
  }
})
</script>
\`\`\`

Emitimos el evento a los hijos de forma que llamen a la función manejadora con el producto seleccionado:

\`\`\`typescript
// React
// /src/infrastructure/components/ProductList.tsx
import * as React from 'react'
import { Product } from '../../domain/models/Product'
import { productService } from '../../domain/services/Product.service'

type ProductListProps = {
  onSelectProduct: (product: Product) => void
}

export const ProductList: React.FC<ProductListProps> = ({ onSelectProduct }) => {
  const [products, setProducts] = React.useState<Product[]>([])

  React.useEffect(() => {
    productService.getProducts().then(setProducts)
  }, [])

  return (
    <ul>
      {products.map((product) => <li key={product.id}>
        <button onClick={() => { onSelectProduct(product) }}>{product.title}</button>
      </li>)}
    </ul>
  )
}
\`\`\`
\`\`\`vue
<!--
Vue
/src/infrastructure/components/ProductList.vue
-->
<template>
  <ul>
    <li v-for="product in products " :key="product.id">
      <button @click="() => { onSelectProduct(product) }">{{ product.title }}</button>
    </li>
  </ul>
</template>

<script lang="ts">
import { defineComponent } from 'vue'
import { productService } from '@/domain/services/Product.service'
import { Product } from '@/domain/models/Product'

type DataProps = {
  products: Product[];
}

export default defineComponent({
  name: 'ProductList',
  props: {
    onSelectProduct: { type: Function }
  },
  data (): DataProps {
    return {
      products: []
    }
  },
  mounted () {
    productService.getProducts().then(response => (this.products = response))
  }
})
</script>
\`\`\`

[GitHub - Vista](https://github.com/adrian-afergon/hexagonal-arch-example/tree/step-4/view)
[GitHub - Events](https://github.com/adrian-afergon/hexagonal-arch-example/tree/step-5/events)

### Librerías de terceros

Si prestamos atención al código anterior, vemos que todo nuestro código está desacoplado de la tecnología que usamos. Nuestra capa de **dominio** es capaz ser usada tanto por \`Vue\` como por \`React\`, teniendo una implementación \`http\` que nos podría llegar a abstraer de si estamos aplicando \`SSR\` o funcionamos sobre una \`SPA\`.

Sin embargo ¿qué ocurriría si tuviésemos que utilizar una librería de terceros? Lo cierto es que si prestamos atención al \`basket.service.ts\`, tenemos una dependencia con la librería \`uuid\` (la cual hemos dejado aposta). Esta librería se encarga de generar \`ids\` de forma aleatoria para el carrito en *frontend*, pero a su vez nos limita a la hora de ejecutarse en *backend*, o en su defecto, nos puede obligar a modificar nuestra capa de **dominio** por una actualización de la misma.

Por ello, la solución a aplicar debería ser la seguida con la integración que hemos hecho para \`http\`.

\`\`\`typescript
// /src/infrastructure/uid/uid
import * as uuid from 'uuid'

export const generateUid = (): string => uuid.v4()
\`\`\`

\`\`\`typescript
// /src/domain/service/Basket.service.ts
const createBasket = (product: Product) => ({
  id: generateUid(),
  items: [product]
})
\`\`\`

Este simple cambio nos permitirá que a futuro podamos cambiar a una \`v5\` sin necesidad de actualizar el código del **dominio** en múltiples puntos, pues es dentro de la función \`generateUid\` el único punto donde tendremos que aplicar el cambio.

## Conclusión

Como hemos tratado varias veces a lo largo de esta publicación, el aplicar la arquitectura adecuada en *frontend* nos permitirá mejorar la mantenibilidad del código. Si se poseen los conocimientos adecuados, el uso tecnológico será menos crítico y por tanto, podemos añadir un mayor valor al **dominio**.

Pensemos en la velocidad a la que evoluciona el software. En los últimos 20 años la forma de programar ha cambiado enormemente, los desarrolladores hemos tenido que aprender nuevas tecnologías y adaptarnos, pero el negocio se ha mantenido constante.

Por último, aclaremos que este patrón se puede combinar con otros conceptos, como pueden ser *DDD*, *Functional Programing*, *OOP*, etc. No obstante, la intención de este ejemplo es transmitir unas nociones básicas y ser capaz de llegar a cualquier persona interesada, de la manera más sencilla posible.

Espero que estos conceptos te sean de ayuda en tu día a día, que desde un punto crítico te ayuden a evaluar tus proyectos de software y optar por éste u otros patrones de desarrollo que mejoren la calidad de tu trabajo; y que mitiguen los problemas diarios en lo que a software y decisiones de negocio se refiere.

Ante cualquier pregunta, no dudes ponerte en contacto conmigo a través de [mi web](https://adrianferrera.com/) o la de [software crafters](https://softwarecrafters.io/) para más documentación de esta índole.
Puedes encontrarme en redes sociales:

- [Twitter](https://twitter.com/AdrianFerrera91)
- [Linkedin](https://www.linkedin.com/in/afergon/)
- [Youtube](https://www.youtube.com/channel/UCiLWrFqdr20VGV9ZISqaJeg)",
    "slug": "arquitectura-hexagonal-frontend",
    "tags": [
      "react",
    ],
    "title": "Arquitectura Hexagonal en el FrontEnd",
    "userPicture": "",
    "username": "Adrián Ferrera",
  },
  {
    "category": "javascript",
    "cover": "https://swcrafters.fra1.cdn.digitaloceanspaces.com/Categories/JS_category.png",
    "date": "",
    "description": "La programación funcional es un paradigma de programación basado en la composición de funciones matemáticas.",
    "id": "introduccion-programacion-funcional-javascript",
    "markdownBody": "La **programación funcional** es una forma de entender nuestro software como una serie de *funciones matemáticas* en las que, dadas unas *entradas* determinadas, siempre obtenemos las mismas *salidas*.

Aunque esté "de moda", este paradigma existe desde antes que la *orientación a objetos*, y está basado en el *cálculo lambda*. Sin embargo, hasta hace relativamente poco permanecía en el ámbito académico y científico.

En el caso de **JavaScript**, aunque no es un lenguaje funcional puro (ya que implementa características imperativas), su flexibilidad y dinamismo nos permiten adoptar un enfoque funcional y métodos como *map*, *filter* y *reduce* nos son de gran ayuda.

Los beneficios de la FP sobre nuestro código son:

- Es mucho más fácil de testear.
- Se reduce la complejidad, al enfocarse en qué vamos a hacer, y no cómo lo haremos.
- El código es más modular, y por lo tanto, más sencillo de entender.
- También es más confiable, al tener la seguridad de que no cambiaremos el valor de ningún recurso compartido.

## Algunos conceptos de la programación funcional

### Parámetros y argumentos

Los **argumentos** son los valores con los que llamamos a las funciones, mientras que los **parámetros** son las variables nombradas que reciben estos valores dentro de nuestra función:

\`\`\`javascript
const double = x => x * 2; // x es el parámetro de nuestra función

double(2); // 2 es el argumento con el que llamamos a nuestra función
\`\`\`

### Aridad

La **aridad** de una función hace referencia al número de *parámetros* que tiene. Así pues, una función de *aridad 1* (o unaria) tiene 1 parámetro, una unidad de *aridad 2* (o binaria) tiene 2 parámetros y así sucesivamente (por cierto, a la de *aridad 3* se le llama ternaria).

En **JavaScript**, es posible llamar a una función con más *argumentos* de los *parámetros* que soporta. Simplemente serán ignorados.

\`\`\`javascript
const double = x => x * 2;

console.log(double(2, 5)); // double(2); // 4;
\`\`\`

### Funciones puras

Una **función** es **pura** cuando:

- Su salida depende sólamente de los *parámetros* recibidos (es **determinista**), por lo que una llamada a la función se podría sustituir por el valor que devuelve sin que el funcionamiento de la aplicación se viese alterado (**transparencia referencial**).
- Los *parámetros* no son modificados y no se producen **efectos colaterales**. Imaginemos que varias partes de la aplicación apuntasen a la misma referencia que ha recibido nuestra función como argumento y que esta referencia original fuese alterada...


En el caso de **JavaScript**, esto tiene especial importancia, porque tanto los *arrays* como los *objetos* (también las funciones) se copian por referencia y no por valor. Veamos un ejemplo de un *efecto colateral*.

\`\`\`javascript
// Queremos crear un objeto igual a objA, pero con "prop2" igual a  "newVal2"

const objA = {
  prop1: 'val1',
  prop2: 'val2',
};

const objB = objA;
objB.prop2 = 'newVal2';

console.log(objB); // { prop1: 'val1', prop2: 'newVal2' } ✅ Tenemos nuestro nuevo objeto, pero...
console.log(objA); // { prop1: 'val1', prop2: 'newVal2' } ❌ hemos modificado el objeto original

console.log(objA === objB); // true ❌
\`\`\`

Si queremos obtener un nuevo objecto, tan solo tenemos que hacer una destructuración del objeto, añadiendo las claves que queremos modificar, o bien usar \`Object.assign\`:

\`\`\`javascript
const objA = {
  prop1: 'val1',
  prop2: 'val2',
};

const objB = { ...objA, prop2: 'newVal2');
// o
const objB = Object.assign({}, objA, { prop2: 'newVal2' });

console.log(objB); // { prop1: 'val1', prop2: 'newVal2' } ✅
console.log(objA); // { prop1: 'val1', prop2: 'val2' } ✅

console.log(objA === objB); // false ✅
\`\`\`

Debemos llevar cuidado con métodos como \`reverse\`, \`splice\`, etc, ya que mutan el array original. Una solución sería buscar un método alternativo o bien crear un nuevo array antes de llamar a esos métodos:

\`\`\`javascript
const options = ['a', 'b', 'c', 'd'];

// en vez de splice(1, 2);
const filteredOptions = options.filter(option => option !== 'b' && option !== 'c'); 

const reversedOptions = [...options].reverse();
\`\`\`

Algunas librerías, como React, basan su filosofía en el concepto de *immutabilidad*, ya que los componentes son renderizados solo cuando alguna de las propiedades cambia.

En el caso anterior de efecto colateral,  como \`objA\` es igual a \`objB\`, si se pasase ese objeto como propiedad, podría suceder que el componente no fuese capaz de detectar esos cambios, y reflejase un estado desactualizado.

Con repecto a la transparencia referencial, imaginemos esta función:

\`\`\`javascript
const runAtFive = () => {
	if ((new Date()).getHours() === 17) {
		externalFunction();
	}
};
\`\`\`

Si quisieramos testearla correctamente, necesitaríamos hacer un mock del objeto \`Date\` (o ejecutar el test solo a las 17h 🤣), además de tener que observar \`externalFunction\`.

Una aproximación más correcta sería pasar como argumento la hora actual, así como el callback que queremos ejecutar.
El retorno sería el resultado de ejecutar el callback, o \`false\` en caso contrario, lo que hace a nuestra función mucho más sencilla de testear.

\`\`\`javascript
const runAtFive = (hour, cb) => hour === 17 && cb();
\`\`\`

Algunos autores consideran que la utilización de constantes dentro de las funciones no viola los principios anteriormente descritos. Por ejemplo:

\`\`\`javascript
const SITE_NAME = 'Software Crafters';

const getFullTitle = (sectionTitle) => \`\${sectionTitle} | \${SITE_NAME}\`;
\`\`\`

En este caso, \`getFullTitle\` produciría siempre el mismo resultado para una determinada entrada y, además, si en la función reemplazásemos el uso de \`SITE_NAME\` por su valor, el resultado de la función permanecería inalterable.

### Funciones de Alto Orden (Higher Order Functions)

Las funciones de alto orden son aquellas que se envían como argumento a otra función, o bien son devueltas como resultado de la ejecución de otra función.

\`\`\`javascript
const double = x => x * 2;
[1,2,3,4,5].map(double); // double actuaría como HOF (Higher Order Function);

// add devuelve una HOF
const add = (x) => {
  if (typeof x === 'number') {
    return y => x + y;
  }
  return y => \`\${x}\${y}\`;
}

const addFive = add(5); HOF: y => 5 + y;
console.log(addFive(3)); // 8
console.log(addFive(12)); // 17
\`\`\`

Dado que, como veremos más adelante, una de las características principales de la programación funcional es la composición de funciones, este concepto nos resulta realmente útil.

### Forma declarativa

Tal y como la propia palabra expresa, cuando programamos de forma declarativa estamos haciendo uso de un alto nivel de abstracción, para decirle al lenguaje (o librería) qué es lo que queremos obtener, en vez de decirle cómo debe obtenerlo.

En el ejemplo anterior, podemos escribir en forma declarativa:

\`\`\`javascript
[1,2,3,4,5].map(double);
\`\`\`

o bien en forma imperativa:

\`\`\`javascript
let arr = [];
for(i=0; i<5; i++) {
  arr.push((i + 1) * 2);
}
\`\`\`

Ejemplos de lenguajes y librerías declarativas podrían ser GraphQL y React:

\`\`\`javascript
export const USERS_QUERY = gql\`
  query usersQuery {
    users {
      edges {
        node {
          id
          title
          description
          categories
        }
      }
    }  
  }
\`;


const { data, loading, error } = useQuery(USERS_QUERY);
return (
  <div>
    {data.map(({ id, title }) => <div key={id}>{title}</div>)}
  </div>
)
\`\`\`

### Recursividad

La recursividad se da cuando una función se llama a si misma, y es esencial cuando queremos trabajar de forma funcional con estructuras de datos.

\`\`\`javascript
const concatenateAll = (target, source) => {
  if (Array.isArray(source)) {
    return source.reduce(concatenateAll, target);
  }
  if (typeof source === 'object') {
    return Object.values(source).reduce(concatenateAll, target);
  }
  return \`\${target}#\${source}\`;
};

const data = {
  name: 'José Manuel',
  surname: 'Lucas',
  pet: {
    type: 'dog',
    name: 'Hustle',
  },
  hobbies: ['travelling', 'music', 'mountain biking'],
};

console.log(concatenateAll('', data)); // #José Manuel#Lucas#dog#Hustle#travelling#music#mountain biking
\`\`\`

### Composición de funciones

Imaginemos estas dos funciones:

\`\`\`javascript
const add3 = x => x + 3;
const double = x => x * 2;
\`\`\`

Podríamos decir que \`double(add3(2))\` es el resultado de componer "double" y "add3" sobre "2".

- Se calcula el resultado de aplicar la función "add3" a "2".
- Se calcula el resultado de aplicar la función "double" al resultado anterior.

Dado que podemos predecir el resultado de "add3" y de "double" por separado basándonos en su argumento, podríamos predecir de igual manera el resultado de la composición de las dos funciones.

Para facilitar la escritura de las composiciones de nuestras funciones, se suele hacer uso de las utilidades \`compose\` y \`pipe\`. Incluídas en librerías como [ramda](https://ramdajs.com/) o [lodash/fp](https://github.com/lodash/lodash/wiki/FP-Guide), si bien es cierto que la implementación básica es muy sencilla:

\`\`\`javascript
const compose = (...fns) => x => fns.reduceRight((acc, fn) => fn(acc), x);
const pipe = (...fns) => x => fns.reduce((acc, fn) => fn(acc), x);
\`\`\`

La diferencia es el orden en el que se pasan las funciones:

- **Compose**: Derecha a izquierda. Más cercano a la notación matemática.
- **Pipe**: Izquierda a derecha, más cercano al orden de evaluación.

\`\`\`javascript
console.log(pipe(add3, double)(2)); // 10 ✅
console.log(compose(add3, double)(2)); // 7❌
console.log(compose(double, add3)(2)); // 10 ✅
\`\`\`

### Estilo tácito o "point free"

Consiste en omitir los argumentos en aquellos casos donde es posible y hace que nuestra composición de funciones quede mucho más limpia.

Comparemos el ejemplo anterior con un ejemplo sin aplicar el estilo tácito:

\`\`\`javascript
pipe(add3, double)(2);

//vs

pipe(
  x => add3(x),
  x => double(x),
)(2);
\`\`\`

### Currificación

La currificación (estricamente hablando) consiste en transformar una función con x parámetros en una secuencia de x funciones con un solo argumento.

\`\`\`javascript
const sum3 = (a, b, c) => a + b + c;
const curriedSum3 = curry(sum3);

console.log(sum3(2, 4, 3)); // 9
console.log(curriedSum3(2)(4)(3)); // 9
\`\`\`


Una implementación sencilla podría ser:

\`\`\`javascript
const curry = (fn, arity = fn.length) => {
  const nextCurried = prevArgs => nextArg => {
    const args = [...prevArgs, nextArg];
    return args.length >= arity ? fn(...args) : nextCurried(args);
  };
  return nextCurried([]);
}
\`\`\`

Sin embargo, en librerías como ramda, la utilidad curry permite llamar a la función en cualquiera de sus formas, y no sólo argumento a argumento:

\`\`\`javascript
import { curry } from 'ramda'; 

const sum3 = (a, b, c) => a + b + c;
const curriedSum3 = curry(sum3);

sum3(2, 4, 3);
sum3(2)(4)(3);
sum3(2, 4)(3);
sum3(2)(4, 3);
\`\`\`

### Aplicación parcial

La aplicación parcial es una técnica similar a la currificación, solo que en este caso producimos una función con una aridad que no necesariamente es 1, simplemente es menor que la función original:

\`\`\`javascript
const operation = (a, b, c) => a + b - c;

const partialedOp = partial(operation, [2]);
console.log(partialedOp(4, 3)); // 3

// o

const partialedOp = partial(operation, [2, 4]);
console.log(partialedOp(3)); // 3
\`\`\`

La implementación podría ser algo así:

\`\`\`javascript
const partial = (fn, predefArgs) => (...args) => fn(... predefArgs, ...args);
\`\`\`

También es posible la aplicación parcial desde la derecha, es decir, pasar los últimos argumentos y después los primeros:

\`\`\`javascript
const operation = (a, b, c) => a + b - c;

const partialedOp = partialRight(operation, [3]);
console.log(partialedOp(2, 4)); // 3

// o

const partialedOp = partialRight(operation, [4, 3]);
console.log(partialedOp(2)); // 3
\`\`\`

## Aislando los efectos colaterales

Si nuestras aplicaciones no pudiesen manejar efectos colaterales bajo ningún concepto no podrían hacer uso de:

- Estado compartido
- Eventos
- Peticiones a una API
- Input del usuario
- Lecturas de tiempo
- Escritura o lectura en disco
- Generación de hashes o de números aleatorios
- etc

Al aplicar un enfoque funcional a nuestro código, el objetivo debe ser aislar todos esos efectos colaterales, no sustituirlos por completo.

Esto se podría resolver mediante una inyección simple de dependencias...

\`\`\`javascript
/**
 * CÓDIGO PURO
 */
const updateKey = (key, fn) => (obj) => ({
	...obj,
	[key]: fn(obj[key]),
});

const applyPrizeDecrease = updateKey('prize', currentPrize => currentPrize * 0.95);
const applyExpiryDecrease = updateKey('expiry', currentExpiry => currentExpiry > 0 ? currentExpiry - 1 : 0);

const updateItem = pipe(
	applyPrizeDecrease,
	applyExpiryDecrease,
);
const updateData = currentData => currentData.map(getUpdatedItem);

/**
 * CÓDIGO IMPURO
 */
(async () => {
	// Usamos un array vacío como salvaguarda, en caso de que la API responda con un valor "falsy"
	let data = await APIService.get('/endpoint') || [];
	setTimeout(() => {
		data = updateData(data);
	}, 86400000);
})();
\`\`\`

Imaginemos que queremos obtener el breakpoint actual en base a la anchura de nuestra pantalla. Tan sólo deberíamos aislar nuestros *side effects* (obtener el objeto window) e inyectarlo como dependencia en nuestras funciones puras, que se encargan de extraer la anchura de la pantalla, y de transformarla en un string con el valor del breakpoint.

\`\`\`javascript
/**
 * CÓDIGO PURO
 **/
const getWidth = x => x.screen.width;
const getBreakpoint = (x) => {
  if (x > 1200) {
    return 'desktop';
  }
  if (x > 600) {
    return 'tablet';
  }
  return 'mobile';
}

const getBreakpointFromWidth = pipe(getWidth, getBreakpoint);

/**
 * CÓDIGO IMPURO
 **/
 console.log(getBreakpointFromWidth(width));

\`\`\`

Otra opción sería usar un **functor**, que es una función que se encarga de transformar una categoría en otra.

Un ejemplo sencillo sería el functor \`Array\`, que con el método map nos permite transformar cada uno de sus elementos de una categoría a otra (por ejemplo de \`number\` a \`string\`, mediante la función \`getFeelFromTemp \`).

\`\`\`javascript
const getFeelFromTemp = temp => (temp > 22 ? 'hot' : 'cold');

const temps = [24, 19, 13, 32];
const feels = temps.map(getFeelFromTemp);
console.log(feels); // ['hot', 'cold', 'cold', 'hot']
\`\`\`

Para el propósito que nos ocupa, crearemos un functor *effect*, que se encargará de mantener nuestro código puro mientras lo "mapeamos", hasta que lo lancemos con "run".

\`\`\`javascript
/**
 * CÓDIGO PURO
 */
class Effect {
  static of(f) {
    return new Effect(f);
  }
  
  constructor(f) {
    this.f = f;
  }
  
  map(g) {
    return Effect.of(x => g(this.f(x)));
  }
  
  run() {
    return this.f();
  }
}

const getWindow = () => window;
const getWidth = x => x.screen.width;
const getBreakpoint = (x) => {
  if (x > 1200) {
    return 'desktop';
  }
  if (x > 600) {
    return 'tablet';
  }
  return 'mobile';
}

const breakpointEffect = Effect.of(getWindow).map(getWidth).map(getBreakpoint);

/**
 * CÓDIGO IMPURO
 */
console.log(breakpointEffect.run(100));
\`\`\`


## Bibliografía

- [Funcional Light JavaScript - Kyle Sympson](https://github.com/getify/Functional-Light-JS)
- [Professor Frisby's Mostly Adequate Guide to Funcional Programming - Brian Lonsdorf](https://mostly-adequate.gitbooks.io/mostly-adequate-guide/)
- [JavaScript Array Methods: Mutating vs. Non-Mutating](https://lorenstewart.me/2017/01/22/javascript-array-methods-mutating-vs-non-mutating/)
- [How to deal with dirty side effects in your pure functonal JavaScript](https://jrsinclair.com/articles/2018/how-to-deal-with-dirty-side-effects-in-your-pure-functional-javascript/)",
    "slug": "introduccion-programacion-funcional-javascript",
    "tags": [
      "javascript",
    ],
    "title": "Programación funcional en JavaScript. Introducción",
    "userPicture": "",
    "username": "Jose Manuel Lucas",
  },
  {
    "category": "blockchain",
    "cover": "https://swcrafters.fra1.digitaloceanspaces.com/Categories/bitcoin_category.png",
    "date": "",
    "description": "Los árboles de Merkle fueron desarrollados en 1979 por Ralph Merkle, el padre de la criptografía asimétrica y de las funciones hash.",
    "id": "merkle-trees-typescript-tdd",
    "markdownBody": "Hace un tiempo que estoy estudiando sistemas **Blockchain** en general y en particular el código de **Bitcoin**. Durante este proceso me he topado con los conocidos como árboles de Merkle, o **Merkle Trees** en inglés. Estos árboles son un elemento fundamental en el algoritmo de **validación de transacciones** de Bitcoin, formando parte a su vez del famoso **mecanismo de consenso**. Esta estructura es una pieza criptográfica muy interesante de implementar desde un punto de vista didáctico, ya que se interconectan conceptos de **criptografía** con **estructuras jerárquicas de datos**. La idea de este artículo es realizar una implementación aplicando un enfoque híbrido, interconectando conceptos de **POO** con elementos **programación funcional** como **inmutabilidad**, **recursividad** y **high order functions**, todo ello aplicando **TDD** y **buenas prácticas**. Así que independientemente de que te interese el mundo Blockchain o no, te invito que sigas el artículo hasta el final.

Los árboles de Merkle no son un concepto nuevo, fueron desarrollados y patentados en 1979 por **Ralph Merkle**, el padre de la **criptografía asimétrica** y de las **funciones hash**. En esencia un árbol de Merkle, también conocido como un árbol hash binario, es una estructura de datos jerárquica, en concreto un **árbol binario balanceado y completo** en el que cada uno de los elementos viene representado por un hash criptográfico. Se usa para resumir y verificar de manera eficiente la integridad de grandes conjuntos de datos. Recuerda, un árbol es binario cuando tiene cero, uno o dos nodos hijos, y además es balanceado cuando las alturas de los dos subárboles de todos sus nodos no difiere en más de uno. Por otro lado, un árbol binario completo es aquel en el que todos los niveles (excepto el más profundo) están completamente llenos de nodos. El nivel más profundo puede llenarse parcialmente, pero todos los nodos deben generarse transversalmente desde la izquierda hasta la derecha y sin que se formen espacios entre ellos. 

![Tipos de árboles binarios](https://swcrafters.fra1.digitaloceanspaces.com/Posts/merkle-tree-typescript/Arboles%20Binarios%20Balanceados.png)

## Aplicaciones

Los árboles de Merkle tienen múltiples utilidades. En Bitcoin, por ejemplo, se usan  para resumir todas las transacciones de un bloque concreto mediante una huella digital conocida como raíz de Merkle o Merkle root. Mediante esta raíz y un subconjunto del árbol conocido como Merkle path se puede verificar si un dato concreto (en el caso de Bitcoin, una transacción) se encuentra dentro de un bloque sin tener que disponer del árbol entero o de toda la colección de datos, en los siguientes párrafos veremos como implementar esto con TypeScript. Los árboles de Merkle, además de usarse en tecnologías blockchain, tienen otras aplicaciones, como pueden ser:

* **Bases de datos**: Apache Cassandra y otros sistemas NoSQL los usan para mantener la integridad de sus datos sin sacrificar rendimiento.
* **Sistemas de control de versiones** como Git, Mercurial y Subversion. 
* También los podemos encontrar en **sistemas de ficheros** distribuidos. Desarrollos como Ceph, BTRFS, ZFS e IPFS; usan estos árboles de hash con el fin de verificar y mantener la integridad de la información.
* Sin lugar a dudas, el mayor uso de los árboles de Merkle es hacer seguros los bloques de datos recibidos de otros nodos en **redes P2P**, como por ejemplo BitTorrent. Ya que verifican que los fragmentos de diferentes archivos son recibidos sin haber sido alterados. 

## El algoritmo

El árbol de merkle se construye de abajo hacia arriba, es decir, desde las hojas hasta la raíz, y de forma transversal, de izquierda a derecha. Para ello se ejecuta una función de hash en pares de nodos recursivamente hasta que solo queda un único hash, este último se le conoce como raíz de Merkle. En nuestra implementación usaremos como función de hash el algoritmo SHA-256, para ello nos apoyaremos en la librería crypto-js. En Bitcoin también se usa este algoritmo, con la diferencia de que se aplica doblemente, es decir, se genera un hash a partir del hash anterior. Nosotros para simplificar, sólo lo aplicaremos una vez.

Veamos un ejemplo, imagina que tenemos una con una colección que contiene los siguientes cuatro elementos:  ‘A’, ‘B’, ‘C’ y ‘D’. A cada uno de estos elementos se le aplica la función hash, cuyos hashes resultantes (HA, HB, HC, y HD) forman las hojas del árbol. Es importante tener en cuenta que la colección de elementos en sí misma no se almacena en el árbol de merkle. A continuación, los pares de hojas consecutivas se concatenan y se les vuelve a aplicar la función hash, de esta manera se obtiene el siguiente nivel de nodos, en este caso HAB y HCD. En el siguiente paso, se aplica la función hash en estos dos últimos nodos obteniendo así la raíz de Merkle (HABCD):

![Merkle Tree](https://swcrafters.fra1.digitaloceanspaces.com/Posts/merkle-tree-typescript/Merkle%20Tree%20nodos%20pares.png)

¿Qué pasaría en el caso de tener un número impar de hojas o de nodos intermedios? En ese caso lo que se haría es calcular el hash del elemento concatenado consigo mismo, de esta manera mantendremos constantemente los nodos con un número par de elementos. Por ejemplo, si en lugar de la colección anterior tuviéramos A, B y C, tendremos como primer nivel de nodos padre HAB y HCC y como raíz de Merkle HABCC: 

![Merkle Tree](https://swcrafters.fra1.digitaloceanspaces.com/Posts/merkle-tree-typescript/Merkle%20Tree%20Nodos%20Impares.png)

## ¿Cómo lo vamos a implementar?

Para la implementación del algoritmo vamos aplicar un estilo híbrido donde combinaremos algunos elementos de orientación a objetos, como clases y value objects, con algunos elementos de programación funcional como inmutabilidad, recursividad y las funciones de alto nivel map, filter y reduce; además nos pondremos algunas restricciones que me gusta aplicar en mi dia a dia, como evitar el uso de bucles y de bloques else.  

Los árboles en general se pueden representar de múltiples formas, en nuestro caso  lo vamos a hacer mediante una matrix de  bidimensional en la que cada uno de las filas se corresponde con un nivel del árbol, como veremos implementarlo a través de una matriz simplifica la representación y la generación. La matriz la vamos a construir como si de una pila se tratase, apilando las filas. Donde la primera fila insertada contendrá el nodo de hojas y el último la raíz de Merkle. Esta estructura la vamos a definir como una matriz de hashes de solo lectura para evitar mutar su contenido, además la vamos a encapsular dentro de un tipo rico en comportamiento e inmutable, un value object. Para representarlo vamos a utilizar una clase, cuyos métodos estáticos contendrán toda la lógica necesaria para construir la estructura e instanciar el objeto. Y, por otro lado, los métodos de instancia expondrán la API mínima necesaria para poder realizar la prueba de inclusión. 

## Generando el Merkle Tree con TDD

Vamos a implementar la solución al algoritmo aplicando TDD. Empezamos por el primer test, en el que comprobaremos que se genera un árbol de hash binario para una colección dada de elementos. Tratar de resolver directamente este test puede ser un paso demasiado grande. Lo que vamos a hacer es ir añadiendo aserciones intermedias que nos permitan dar pequeños pasos hasta la solución. Luego decidiremos si las dejamos en el test o simplemente las eliminamos. Comenzamos por una aserción que evalúa si las hojas se están generando correctamente para la colección dada. Para generar los hashes nos podemos apoyar en cualquier generador online de SHA256. Recuerda las funciones hash son deterministas, es decir, para una misma entrada siempre se obtiene la misma salida. 

\`\`\`javascript
describe('The Merkle Tree', () => {
	it('generates a binary hash tree from a given collection with an even number of elements', () => {
		const merkelTree = MerkleTree.createTree(['a', 'b', 'c', 'd']);

		expect(merkelTree.getLeaves()).toEqual([
			'ca978112ca1bbdcafac231b39a23dc4da786eff8147c4e72b9807785afee48bb',
			'3e23e8160039594a33894f6564e1b1348bbd7a0088d42c4acb73eeaed59c009d',
			'2e7d2c03a9507ae265ecf5b5356885a53393a2029d241394997265a1a25aefc6',
			'18ac3e7343f016890c510e93f935261169d9e3f565436429830faf0934f4f8e4',
		]);
	});
});
\`\`\`

La función sha256 de crypto-js la vamos a esconder detrás de nuestra propia función hash, en una especie de wrapper, para en el caso de querer reemplazar el tipo de hash o la librería en sí misma sólo haya que cambiarla en un punto. 

\`\`\`javascript
import { SHA256 } from 'crypto-js';

export function hash(value: string) {
	return SHA256(value).toString();
}
\`\`\`

A continuación creamos la clase MerkleTree, en la cual vamos a encapsular la matriz de nodos, esta estructura la vamos a definir como privada y además de tipo ReadonlyArray, esto nos protegerá de mutar la matriz ya que no nos permitirá usar los típicos métodos como push, unshift o shift que mutan el contenido del array. Para la creación definimos un método de factoría donde transformaremos la colección de datos en el tipo que espera el constructor. Para hacer que el test pase implementamos el método getLeaves, que nos devolverá un array con todas las hojas del árbol de manera transversal.

\`\`\`javascript
export class MerkleTree {
	private constructor(private readonly nodeMatrix: ReadonlyArray<ReadonlyArray<string>>) {}

	static create(elements: string[]) {
		const leafNode = elements.map((e) => hash(e));
		return new MerkleTree([leafNode]);
	}

	getLeaves() {
		return this.nodeMatrix[this.nodeMatrix.length - 1];
	}
}
\`\`\`

El siguiente paso más sencillo es construir el primer nivel de nodos padres, esto lo representamos en otra colección apilada sobre la anterior. Como hemos mencionado, los nodos padres se generan a partir de concatenar en pares los nodos hijos y aplicar la función hash. Para evitar el ruido que introducen los hashes en los tests vamos a utilizar directamente la funcion hash que encapsulamos en el apartado anterior.


\`\`\`javascript
describe('The Merkle Tree', () => {
	it('generates a binary hash tree from a given collection with an even number of elements', () => {
		const merkelTree = MerkleTree.create(['a', 'b', 'c', 'd']);

		expect(merkelTree.getLeaves()).toEqual([hash('a'), hash('b'), hash('c'), hash('d')]);
		expect(merkelTree.getNodesByLevel(0).length).toBe(2);
    const expectedABHash = hash(hash('a') + hash('b'));
		const expectedCDHash = hash(hash('c') + hash('d'));
		expect(merkelTree.getNodesByLevel(0)).toEqual([expectedABHash, expectedCDHash]);
	});
});
\`\`\`

Escribimos el código mínimo para que pase el test, para ello calculamos directamente los nodos padres e implementamos el método getNodesByLevel. 

\`\`\`javascript
export class MerkleTree {
	private constructor(private readonly nodeMatrix: ReadonlyArray<ReadonlyArray<string>>) {}

	static create(elements: string[]) {
		const leafNode = elements.map((e) => hash(e));
		const parentNodes = [hash(leafNode[0] + leafNode[1]), hash(leafNode[2] + leafNode[3])];
		const nodes = [parentNodes].concat([leafNode]);
		return new MerkleTree(nodes);
	}

	getNodesByLevel(level: number) {
		return this.nodeMatrix[level];
	}

	getLeaves() {
		return this.nodeMatrix[this.nodeMatrix.length - 1];
	}
}
\`\`\`

Este método nos devuelve los nodos para un nivel particular del árbol, por ahora este solo tiene dos niveles, cero y uno. El nivel cero representa en este momento los padres y el nivel 1 los nodos hoja:

\`\`\`javascript
[
	['62af5c3cb8da3e4f25061e829ebeea5c7513c54949115b1acc225930a90154da',
	'd3a0f1c792ccf7f1708d5422696263e35755a86917ea76ef9242bd4a8cf4891a',],
	['ca978112ca1bbdcafac231b39a23dc4da786eff8147c4e72b9807785afee48bb',
	'3e23e8160039594a33894f6564e1b1348bbd7a0088d42c4acb73eeaed59c009d',
	'2e7d2c03a9507ae265ecf5b5356885a53393a2029d241394997265a1a25aefc6',
	'18ac3e7343f016890c510e93f935261169d9e3f565436429830faf0934f4f8e4',]
]
\`\`\`

Antes de continuar vamos a refactorizar un poco el código, podemos extraer dos métodos estáticos privados, uno para generar el hash de un nodo padre en particular a partir de un índice y otro para generar el conjunto de todos los nodos. Para refactorizar adecuadamente te aconsejo que trates de usar el refactor automático de tu IDE y que siempre mantengas los tests en verde.

\`\`\`javascript
export class MerkleTree {
	private constructor(private readonly nodeMatrix: ReadonlyArray<ReadonlyArray<string>>) {}

	static create(elements: string[]) {
		const leafNode = elements.map((e) => hash(e));
		const nodes = generateParentNodes(leafNode);
		return new MerkleTree(nodes);
	}

	private static generateParentNodes(leafNode: string[]) {
		const parentNode =  [this.generateParentHashNode(0, leafNode), this.generateParentHashNode(2, leafNode)]
		const nodes = [parentNodes].concat([leafNode]);
		return nodes;
	}

	private static generateParentHashNode(index: number, node: string[]) {
		return hash(node[index] + node[index + 1]);
	}

	getNodesByLevel(level: number) {
		return this.nodeMatrix[level];
	}

	getLeaves() {
		return this.nodeMatrix[this.nodeMatrix.length - 1];
	}
}
\`\`\`

Antes de continuar podemos refactorizar un poco más, se me ocurre que podríamos generar el nivel de nodos padres sin tener que hardcodear el índice, de esta manera continuamos generalizando y además eliminamos esa duplicidad. Para ello debemos pasarle a la función generateParentHashNode solamente índices pares, siempre y cuando estos sean estrictamente menor que la longitud total del nodo. Vamos a implementar esta parte primero de forma imperativa y luego con un estilo más funcional:

\`\`\`javascript
private static generateParentNodes(leafNode: string[]) {
		const nodes = [];
		nodes.push(leafNode)
		for (let i = 0; i < leafNode.length; i++) {
			if (i % 2 == 0) {
				nodes.push(this.generateParentHashNode(i, leafNode));
			}
		}
		return nodes;
	}
\`\`\`

Una alternativa funcional podría ser proyectar un array de índices pares, haciendo uso de una función que genere un array a partir de un rango. La función range suele formar parte de la librería estándar en la mayoría de lenguajes modernos, aunque en javascript no hay una implementación per se. Típicamente se suele hacer uso de lodash o alguna otra librería de utilidades, pero personalmente prefiero construirme este tipo de elementos para minimizar el uso y actualización de librerías de terceros. Una implementación válida para este propósito podría ser la siguiente:

\`\`\`javascript
function range(from:number, length:number, steps = 1): number[] {
	return Array.from({ length: length }, (_, i) => (i + from) * steps);
}
\`\`\`

Con esta pieza ya podemos reemplazar el bucle por una alternativa declarativa. Donde el rango empezaria en cero, el número de elementos sería la mitad del número de hojas y los pasos serían dos:

\`\`\`javascript
private static generateParentNodes(leafNode: string[]) {
		const length = Math.round(leafNode.length / 2);
		const parentNode = range(0, length, 2).map((i) => this.generateParentHashNode(i, leafNode));
		return  [parentNode].concat([leafNode]);
	}
\`\`\`

## Merkle Root
Nuestro árbol de Merkle aun no esta completo, por ahora solo estamos generando las hojas y el primer nivel de padres. Para completar el árbol tenemos que ser capaces de generar n número de nodos padres hasta llegar a obtener un nivel con un solo hash, la raíz de Merkle. Esta pieza es clave, ya que, junto con el Merkle Path, nos permitirá verificar si un determinado dato se encuentra ha formado parte del árbol sin tener que reconstruirlo entero. 

Continuamos desarrollando nuestro primer test, vamos añadir una aserción que evalúa que estamos generando la raiz de merkle. También tenemos que modificar la aserción anterior ya que ahora los nodos padres intermedios tienen que estar en el nivel 1 en lugar del cero: 

\`\`\`javascript
describe('The Merkle Tree', () => {
	it('generates a binary hash tree from a given collection with an even number of elements', () => {
		const merkelTree = MerkleTree.create(['a', 'b', 'c', 'd']);

    const expectedHashedLeaves = [hash('a'), hash('b'), hash('c'), hash('d')];
		const expectedABHash = hash(hash('a') + hash('b'));
		const expectedCDHash = hash(hash('c') + hash('d'));
		const expectedLevelOneHashedNodes = [expectedABHash, expectedCDHash];
		const expectedMerkleRoot = hash(expectedABHash + expectedCDHash);
		expect(merkelTree.getLeaves()).toEqual(expectedHashedLeaves);
		expect(merkelTree.getNodesByLevel(1).length).toBe(2);
		expect(merkelTree.getNodesByLevel(1)).toEqual(expectedLevelOneHashedNodes);
		expect(merkelTree.getNodesByLevel(0).length).toBe(1);
		expect(merkelTree.getMerkleRoot()).toBe(expectedMerkleRoot);
	});
});
\`\`\`

Para resolver esto vamos a utilizar un enfoque parecido al anterior. Lo implementaremos de primero de forma imperativa y luego veremos cómo resolverlo de forma recursiva. El paso más pequeño para hacer que el test pase es utilizar un bucle while que genere y concatene los nodos padres hasta que el nodo root solo contenga un elemento:

\`\`\`javascript
	private static generateParentNodes(leafNode: string[]) {
		let nodes = [leafNode].concat([]);
		while (nodes[0].length > 1) {
			const length = Math.round(nodes[0].length / 2);
			const parentNode = range(0, length, 2).map((i) => this.generateParentHashNode(i, nodes[0]));
			nodes = [parentNode].concat(nodes);
		}
		return nodes;
	}
\`\`\`

Una vez tenemos el test en verde vamos a refactorizar aplicando un enfoque recursivo. El primer paso para transformar el bucle a una función recursiva es representar el acumulador como un parámetro de la función. A continuación debemos especificar la condición de salida de la función recursiva, la cual la ya definimos en el bucle while anterior:

\`\`\`javascript
private static generateParentNodes(leafNode: string[], nodes = [leafNode].concat([])) {
		if (nodes[0].length > 1) {
			const length = Math.round(nodes[0].length / 2);
			const parentNode = range(0, length, 2).map((i) => this.generateParentHashNode(i, nodes[0]));
			return this.generateParentNodes(leafNode, [parentNode].concat(nodes));
		}
		return nodes;
	}
\`\`\`

Como norma general a la hora de escribir funciones recursivas debemos tratar de diseñarlas con recursividad final, para aprovechar la optimización por recursión en cola (tail call optimization) que nos ofrecen los diferentes intérpretes y compiladores de los lenguajes modernos. Por cierto, en JavaScript se propuso en ES6, pero actualmente solamente Safari le da soporte. En su momento el V8 engine de Chrome también lo soportó pero por el momento no está de vuelta, así que ojo con los desbordamientos de pila en NodeJS. Aunque esta optimización no aplique en nuestro caso, vamos a refactorizar para dejar la función con recursividad final, ya que nos va a quedar un código más elegante, de paso aprovechamos para añadir algunas variables explicativas:

\`\`\`javascript
	private static generateParentNodes(leafNode: string[], nodes = [leafNode].concat([])) {
		const rootNode = nodes[0];
		const isValidMerkleRoot = rootNode.length <= 1;
		if (isValidMerkleRoot) {
			return nodes;
		}
		const length = Math.round(rootNode.length / 2);
		const parentNode = range(0, length, 2)
			.map((i) => this.generateParentHashNode(i, rootNode));
		return this.generateParentNodes(leafNode, [parentNode].concat(nodes));
	}
\`\`\`

Ahora que hemos completado el test que genera el árbol de merkle para nodos pares podemos afrontar el caso de los nodos impares. En ese caso lo que ocurre es que nos queda un hash que no tiene pareja con la que concatenarlo. Como vimos en la definición del algoritmo, cuando se da esta situación el nodo padre se obtiene mediante la concatenación del hash hijo consigo mismo y aplicando al resultado la función de hash. Vamos a crear un test partiendo del anterior, en este caso vamos a tener un elemento más, por lo tanto en el nodo que contiene las hojas tendremos cinco hashes, en el siguiente tendremos tres, luego dos y finalmente la raíz:

\`\`\`javascript
it('generates a binary hash tree from a given collection with an odd number of elements', () => {
		const merkelTree = MerkleTree.create(['a', 'b', 'c', 'd', 'e']);

  	const expectedHashedLeaves = [hash('a'), hash('b'), hash('c'), hash('d'), hash('e')];
		const expectedABHash = hash(hash('a') + hash('b'));
		const expectedCDHash = hash(hash('c') + hash('d'));
		const expectedEEHash = hash(hash('e') + hash('e'));
		const expectedLevelTwoHashedNodes = [expectedABHash, expectedCDHash, expectedEEHash];
		const expectedABCDHash = hash(expectedABHash + expectedCDHash);
		const expectedEEEEHash = hash(expectedEEHash + expectedEEHash);
		const expectedLevelOneHashedNodes = [expectedABCDHash, expectedEEEEHash];
		const expectedMerkleRoot = hash(expectedABCDHash + expectedEEEEHash);
		expect(merkelTree.getLeaves()).toEqual(expectedHashedLeaves);
		expect(merkelTree.getNodesByLevel(2).length).toBe(3);
		expect(merkelTree.getNodesByLevel(2)).toEqual(expectedLevelTwoHashedNodes);
		expect(merkelTree.getNodesByLevel(1).length).toBe(2);
		expect(merkelTree.getNodesByLevel(1)).toEqual(expectedLevelOneHashedNodes);
		expect(merkelTree.getNodesByLevel(0).length).toBe(1);
		expect(merkelTree.getMerkleRoot()).toBe(expectedMerkleRoot);
	});
\`\`\`

La implementación de esta parte es trivial, tan solo debemos añadir una condición a la función generateParentHasNode que evalúe si hay un par de hashes para un nodo y un índice determinados, en caso afirmativo crea un hash con la concatenación de los dos nodos y si no genera un hash del nodo concatenado consigo mismo:

\`\`\`javascript
	private static generateParentHashNode(index: number, node: string[]) {
		const hasCoupleOfHashes = index < node.length - 1;
		return hasCoupleOfHashes 
			? hash(node[index] + node[index + 1]) 
			: hash(node[index] + node[index]);
	}
\`\`\`

## Merkle Path

Para demostrar que un dato específico está incluido en un árbol de merkle necesitamos obtener lo que se conoce como Merkle Path o camino de Merkle. En esencia, se trata de una colección que contiene todos aquellos nodos necesarios para reconstruir la raíz de Merkle. Por ejemplo, si queremos obtener el camino de Merkle para el hash del elemento ‘A’, utilizado en el ejemplo del primer test, solo nos harían falta los hashes HB y HCD. Es decir, solo necesitamos un nodo por cada nivel del árbol, por lo tanto la altura del árbol va a coincidir con el número de hashes que necesitamos que incluya el Merkle Path:

![Merkle Path](https://swcrafters.fra1.digitaloceanspaces.com/Posts/merkle-tree-typescript/Merkle%20Path.png)

Ahora que sabemos lo que es un Merkle Path, vamos a implementar una serie de pruebas que cubran algunos casos de uso. Empezar con un test sencillo, en el que se genera un array vacío en el caso de que el hash de un elemento dado no se encuentre entre las hojas del árbol:

\`\`\`javascript
it('does not create the merkle path for a given element that does not exist in the leaves of the tree', () => {
		const merkelTree = MerkleTree.create(['a', 'b', 'c', 'd']);
		
    const merklePath = merkelTree.generateMerklePath('e');

		expect(merklePath).toEqual([]);
});
\`\`\`

Este caso es muy sencillo de implementar, solo tenemos que evaluar el hash del elemento y comprobar que existe entre las hojas:

\`\`\`javascript
	generateMerklePath(element): string[] {
		const leafHash = hash(element);
		const leafLevel = this.nodeMatrix.length - 1;
		const leafIndex = this.getNodesByLevel(leafLevel).findIndex((e) => e == leafHash);
		if (leafIndex <= -1) {
			return [];
		}
	}
\`\`\`

El siguiente caso que vamos a implementar es ‘genera un camino de merkle para un elemento dado que existe en un conjunto par de hojas’. Este caso de uso es un poco más complejo, así que iremos construyendo el test en dos pasos. En esta primera iteración solo obtendremos el primer hash del Merkle path:

\`\`\`javascript
it('generates the merkle path for a given element that exists in a set of even leaves', () => {
		const merkelTree = MerkleTree.create(['a', 'b', 'c', 'd']);
		
    const merklePath = merkelTree.generateMerklePath('a');

		const expectedLeafHash = hash('b');
		expect(merklePath).toEqual([expectedLeafHash]);
});
\`\`\`

Para pasar de rojo a verde, podemos implementar una función que devuelva el nodo vecino. Obteniendo el nodo de la derecha o de la izquierda dependiendo si el índice es par o impar, respectivamente:

\`\`\`javascript
	generateMerklePath(element): string[] {
		const leafHash = hash(element);
		const leafLevel = this.nodeMatrix.length - 1;
		const leafIndex = this.getNodesByLevel(leafLevel).findIndex((e) => e == leafHash);
		if (leafIndex <= -1) {
			return [];
		}
		const merklePath = [];
		merklePath.push(this.getNeighbourBy(leafIndex, leafLevel));
		return merklePath;

	}

	private getNeighbourBy(index: number, level) {
		if (index % 2 == 0) {
			return this.nodeMatrix[level][index + 1];
		}
		return this.nodeMatrix[level][index - 1];
	}
\`\`\`

Con el test pasando le añadimos a la aserción el hash que esperamos del siguiente nivel,  es decir, el que corresponde al hash de los elementos C y D:

\`\`\`javascript
	it('generates the merkle path for a given element that exists in a set of even leaves', () => {
		const merkelTree = MerkleTree.create(['a', 'b', 'c', 'd']);
		
    const merklePath = merkelTree.generateMerklePath('a');

		const expectedLeafHash = hash('b');
		const expectedLevelOneHash = hash(hash('c') + hash('d'));
		expect(merklePath).toEqual([expectedLeafHash, expectedLevelOneHash]);
	});
\`\`\`

Esta parte la vamos a implementar primero con un enfoque imperativo y luego la pasaremos a un enfoque recursivo como hicimos anteriormente. Podemos utilizar un bucle while para ir acumulando los nodos necesarios mientras el nivel sea estrictamente mayor que cero. Necesitaremos ir decrementando el nivel y recalculando el índice: 

\`\`\`javascript
	generateMerklePath(element): string[] {
		const leafHash = hash(element);
		let leafLevel = this.nodeMatrix.length - 1;
		let leafIndex = this.getNodesByLevel(leafLevel).findIndex((e) => e == leafHash);
		if (leafIndex <= -1) {
			return [];
		}
		const merklePath = [];
		while (leafLevel > 0) {
			merklePath.push(this.getNeighbourBy(leafIndex, leafLevel));
			leafLevel--;
			leafIndex = Math.round(leafIndex / 2);
		}
		return merklePath;
	}
\`\`\`

Con el test pasando hacemos un pequeño refactor en el que extraemos un método para facilitarnos la tarea de convertir el bucle a una función recursiva:

\`\`\`javascript
	generateMerklePath(element): string[] {
		const leafHash = hash(element);
		const leafLevel = this.nodeMatrix.length - 1;
		const leafIndex = this.getNodesByLevel(leafLevel).findIndex((e) => e == leafHash);
		if (leafIndex <= -1) {
			return [];
		}
		return this.buildMerklePath( leafLevel,leafIndex);
	}

	private buildMerklePath( level: number, index: number) {
		const merklePath = [];
		while (level > 0) {
			merklePath.push(this.getNeighbourBy(index, level));
			level--;
			index = Math.round(index / 2);
		}
		return merklePath;
	}
\`\`\`

Una vez extraído el método buildMerklePatch generar una función recursiva a partir del código que tenemos es prácticamente trivial. Igual que hicimos con anterioridad, movemos el acumulador a la lista de parámetros de la función y sustituimos el while por una cláusula de guarda en la que directamente devolvemos la llamada recursiva:

\`\`\`javascript
	generateMerklePath(element): string[] {
		const leafHash = hash(element);
		const leafLevel = this.nodeMatrix.length - 1;
		const leafIndex = this.getNodesByLevel(leafLevel).findIndex((e) => e == leafHash);
		if (leafIndex <= -1) {
			return [];
		}
		return this.buildMerklePath(leafLevel, leafIndex);
	}

	private buildMerklePath(level: number, index: number, merklePath = []) {
		if (level > 0) {
			return this.buildMerklePath(
				level - 1,
				Math.round(index / 2),
				merklePath.concat(this.getNeighbourBy(index, level))
			);
		}
		return merklePath;
	}
\`\`\`

Podríamos darle una vuelta más al refactor invirtiendo la condición para hacer recursión en cola y reemplazar la estructura condicional por un ternario:

\`\`\`javascript
	private buildMerklePath(level: number, index: number, merklePath = []) {
		return level <= 0
			? merklePath
			: this.buildMerklePath(
                level - 1, 
                Math.round(index / 2), 
                merklePath.concat(this.getNeighbourBy(index, level))
            );
	}
\`\`\`

A continuación podemos añadir algunos tests más para comprobar que estamos cubriendo correctamente las diferentes casuísticas. También se han eliminado algunas aserciones que eran redundantes. Nuestra suite completa quedaría tal que así:

\`\`\`javascript
import { MerkleTree } from '../core/MerkleTree';
import { hash } from '../core/utils/Crypto';

describe('The Merkle Tree', () => {
	it('creates a binary hash tree from a given collection with an even number of elements', () => {
		const merkelTree = MerkleTree.create(['a', 'b', 'c', 'd']);

		const expectedHashedLeaves = [hash('a'), hash('b'), hash('c'), hash('d')];
		const expectedABHash = hash(hash('a') + hash('b'));
		const expectedCDHash = hash(hash('c') + hash('d'));
		const expectedLevelOneHashedNodes = [expectedABHash, expectedCDHash];
		const expectedMerkleRoot = hash(expectedABHash + expectedCDHash);
		expect(merkelTree.getLeaves()).toEqual(expectedHashedLeaves);
		expect(merkelTree.getNodesByLevel(1)).toEqual(expectedLevelOneHashedNodes);
		expect(merkelTree.getMerkleRoot()).toBe(expectedMerkleRoot);
	});

	it('creates a binary hash tree from a given collection with an odd number of elements', () => {
		const merkelTree = MerkleTree.create(['a', 'b', 'c', 'd', 'e']);

		const expectedHashedLeaves = [hash('a'), hash('b'), hash('c'), hash('d'), hash('e')];
		const expectedABHash = hash(hash('a') + hash('b'));
		const expectedCDHash = hash(hash('c') + hash('d'));
		const expectedEEHash = hash(hash('e') + hash('e'));
		const expectedLevelTwoHashedNodes = [expectedABHash, expectedCDHash, expectedEEHash];
		const expectedABCDHash = hash(expectedABHash + expectedCDHash);
		const expectedEEEEHash = hash(expectedEEHash + expectedEEHash);
		const expectedLevelOneHashedNodes = [expectedABCDHash, expectedEEEEHash];
		const expectedMerkleRoot = hash(expectedABCDHash + expectedEEEEHash);
		expect(merkelTree.getLeaves()).toEqual(expectedHashedLeaves);
		expect(merkelTree.getNodesByLevel(2)).toEqual(expectedLevelTwoHashedNodes);
		expect(merkelTree.getNodesByLevel(1)).toEqual(expectedLevelOneHashedNodes);
		expect(merkelTree.getMerkleRoot()).toBe(expectedMerkleRoot);
	});

	it('does not create the merkle path for a given element that does not exist in the leaves of the tree', () =>{
		const merkelTree = MerkleTree.create(['a', 'b', 'c', 'd']);

		const merklePath = merkelTree.generateMerklePath('e');

		expect(merklePath).toEqual([]);
	});

	it('generates the merkle path for a given element that exists in a set of even leaves', () => {
		const merkelTree = MerkleTree.create(['a', 'b', 'c', 'd']);

		const merklePath = merkelTree.generateMerklePath('a');

		const expectedLeafHash = hash('b');
		const expectedLevelOneHash = hash(hash('c') + hash('d'));
		expect(merklePath).toEqual([expectedLeafHash, expectedLevelOneHash]);
	});

	it('generates the merkle path for a given element in an intermediate position of a set of even leaves', () =>{
		const merkelTree = MerkleTree.create(['a', 'b', 'c', 'd']);

		const merklePath = merkelTree.generateMerklePath('c');

		const expectedLeafHash = hash('d');
		const expectedLevelOneHash = hash(hash('a') + hash('b'));
		expect(merklePath).toEqual([expectedLeafHash, expectedLevelOneHash]);
	});

	it('generates the merkle path for a given element that exists in a set of odd leaves', () => {
		const merkelTree = MerkleTree.create(['a', 'b', 'c', 'd', 'e']);

		const merklePath = merkelTree.generateMerklePath('a');

		const expectedLeafHash = hash('b');
		const expectedLevelTwoHash = hash(hash('c') + hash('d'));
		const expectedEEHash = hash(hash('e') + hash('e'));
		const expectedLevelOneHash = hash(expectedEEHash + expectedEEHash);
		expect(merklePath).toEqual([expectedLeafHash, expectedLevelTwoHash, expectedLevelOneHash]);
	});
});
\`\`\`

Todas las pruebas pasan correctamente. Con esto podemos dar por completada la implementación de la clase Merkle Tree. 

\`\`\`javascript
import { hash } from './utils/Crypto';
import { range } from './utils/Array';

export class MerkleTree {
	private constructor(private readonly nodeMatrix: ReadonlyArray<ReadonlyArray<string>>) {}

	static create(elements: string[]) {
		const leafNode = elements.map((e) => hash(e));
		const nodes = this.generateParentNodes(leafNode);
		return new MerkleTree(nodes);
	}

	private static generateParentNodes(leafNode: string[], nodes = [leafNode].concat([])) {
		const rootNode = nodes[0];
		const isValidMerkleRoot = rootNode.length <= 1;
		if (isValidMerkleRoot) {
			return nodes;
		}
		const length = Math.round(rootNode.length / 2);
		const parentNode = range(0, length, 2).map((i) => this.generateParentHashNode(i, rootNode));
		return this.generateParentNodes(leafNode, [parentNode].concat(nodes));
	}

	private static generateParentHashNode(index: number, node: string[]) {
		const hasCoupleOfHashes = index < node.length - 1;
		return hasCoupleOfHashes ? hash(node[index] + node[index + 1]) : hash(node[index] + node[index]);
	}

	generateMerklePath(element): string[] {
		const leafHash = hash(element);
		const leafLevel = this.nodeMatrix.length - 1;
		const leafIndex = this.getNodesByLevel(leafLevel).findIndex((e) => e == leafHash);
		if (leafIndex <= -1) {
			return [];
		}
		return this.buildMerklePath(leafLevel, leafIndex);
	}

	private buildMerklePath(level: number, index: number, merklePath = []) {
		return level <= 0
			? merklePath
			: this.buildMerklePath(
                level - 1, 
                Math.round(index / 2), 
                merklePath.concat(this.getNeighbourBy(index, level))
            );
	}

	private getNeighbourBy(index: number, level: number) {
		if (index % 2 == 0) {
			return this.getNodesByLevel(level)[index + 1];
		}
		return this.getNodesByLevel(level)[index - 1];
	}

	getMerkleRoot() {
		return this.getNodesByLevel(0)[0];
	}

	getNodesByLevel(level: number) {
		return this.nodeMatrix[level];
	}

	getLeaves() {
		return this.nodeMatrix[this.nodeMatrix.length - 1];
	}
}
\`\`\`



## Prueba de inclusión

La prueba de inclusión, o Merkle proof of inclusion, es un algoritmo que verifica que un elemento concreto se encuentra en un conjunto de datos a partir de un Merkle Path y un Merkle Root. En Bitcoin, todos los nodos ligeros (aquellos que no contienen la Blockchain entera) como por ejemplo podría ser una wallet, son capaces de validar si una transacción está incluida o no en un bloque con tan solo una milésima parte de los datos, gracias al Merkle Root, al Merkle Path y al algoritmo de prueba de inclusión.

Para implementar este algoritmo vamos a construir un pequeño servicio de dominio que recibe en el constructor un Merkle root y un Merkle Path y expone un método que verifica la inclusión de un elemento concreto. Como venimos haciendo hasta ahora vamos a construir primero el test y luego la implementación:

\`\`\`javascript
describe('The Merkle proof of inclusion', () => {
	it('verifies that a element and a given merkle path generates the expected Merkle root for a tree with even nodes', () => {
		const element = 'a';
		const merkelTree = MerkleTree.create(['a', 'b', 'c', 'd']);
		const proofOfInclusion = ProofOfInclusion.create(
			merkelTree.getMerkleRoot(),
			merkelTree.generateMerklePath(element)
		);

		expect(proofOfInclusion.verify(element)).toBeTruthy();
	});
});
\`\`\`

La implementación del método de verificación es bastante simple, en esencia lo que tenemos que hacer es generar el hash del dato recibido por parámetro. Dicho hash lo concatenamos con el merkle path y a continuación reducimos el array generado aplicando la función de hash el resultado de concatenar el hash previo con el actual. Finalmente se compara el resultado con la raíz de Merkle dada:

\`\`\`javascript
export class ProofOfInclusion {
	private constructor(private readonly merkleRoot: string, private readonly merklePath: ReadonlyArray<string>) {}

	static create(merkleRoot: string, merklePath: ReadonlyArray<string>) {
		return new ProofOfInclusion(merkleRoot, merklePath);
	}

	verify(element: string) {
		const hashedElement = hash(element);
		const newMerkleRoot = [hashedElement]
			.concat(this.merklePath)
			.reduce((previousHash, currentHash) => hash(previousHash + currentHash));
		return newMerkleRoot === this.merkleRoot;
	}
}
\`\`\`

Para terminar vamos a añadir algunas pruebas más a la suite, por ejemplo podemos comprobar si un elemento existente en un árbol de merkle con nodos impares lo verifica correctamente y también podemos añadir otro test que evalúe el caso contrario, es decir que no verifique la prueba de inclusión si el elemento no existe:

\`\`\`javascript
import { ProofOfInclusion } from '../core/ProofOfInclusion';
import { MerkleTree } from '../core/MerkleTree';

describe('The Merkle proof of inclusion', () => {
	it('verifies that a given element and a merkle path generate the expected Merkle root for a tree with even nodes', () => {
		const element = 'a';
		const merkelTree = MerkleTree.create([element, 'b', 'c', 'd']);
		const proofOfInclusion = ProofOfInclusion.create(
			merkelTree.getMerkleRoot(),
			merkelTree.generateMerklePath(element)
		);

		expect(proofOfInclusion.verify(element)).toBeTruthy();
	});

	it('verifies that a given element and a merkle path generate the expected Merkle root for a tree with odd nodes', () => {
		const element = 'a';
		const merkelTree = MerkleTree.create([element, 'b', 'c', 'd', 'e']);
		const proofOfInclusion = ProofOfInclusion.create(
			merkelTree.getMerkleRoot(),
			merkelTree.generateMerklePath(element)
		);

		expect(proofOfInclusion.verify(element)).toBeTruthy();
	});

	it('does not verify the inclusion of a data that does not exist', () => {
		const element = 'x';
		const merkelTree = MerkleTree.create(['a', 'b', 'c', 'd']);
		const proofOfInclusion = ProofOfInclusion.create(
      merkelTree.getMerkleRoot(), 
      merkelTree.generateMerklePath('a')
    );

		expect(proofOfInclusion.verify(element)).toBeFalsy();
	});
});
\`\`\`

Con esto damos por finalizada nuestra implementación del árbol de Merkle y la prueba de inclusión. Puedes acceder al repositorio completo [desde aquí](https://github.com/softwarecrafters-io/merkle-tree-typescript). Si el artículo te ha gustado o te ha aportado algún detalle de valor, te agradeceria mucho que lo compartieras en tus redes sociales. 

",
    "slug": "merkle-trees-typescript-tdd",
    "tags": [
      "blockchain",
    ],
    "title": "Merkle Trees y prueba de inclusión con TypeScript y TDD",
    "userPicture": "",
    "username": "Miguel A. Gómez",
  },
  {
    "category": "typescript",
    "cover": "https://swcrafters.fra1.cdn.digitaloceanspaces.com/Categories/TS_category.png",
    "date": "",
    "description": "Un patrón de diseño es un conjunto de recomendaciones que podemos aplicar para resolver problemas de diseño comunes. Creacionales y estructurales ",
    "id": "patrones-diseno-creacionales-estructurales",
    "markdownBody": "Aunque lo sepamos, creo que lo correcto es que empecemos por el principio: *¿qué es un patrón de diseño?* La definición según Wikipedia es:

> Los patrones de diseño son unas **técnicas para resolver problemas comunes en el desarrollo de software** y otros ámbitos referentes al diseño de interacción o interfaces.
> Un patrón de diseño resulta ser una **solución a un problema de diseño**. Para que una solución sea considerada un patrón debe poseer ciertas características. Una de ellas es que **debe haber comprobado su efectividad** resolviendo problemas similares en ocasiones anteriores. Otra es que **debe ser reutilizable**, lo que significa que es aplicable a diferentes problemas de diseño en distintas circunstancias.

Efectivamente, un patrón de diseño no es más que una especie de receta o recomendaciones que podemos aplicar sobre nuestro código para resolver problemas de diseño comunes, incrementando además la calidad de éste, haciéndolo más mantenible, desacoplado y tolerante a cambios. Estas recetas podemos reutilizarlas gracias a que ya han sido probadas anteriormente en situaciones similares por gente que sabe mucho más que nosotros, por lo que su efectividad está más que demostrada.

Los patrones de diseño son uno de los aspectos más importantes de las **bases del desarrollo de software**, que siempre han estado (y estarán) ahí, independientemente de los frameworks y librerías que han ido saliendo al mercado, por lo que es casi obligatorio conocerlos.

Pero cuidado, no dejan de ser una herramienta más que tenemos disponible para desarrollar, por lo que deberemos conocer correctamente la motivación de cada uno de ellos, para saber cuando merece la pena aplicarlos sobre nuestros diseños, **evitando la sobreingeniería**.

A lo largo del artículo, veremos varios de estos **patrones aplicados sobre ejemplos reales** dentro de una aplicación *Angular* en la que trabajamos durante 2 años, implementada con *TypeScript*. De esta forma, evitaremos repasar cada patrón sólo desde el punto de vista teórico, por lo que os resultará más fácil saber si se ajusta a vuestras necesidades o no.

Antes de meternos de lleno con cada patrón, cabe destacar que se suelen agrupar en distintas categorías:
* **Patrones creacionales:** Solucionan problemas de creación de instancias de objetos.
* **Patrones estructurales:** Solucionan problemas de composición y agregación de objetos.
* **Patrones de comportamiento:** Solucionan problemas surgidos sobre las responsabilidades e interacciones entre objetos.
* **Patrones de UI:** Solucionan problemas específicos sobre la capa de presentación de la aplicación.

En este primer artículo nos centraremos en los patrones creacionales y estructurales.

## Patrones creacionales
### Factory method
Nuestro objetivo antes de aplicar este patrón, es crear instancias de un objeto cualquiera *ConcreteProduct*, que puede implementar una interfaz *Product* en caso de que necesitemos instanciar distintos tipos de objetos con una estructura similar:
\`\`\`javascript
interface Product {
  // Contract members
}

class ConcreteProduct1 implements Product {
  // Contract members implemented
}
\`\`\`
El patrón *factory method* nos permite **encapsular** la lógica de creación de ese objeto dentro de las subclases *ConcreteCreators*, descargando de dependencias al cliente que las consume:
\`\`\`javascript
abstract class Creator {
  public abstract factoryMethod(): Product;
}

class ConcreteCreator extends Creator {
  factoryMethod(): Product {
    return new ConcreteProduct1();
  }
}

export class Client {
  createProduct(): Product {
    const creator: Creator = new ConcreteCreator();
    return creator.factoryMethod();
  }
}
\`\`\`
Como podéis ver en el código, *ConcreteCreator* extiende la clase abstracta *Creator* para que podamos asegurarnos de que todas las subclases encargadas de crear las instancias de los distintos tipos de objetos, devuelven un objeto de tipo *Product* y además tienen su correspondiente *factory method* con la misma firma. Además, podemos añadir en esa clase abstracta, más métodos que tengan que ver con la manipulación de los productos.

Además, este patrón favorece la **extensibilidad** siguiendo el [principio de open-close](https://es.wikipedia.org/wiki/Principio_de_abierto/cerrado): podemos añadir un nuevo *ConcreteProduct* con solo cumplir la interfaz, sin tener que modificar los productos existentes. Incluso tenemos la **versatilidad** de intercambiar facilmente un *ConcreteCreator* por otro.

Otra ventaja de este patrón, es que si los objetos *Product* tienen alguna dependencia externa, podemos proporcionárselas mediante su constructor y esta lógica estará encapsulada también. De tal forma que si en el futuro varía alguna de estas dependencias, el punto de colisión en el código es mucho menor, sólo tendremos que modificar la dependencia en la instanciación desde su *ConcreteProduct*, en vez de tener que revisar todos los *Client*.

Una vez recordada la teoría del patrón, vamos a ver cómo lo aplicamos nosotros en el proyecto.

Para el entorno de *Producción*, nos surgió la necesidad de guardar una traza de los eventos y errores que iban sucediendo durante la ejecución de la aplicación en una plataforma *cloud* como es [Application Insights](https://docs.microsoft.com/es-es/azure/azure-monitor/app/app-insights-overview). Sin embargo, para el entorno de *Desarrollo*, queríamos que esos eventos y errores aparecieran en la consola del navegador.

Para ello, definimos la interfaz *Logger* con el método *log* que usaremos para registrar estos eventos y errores. Dicha interfaz la implementan *AppInsightsLogger* que registra la información en la nube y un hipotético *ConsoleLogger* que no hace falta implementarlo puesto que el objeto *console* del navegador ya cumple con esa interfaz. 
\`\`\`javascript
interface Logger {
    log(message: string): void;
}

class AppInsightsLogger implements Logger {
    log(message: string): void {
        (<any>window).appInsights.trackTrace({ message });
    }
}
\`\`\`
Para crear cada uno de los *loggers* tenemos dos clases *AppInsightsLoggerCreator* y *ConsoleLoggerCreator* que pueden ser instanciadas desde cualquier punto de la aplicación, **sin necesidad de conocer cómo deben crearse dichos objetos**, únicamente invocando al *factory method* *getLogger*:
\`\`\`javascript
class ConsoleLoggerCreator
    extends AbstractLoggerCreator {

    protected createLogger(): Logger {
        return console;
    }
}

class AppInsightsLoggerCreator
    extends AbstractLoggerCreator {

    protected createLogger(): Logger {
        return new AppInsightsLogger();
    }
}
\`\`\`
Nótese que ambos *LoggerCreators* extienden la clase abstracta *AbstractLoggerCreator* para evitar que ciertos puntos de la aplicación dependan de un tipo concreto, favoreciendo implementar un **código más genérico y sin duplicidades**. Además, nos permite añadir en dicha clase más métodos que tengan que ver con la manipulación de loggers.
\`\`\`javascript
abstract class AbstractLoggerCreator {
    protected abstract createLogger(): Logger;

    public getLogger(): Logger {
        return this.createLogger();
    }
    // More possible methods about loggers manipulation
}
\`\`\`
En vez de invocar directamente al *factory method* desde el cliente, implementamos una clase intermedia *LoggerCreator* que era la encargada de llamar a este método dependiendo del entorno en el que nos encontrábamos:
\`\`\`javascript
class LoggerCreator {
    public static getLogger(environment): Logger {
        const dictionary = {
            ['DEV']: () => new ConsoleLoggerCreator(),
            ['PROD']: () => new AppInsightsLoggerCreator()
        };
        return dictionary[environment]().getLogger();
    }
}

export class Client {
    constructor(private appConfig: { environment: string }) { }

    main() {
        LoggerCreator.getLogger(this.appConfig.environment).log('a message to log');
    }
}
\`\`\`

### Factory method (with params)
Partimos del objetivo de instanciar tres tipos de objetos diferentes pero con una interfaz común a implementar:
\`\`\`javascript
interface Product {
  // Contract members
}

class ConcreteProduct1 implements Product {
  // Contract members implemented
}

class ConcreteProduct2 implements Product {
  // Contract members implemented
}

class ConcreteProduct3 implements Product {
  // Contract members implemented
}
\`\`\`
Este patrón no deja de ser una variación sobre el patrón *factory method* original, cuya principal diferencia es que **un mismo factory method** de un *ConcreteCreator* puede ser **utilizado para crear estos tres tipos de objetos diferentes**, sólamente pasando por parámetro distintos valores.
\`\`\`javascript
interface Creator {
  factoryMethod(param: 1 | 2 | 3): Product;
}

class ConcreteCreator implements Creator {
  factoryMethod(param: 1 | 2 | 3): Product {
    const dictionary = {
      1: ConcreteProduct1,
      2: ConcreteProduct2,
      3: ConcreteProduct3
    }
    const ConcreteProduct = dictionary[param];
    return new ConcreteProduct();
  }
}

export class Client {
  createProduct(): Product {
    const creator = new ConcreteCreator();
    return creator.factoryMethod(1);
  }
}
\`\`\`
En nuestro caso, teníamos una aplicación basada en formularios, donde los usuarios de cada equipo introducían la información necesaria. Esa información debía ser corregida y validada campo a campo, formulario a formulario por un jefe de equipo. 

Esta funcionalidad de modificación y validación del valor de cada campo se centralizó en un único componente, puesto que lo único que cambiaba era el tipo de datos que recibía y su forma de representación. De esta forma, tenemos:
\`\`\`javascript
@Component({ selector: 'fm-creator-component', template: '' })
export class FactoryMethodCreatorComponent implements OnInit {
    @Input() mode: ComponentModes;
    @Input() data: Array<any>;

    constructor(
        private componentFactoryResolver: ComponentFactoryResolver,
        public viewContainerRef: ViewContainerRef
    ) { }

    ngOnInit() {
        const componentToInstance = ComponentFactory.getComponentByMode(this.mode);
        const componentFactory =
            this.componentFactoryResolver.resolveComponentFactory(componentToInstance);

        this.viewContainerRef.clear();

        const componentInstance =
            this.viewContainerRef.createComponent(componentFactory).instance;
        componentInstance.data = this.data;
    }
}
\`\`\`
Un componente *FactoryMethodCreatorComponent* que es el que se encarga de actuar como *creator* y que no tiene una representación propia, sino que es un mero contenedor que dentro de él renderiza el componente concreto en base al parámetro *mode* que le llega por parámetro como *Input*. Como véis, en nuestro caso no hay un *factory method* que se llame de forma explícita, ya que la "magia" transcurre dentro del método *ngOnInit*.

Por tanto, con esto ya éramos capaces de renderizar en una vista, de forma distinta, una serie de datos con el **componente *creator* y el parámetro como únicas dependencias**. Como se ve en el ejemplo, podemos representar los mismos datos con una caja de texto, un *dropdown* o un *textarea*, usando el mismo componente *creator* y pasándole valores distintos de *mode*.
\`\`\`javascript
@Component({ selector: 'fm-textarea-component', templateUrl: './textarea.component.html' })
export class FactoryMethodTextAreaComponent implements IComponent {
    @Input() data: Array<any>;
}
@Component({ selector: 'fm-text-component', templateUrl: './text.component.html' })
export class FactoryMethodTextComponent implements IComponent {
    @Input() data: Array<any>;
}
@Component({ selector: 'fm-select-component', templateUrl: './select.component.html' })
export class FactoryMethodSelectComponent implements IComponent {
    @Input() data: Array<any>;
}
\`\`\`
Adicionalmente, definimos una interfaz *IComponent* para obligar a que los componentes ligados a las distintas representaciones tengan al menos la misma propiedad *Input* donde recibir los datos a representar. 

Esta relación entre el modo y el tipo de componente a renderizar, la definimos en un diccionario que posteriormente encapsulamos en una factoría que es consultada por el componente *creator*: 
\`\`\`javascript
export class ComponentFactory {
    static getComponentByMode(mode: ComponentModes) {
        const dictionary = {
            [ComponentModes.Text]: FactoryMethodTextComponent,
            [ComponentModes.TextArea]: FactoryMethodTextAreaComponent,
            [ComponentModes.Select]: FactoryMethodSelectComponent
        };
        return dictionary[mode];
    }
}
\`\`\`

## Singleton
Este es sin duda uno de los patrones que más hemos utilizado todos en nuestros proyectos. Su característica principal es que nos permite **crear una instancia única** de un objeto determinado, consiguiendo así un punto centralizado al que podemos acceder desde cualquier punto de nuestro sistema.

Así, desde el punto de vista teórico, tendremos nuestra clase *Singleton* que creará y devolverá mediante el método *build* una instancia de sí misma la primera vez que se llame y reutilizará y devolverá esa misma instancia en el resto de llamadas sucesivas:
\`\`\`javascript
class Singleton {
    private static instance: Singleton;
    private constructor() { }
    static build(): Singleton {
        Singleton.instance = Singleton.instance || new Singleton();
        return Singleton.instance;
    }
}

export class Client {
    getInstance(): Singleton {
        const instance = Singleton.build();
        return instance;
    }
}
\`\`\`
Con esto conseguimos también **evitar la creación de intancias innecesarias**. Hay que tener especial cuidado a la hora de acceder a esa instancia *Singleton* desde distintos puntos, puesto que si lo hacemos sin un orden establecido, obtendremos valores y resultados no esperados.

En nuestro proyecto real, teníamos una parte de generación de informes, donde se utilizaban una serie de templates HTML en los que se representaban una serie de datos almacenados en *data sources*. Todo esto gracias a la librería [Stimulsoft JS](https://www.stimulsoft.com/en/get-started/reports-js). 

Para obtener esos templates HTML, teníamos que hacer llamadas a una API externa. Para ello, creamos un agente intermedio que era el que realizaba las llamadas HTTP necesarias:
\`\`\`javascript
class ReportTemplatesAgent {
    constructor(
        private baseUrl: string,
        private applicationId: string
    ) { }

    getReporTemplates(): Promise<Array<ReportTemplate>> {
        return fetch(
            new Request(\`\${this.baseUrl}/get-all-report-templates\`)
        ).then(response => response.json());
    }
}
\`\`\`
El problema, es que antes de ejecutar esas llamadas HTTP, necesitábamos configurar la URL de la API al iniciar la aplicación SPA. Para ello, implementamos una factoría *ReportTemplatesAgentFactory* que es la que crea el objeto *ReportTemplatesAgent*. Como el inicio de nuestra aplicación y la obtención de las templates HTML se realizan en momentos distintos, esta instancia se crea en forma de *Singleton*:
\`\`\`javascript
class ReportTemplatesAgentFactory {
    private static instance: ReportTemplatesAgent;
    private static config: { baseUrl: string, applicationId: string };

    static use(baseUrl: string, applicationId: string) {
        this.config = { baseUrl, applicationId };
    }

    static build(): ReportTemplatesAgent {
        if (!this.config) {
            throw new Error('You should configure the factory before using it.')
        }
        this.instance = this.instance || new ReportTemplatesAgent(
            this.config.baseUrl,
            this.config.applicationId
        );
        return this.instance;
    }
}

export class Client {
    initializeApp(): void {
        ReportTemplatesAgentFactory.use(
            'https://my-base-url', 'my-app-id');
    }

    async generateReports(): Promise<void> {
        const reportTemplates =
            await ReportTemplatesAgentFactory
                .build().getReporTemplates();
        // Apply datasource over the report templates.
    }
}
\`\`\`

## Patrones estructurales
### Adapter
El patrón *Adapter* o adaptador, nos sirve exactamente para lo que su propio nombre indica: para adaptar **una interfaz** específica, haciéndola compatible con otra, cuando a priori no lo son. Lo de **una interfaz** lo resalto de nuevo para cuando más adelante veamos el patrón *Facade*, puesto que es una de las principales diferencias entre ellos. 

Desde el punto de vista teórico, partimos de la interfaz *Adaptee* que queremos adaptar, y de la interfaz *Target* a la que queremos adaptarla:
\`\`\`javascript
class Adaptee {
    oldMethod(): void { }
}
interface Target {
    requiredMethod(): void;
}
\`\`\`
Finalmente, definimos la clase *Adapter* que implementa la interfaz *Target* y recibirá en su constructor un objeto de la interfaz a adaptar (*Adaptee*). De esta forma, el método de la nueva interfaz que implementa, llamará por debajo al método no adaptado y lograremos nuestro objetivo:
\`\`\`javascript
class Adapter implements Target {
    constructor(private adapteeObject: Adaptee) { }

    requiredMethod(): void {
        this.adapteeObject.oldMethod();
    }
}
export class Client {
    static main(): void {
        const a_compatible_object = new CompatibleObject();
        const a_non_compatible_object = new Adaptee();
        const adapter = new Adapter(a_non_compatible_object);

        a_compatible_object.requiredMethod();
        adapter.requiredMethod();
    }
}
\`\`\`
En nuestro caso, utilizamos este patrón para encapsular ciertos componentes que sabíamos que iban a ser muy cambiantes debido a la indefinición inicial que teníamos del producto. Con ello, **protegeríamos al resto del sistema de dichos cambios**.

Por ejemplo, implementamos un componente personalizado *tooltip* que adaptaba los eventos y propiedades de la librería de terceros *ng2-tooltip-directive*. En este ejemplo, podemos ver como adaptamos el evento *shown* disparado por la directiva de *Angular* *tooltip* a un *Output* personalizado:
\`\`\`html
<i [tooltip]="text" (events)="handleTooltipEvents($event)" class="material-icons">info</i>
\`\`\`
\`\`\`javascript
@Component({
    selector: 'fa-tooltip',
    templateUrl: './tooltip-adapter.component.html'
})
export class TooltipAdapterComponent {
    @Input() text: string;
    @Output() shown: EventEmitter<void> = new EventEmitter<void>();

    handleTooltipEvents(event: { type: string, position: DOMRect }) {
        if (event.type === 'shown') {
            this.shown.emit();
        }
    }
}
\`\`\`
Si examinamos cómo debemos consumir dicho componente desde las vistas de la aplicación:
\`\`\`html
<div class="container">
    <span>One text</span>
    <fa-tooltip class="tooltip" text="one tooltip" (shown)="tooltipWasShown()"></fa-tooltip>
    <span>Another text</span>
    <fa-tooltip class="tooltip" text="another tooltip" (shown)="tooltipWasShown()"></fa-tooltip>
</div>
\`\`\`
Podemos observar que cualquier cambio en la librería de terceros, **sólo afectará** a nuestro componente personalizado, puesto que la dependencia está centralizada en él. 

Este caso específico de la encapsulación del *tooltip* resultó ser una buenísima decisión, puesto que pasados unos meses después del inicio del proyecto, cambiaron los requisitos de negocio respecto al *tooltip*, y no tuvimos más que cambiar la librería por otra y adaptar nuestro componente, el resto del sistema permaneció inalterado.

## Facade
Este patrón es fácilmente confundible con el patrón *Adapter* anterior, de hecho, nosotros mismos los hemos confundido a la hora de identificarlos, ¡no tengáis miedo a equivocaros!. A continuación, voy a intentar aclarar la diferencia entre ambos.

Nuestra principal motivación para este patrón es crear una interfaz (que actuará como *fachada*) para **simplificar la interacción y comunicación con otros subsistemas**. Imaginemos que tenemos tres subsistemas con tres métodos distintos:
\`\`\`javascript
class Part1 {
    method1(): void {
        console.log("method 1 (Part 1)");
    }
}

class Part2 {
    method2(): void {
        console.log("method 2 (Part 2)");
    }
}

class Part3 {
    method3(): void {
        console.log("method 3 (Part 3)");
    }
}
\`\`\`
Estos métodos de cada subsistema, deben ser llamados siempre en un orden concreto. Podemos simplificar las llamadas ordenadas de cada método y centralizarlas en una clase *Facade*:
\`\`\`javascript
class Facade {
    private part1: Part1 = new Part1();
    private part2: Part2 = new Part2();
    private part3: Part3 = new Part3();

    operation1(): void {
        this.part1.method1();
        this.part2.method2();
    }

    operation2(): void {
        this.part1.method1();
        this.part3.method3();
    }
}
\`\`\`
Con ello, además de simplificar las llamadas a los métodos, logramos **encapsular los subsistemas** y los clientes o consumidores no dependerán de ellos. Por tanto, podríamos cambiar la implementación interna de cada subsistema o incluso cambiar la *fachada* siempre que se cumpla la misma interfaz:
\`\`\`javascript
export class Client {
    callOperations(): void {
        const facade = new Facade();
        facade.operation1();
        facade.operation2();
    }
}
\`\`\`
Y aquí podemos ver la **principal diferencia** respecto al patrón *Adapter*. El patrón *Adapter* adapta una interfaz para hacerla compatible con otra, el *Facade* crea y expone una interfaz simplificada para comunicarse con otras interfaces o subsistemas más complejos.

En nuestro proyecto, volviendo al ejemplo de los informes, para obtener sus templates HTML, debíamos utilizar diferentes tipos de servicios. Nuestra aplicación tenía dos posibles modos de ejecución: como una SPA convencional en un navegador web y como una aplicación de escritorio distribuida con [Electron](https://www.electronjs.org/).

En el caso en que estemos ejecutando la aplicación con *Electron*, los templates HTML debíamos obtenerlos desde los *assets* embebidos en la propia instalación de la aplicación. Por tanto, para este proceso, teníamos tres servicios implicados: un servicio para obtener el HTML de los *assets* (*Electron*), otro para obtenerlo en la versión web desde la API y otro para comprobar si estamos en el navegador web o en el escritorio.

Estos servicios podemos verlos a continuación:
\`\`\`javascript
export class AppModeService {
    isOffline(): boolean {
        return !!window.navigator.userAgent.match(/Electron/);
    }
}
export class AssetsService {
    getJsonFromFile(fileName: string): Promise<any> {
        return fetch(new Request(\`./my-assets-path/\${fileName}.json\`))
            .then(response => response.json());
    }
}
export class ReportsService {
    async getAll(): Promise<IReport[]> {
        const reports = await fetch(
            new Request('http://my-reports-rest-api/reports'))
            .then(response => response.json());

        return reports.map((report, index) =>
            ({
                id: index,
                template: 'a-html-report-template',
                name: report.name
            }));
    }
}
\`\`\`
Toda esta lógica para obtener los templates, la simplificamos creando un *ReportsAgentFacade* que actuaba como *fachada*, exponiendo únicamente el método *loadReports* para cargar los informes al inicio de la aplicación y otro método *getReport* para obtener un informe específico y generarlo en otro punto de la aplicación:
\`\`\`javascript
export class ReportsAgentFacade {
    private reportsService = new ReportsService();
    private assetsService = new AssetsService();
    private appModeService = new AppModeService();

    async loadReports(): Promise<IReport[]> {
        let reports: IReport[] = [];
        if (this.appModeService.isOffline()) {
            reports = await this.assetsService.getJsonFromFile('reports');
            localStorage.setItem('reports', JSON.stringify(reports));
        } else {
            reports = await this.reportsService.getAll();
        }
        return reports;
    }

    async getReport(reportId: number): Promise<IReport> {
        let reports: IReport[] = [];
        if (this.appModeService.isOffline()) {
            reports = JSON.parse(localStorage.getItem('reports'));
        } else {
            reports = await this.reportsService.getAll();
        }
        return reports.find(r => r.id === reportId);
    }
}
\`\`\`

### Flyweight
El último de los patrones estructurales que veremos en este artículo, promueve solucionar problemas de rendimiento gracias a la **reducción del número de instancias** almacenadas en la memoria de un sistema. Se basa en, dada una lista de instancias de un tipo de objeto, agruparlas en base a sus propiedades intrínsecas (cuyos valores pueden ser repetidos entre varias instancias) para poder reutilizarlas, y que todas las propiedades extrínsecas (cuyos valores son específicos para cada instancia) sean proporcionadas al objeto en el momento en que se ejecutan sus métodos.

Para entenderlo mejor, vamos a ver un caso teórico/práctico: imaginemos que estamos trabajando con objetos de tipo coche y queremos optimizar nuestro sistema reduciendo el número de instancias que creamos de éstos. Para ello, primero debemos identificar las **propiedades intrínsecas**, las propiedades cuyos valores pueden ser repetidos en varias de las instancias del objeto. Para nuestro caso, estas propiedades podrían ser la marca y el color de cada coche, puesto que dos coches pueden coincidir en marca o color.

Después, identificaremos las **propiedades extrínsecas**, las propiedades cuyos valores son particulares de cada instancia. En nuestro caso, podría ser el kilometraje de cada vehículo. 

Una vez identificadas ambos tipos de propiedades, definimos una interfaz *Flyweight* que cumplirán todas las instancias que almacenemos de cada vehículo, y donde se definirán todas las operaciones que necesitemos que se ejecuten sobre ellos, pasando por parámetro las propiedades extrínsecas si fueran necesarias para dichas operaciones. Esta interfaz es implementada por cada instancia *ConcreteFlyweight* específica de cada coche:
\`\`\`javascript
interface Flyweight {
    operation(extrinsicState);
}

class ConcreteFlyweight implements Flyweight {
    operation(extrinsicState) { }
}
\`\`\`
Estos objetos *ConcreteFlyweight* serán creados a partir de una factoría *FlyweightFactory*, que será la encargada de almacenar la instancia de cada *flyweight* en un diccionario interno indexado por las propiedades intrínsecas como clave. De este modo, la primera vez que recibamos unos valores específicos de las propiedades intrínsecas, se creará la instancia y se almacenará en el diccionario. La próxima vez que se reciban los mismos valores, se evitará la creación de una nueva instancia y se recuperará la que contenga el diccionario:
\`\`\`javascript
class FlyweightFactory {
    private flyweights: { [key: string]: Flyweight };

    getFlyWeight(intrinsicState): Flyweight {
        const key = this.getKey(intrinsicState);
        if (!this.flyweights[key]) {
            const newFlyweight = new ConcreteFlyweight();
            this.flyweights[key] = newFlyweight;
            return newFlyweight;
        } else {
            return this.flyweights[key];
        }
    }

    private getKey(intrinsicState): string {
        return \`\${intrinsicState.model}-\${intrinsicState.color}\`;
    }
}

export class Client {
    run() {
        const factory = new FlyweightFactory();
        const car1 = factory.getFlyWeight({ model: 'BMW', color: 'red' });
        const car2 = factory.getFlyWeight({ model: 'BMW', color: 'red' });
        const car3 = factory.getFlyWeight({ model: 'Toyota', color: 'white' });
        car1.operation({ km: 1000 });
        car2.operation({ km: 200 });
        car3.operation({ km: 3500 });
    }
}
\`\`\`
En nuestro proyecto real, reinterpretamos este patrón para solucionar un problema de rendimiento importante con el que nos encontramos. Teníamos el típico componente modal para mostrar información al usuario. El problema es que este modal estaba referenciado (e instanciado por tanto) en cada componente que lo mostraba. Aplicando nuestro *flyweight* particular, identificamos que la propiedad intrínseca de nuestro objeto componente, era el propio modal, en todas las instancias eran iguales, con la excepción del texto que mostrábamos en cada momento (nuestra propiedad extrínseca).

Por tanto, definimos un componente *FlyweightDialogComponent*:
\`\`\`javascript
@Component({
    selector: 'fly-dialog',
    templateUrl: 'dialog.component.html',
    styleUrls: ['./dialog.component.css']
})
export class FlyweightDialogComponent {
    text = '';
    visible = false;
    show(text: string) { this.text = text; this.visible = true; }
    close() { this.visible = false; }
}
\`\`\`
Que estará centralizado como **una instancia única** en un componente principal de la aplicación (en nuestro caso era el componente *app*):
\`\`\`javascript
@Component({
    selector: 'flyweight',
    templateUrl: './real-world.component.html',
    styleUrls: ['./real-world.component.css']
})
export class FlyweightRealWorldComponent {
    @ViewChild('dialog', { static: false }) dialog: FlyweightDialogComponent;
    showFlyweightDialog(extrinsicInfoText: string) {
        this.dialog.show(extrinsicInfoText);
    }
}
\`\`\`
\`\`\`html
<h3>Flyweight implementation:</h3>
<fly-refactored-info infoText="first info" (showDialog)=showFlyweightDialog($event)></fly-refactored-info>
<fly-refactored-info infoText="second info" (showDialog)=showFlyweightDialog($event)></fly-refactored-info>
<fly-dialog #dialog></fly-dialog>
\`\`\`
Cada vez que se referencie al diálogo modal, se ejecutará al método de *show* de la instancia única, proporcionándole el texto que debe mostrar en ese momento.


# Aún hay mas...
Este ha sido el primer artículo de la serie de patrones de diseño en TypeScript en el mundo real. Nos hemos centrado en los patrones creacionales y estructurales. En el siguiente post hablaremos sobre algunos [patrones de UI y de comportamiento](/typescript/patrones-diseno-comportamiento-ui).

Si quieres seguir profundizando en todos los patrones que hemos utilizado en nuestra aplicación podéis consultar la [charla](https://www.youtube.com/watch?v=ZlhKj32KlfI) que impartimos en la JSDay Canarias 2019 y su [repositorio de código](https://github.com/cbastos/jsdaycan2019-typescript-patterns) correspondiente con ejemplos.

Además, no puedo dejar de recomendar el libro que más me ha servido de ayuda y que mejor explica la mayoría de patrones: **Head First Design Patterns** de *Eric Freeman*, *Elisabeth Freeman*, *Kathy Sierra* y *Bert Bates*.

Espero que os haya resultado útil el artículo, y cualquier duda/pregunta/sugerencia podéis encontrarme en twitter como [@ivanirega](https://twitter.com/ivanirega). Y recuerda: *"Donde hay patrón, no manda marinero"* 😉",
    "slug": "patrones-diseno-creacionales-estructurales",
    "tags": [
      "typescript",
    ],
    "title": "Patrones de diseño con TypeScript en el mundo real: creacionales y estructurales",
    "userPicture": "",
    "username": "Iván Reinoso",
  },
  {
    "category": "devops",
    "cover": "https://swcrafters.fra1.cdn.digitaloceanspaces.com/Categories/docker_category.png",
    "date": "",
    "description": "*Dockerizar* un proyecto Nodejs es bastante sencillo, en este artículo veremos el paso a paso y comentaremos buenas prácticas a tener en cuenta.",
    "id": "docker-nodejs-buenas-practicas",
    "markdownBody": "**Docker** nos permite ejecutar de forma aislada, aunque esto realmente es un truco, ya que **Docker** lo que hace es usar tecnologías como \`Cgroups\` (permite poner límites de recursos a procesos por ejemplo de memoria, CPU, etc) y \`namespaces\` (permite definir qué es lo que puede ver cada proceso) para que parezca que se ejecuta todo en una maquina independiente.

Una de las ventajas de **Docker** es la rapidez en comparación con una VM, podemos disponer de un sistema Ubuntu en cuestión de segundos.

En **Docker** disponemos de diferentes herramientas que podemos utilizar:

- **Docker Engine:** Herramienta para gestionar las imágenes, contenedores, red, etc.
- **docker-compose:** Se trata de una forma de conectar diferentes contenedores, hablaremos de él más adelante.
- **Docker Hub:** Es como GitHub, una plataforma en la que podemos crear, administrar y subir nuestras imágenes.

*Dockerizar* un proyecto **Node.js** es bastante sencillo, en este artículo veremos el paso a paso y comentaremos buenas prácticas a tener en cuenta.

Para este artículo he creado un repositorio en el que podrás comprobar y descargarte los diferentes ejemplos, en enlace para cada uno lo encontrarás junto a 👩‍💻.

Tras esta breve intro vamos al lio!

## Step 1: *Dockerizando* un API Node.js simple

Lo primero es crear un fichero \`Dockerfile\` en la raíz del proyecto, en este fichero vamos a indicar los mismos pasos que realizamos nosotros para construir nuestra API de forma manual, de modo que **Docker** sea capaz de hacerlo automáticamente.

⚠️ esto lo que podemos encontrar en varios artículos de *dockerización* de un proyecto **Node.js**.

\`\`\`docker
FROM node  
WORKDIR /usr/src/app

COPY . .
RUN npm install

EXPOSE 3000
CMD ["node", "server.js"]
\`\`\`

### 👌 **Good practice:** version

Lo mejor a la hora de crear nuestro \`Dockerfile\`, desde otra imagen, es indicar **siempre** la versión que queremos utilizar, de modo que nos aseguramos que ésta es compatible con nuestra API.

\`\`\`docker
# ❌
FROM node   

# 👌
FROM node:14.4.0
\`\`\`

### 👌 **Good practice: .**dockerignore

Solo debemos copiar lo necesario para desplegar nuestro proyecto. Con el \`Dockerfile\` anterior podemos observar lo siguiente:

Si añadimos un fichero a nuestra carpeta \`node_modules\` podemos comprobar que éste se copiará también en nuestro contenedor, por ejemplo \`testFile.txt\`.
![Art%20culo%20Docker%20Node%20Good%20Practice%20d7dd96e770794a808ff07e6c97dd664b/Screenshot_2020-06-13_at_13.55.44.png](https://swcrafters.fra1.digitaloceanspaces.com/Posts/docker-nodejs-buenas-practicas/Screenshot_2020-06-13_at_13.55.44.png)

\`\`\`bash
# Construimos la imagen
➜  docker build -t node-test .

# Arrancamos la imagen
➜  docker run node-test

# Contenedores
➜  docker ps
CONTAINER ID        IMAGE          COMMAND                  CREATED             STATUS              PORTS              NAMES
6418ce58579f        node-test      "docker-entrypoint.s…"   5 seconds ago       Up 5 seconds        3000/tcp           brave_mahavira

# Accedemos al contenedor
➜  docker exec -it 641 bash

# Comprobamos 
root@6418ce58579f:/usr/src/app# cd node_modules/
root@6418ce58579f:/usr/src/app/node_modules# ls
\`\`\`

![Art%20culo%20Docker%20Node%20Good%20Practice%20d7dd96e770794a808ff07e6c97dd664b/Screenshot_2020-06-13_at_14.03.10.png](https://swcrafters.fra1.digitaloceanspaces.com/Posts/docker-nodejs-buenas-practicas/Screenshot_2020-06-13_at_14.03.10.png)

De igual modo revisando el contenedor podemos ver que en el \`WORKDIR\` del mismo se han copiado algunos ficheros y directorios como: \`.git\` \`.gitignore\` \`.idea\`, que no son necesarios.

\`\`\`bash
root@6418ce58579f:/usr/src/app# ls -la
\`\`\`

![Art%20culo%20Docker%20Node%20Good%20Practice%20d7dd96e770794a808ff07e6c97dd664b/Screenshot_2020-06-13_at_14.18.13.png](https://swcrafters.fra1.digitaloceanspaces.com/Posts/docker-nodejs-buenas-practicas/Screenshot_2020-06-13_at_14.18.13.png)

\`.dockerignore\` se comporta igual que el \`.gitignore\`. Esto ayuda a que las imágenes que creamos sean más ligeras y seguras.

![Art%20culo%20Docker%20Node%20Good%20Practice%20d7dd96e770794a808ff07e6c97dd664b/Screenshot_2020-06-13_at_14.35.54.png](https://swcrafters.fra1.digitaloceanspaces.com/Posts/docker-nodejs-buenas-practicas/Screenshot_2020-06-13_at_14.35.54.png)

### 👌 **Good practice:** order and layers

Es de vital importancia tener en cuenta como **Docker** genera las capas, y el orden en que estas se ejecutan.

Usando el ejemplo anterior vamos hacer una comparativa de dos \`Dockerfiles\`. 

\`\`\`docker
FROM node:14.4.0
WORKDIR /usr/src/app

# ❌ 
COPY . .

EXPOSE 3000
CMD ["node", "server.js"]
\`\`\`

En éste tenemos **5 capas** (5 sentencias), y cada vez que modifiquemos algo en nuestro proyecto tanto el \`COPY\` como las siguientes sentencias se volverán a ejecutar (**Docker** no puede cachear estas capas, ya que han cambiado).

![Art%20culo%20Docker%20Node%20Good%20Practice%20d7dd96e770794a808ff07e6c97dd664b/Screenshot_2020-06-13_at_14.57.00.png](https://swcrafters.fra1.digitaloceanspaces.com/Posts/docker-nodejs-buenas-practicas/Screenshot_2020-06-13_at_14.57.00.png)

En el siguiente \`Dockerfile\` tenemos **7 capas** (7 sentencias) que al disponerlas en el orden que se indica, nos aseguramos de no ejecutar sentencias ya cacheadas innecesariamente.

\`\`\`docker
FROM node14.4.0
WORKDIR /usr/src/app

# 👌
COPY package*.json ./
RUN npm install

COPY . .

EXPOSE 3000
CMD ["node", "server.js"]
\`\`\`

Aunque modifiquemos nuestro código, siempre que no modifiquemos algunos de los \`package*.json\`, no se ejecutará, ni la copia de los mismos, ni el correspondiente \`npm install\`.

Ahorrándonos mucho tiempo de construcción.

![Art%20culo%20Docker%20Node%20Good%20Practice%20d7dd96e770794a808ff07e6c97dd664b/Screenshot_2020-06-13_at_14.59.47.png](https://swcrafters.fra1.digitaloceanspaces.com/Posts/docker-nodejs-buenas-practicas/Screenshot_2020-06-13_at_14.59.47.png)

![Art%20culo%20Docker%20Node%20Good%20Practice%20d7dd96e770794a808ff07e6c97dd664b/Screenshot_2020-06-13_at_15.00.09.png](https://swcrafters.fra1.digitaloceanspaces.com/Posts/docker-nodejs-buenas-practicas/Screenshot_2020-06-13_at_15.00.09.png)

Una vez tengamos el \`Dockerfile\` lo ejecutamos de la siguiente manera:

\`\`\`bash
➜  docker run -p 3001:3000 node-test
\`\`\`

👩‍💻[https://github.com/yodra/movies-api](https://github.com/yodra/movies-api)

## Step 2: Usando Multistage

En el proceso de desarrollo existen diferentes fases para obtener el código que finalmente se desplegará en producción. **Docker** proporciona multistage, que permite poder ejecutar cada fase en diferentes contenedores. 

A modo de ejemplo hemos implementado la misma API de Movies en TypeScript que necesita ser transpilada antes de correr en producción.

Por lo que ahora tendríamos el siguiente \`Dockerfile\`:

\`\`\`docker
FROM node:14.4.0 as trasnpiledApi
WORKDIR /usr/src/app

COPY package*.json ./
RUN npm install

COPY . .
RUN npm run build

# Deploy
FROM node:14.4.0
WORKDIR /usr/src/app

COPY package*.json ./
RUN npm install --production

COPY --from=trasnpiledApi /usr/src/app/dist .

EXPOSE 3000
CMD ["node", "server.js"]
\`\`\`

### 👌 **Good practice: Multistage**

Separando fases como compilación, transpilación, empaquetado... nuestras imágenes de producción serán más ligeras y seguras.

👩‍💻 [https://github.com/yodra/movies-api/tree/multistage](https://github.com/yodra/movies-api/tree/multistage)

## Step 3: Añadimos docker-compose

Ya tenemos *dockerizada* la API y solo nos queda conectarla con una base de datos, para conectar diferentes contenedores entre si utilizamos \`docker-compose\`. Éste es un fichero de configuración \`.yml\` que se encargará de orquestar como se arrancaran cada uno de los contenedores que necesitamos además de conectarlos entre si.

En este fichero especificamos cada uno de los servicios con los que contaremos y las dependencias entre ellos.

\`\`\`yaml
version: '3.8'
services:
  app:
    build: .
    ports:
      - 3000:3000
    depends_on:
      - database
  database:
    image: mongo:3.6.18-xenial
    expose:
      - 27017
    volumes:
      - mongodata:/data/db
volumes:
  mongodata:
\`\`\`

### 👌 **Good practice: identical as production**

Esto nos permite disponer de la misma configuración en los diferentes entornos. Trabajar en un entorno igual que el de producción nos permite adelantarnos a posibles errores.

👩‍💻[https://github.com/yodra/movies-api/tree/docker-compose](https://github.com/yodra/movies-api/tree/docker-compose)

### Resumen de comandos

Aquí algunos de los comandos que podemos necesitar a la hora de trabajar con \`docker-compose\`.

![Art%20culo%20Docker%20Node%20Good%20Practice%20d7dd96e770794a808ff07e6c97dd664b/Screenshot_2020-06-21_at_11.56.26.png](https://swcrafters.fra1.digitaloceanspaces.com/Posts/docker-nodejs-buenas-practicas/Screenshot_2020-06-21_at_11.56.26.png)

**Docker** es una herramienta que facilita el desarrollo y todos deberíamos aplicar en nuestros proyectos, a modo de guía he creado una chuleta, la cual incluye un resumen de lo comentado en este artículo, que puedes encontrar en mi web [https://yodralopez.dev/](https://yodralopez.dev/)",
    "slug": "docker-nodejs-buenas-practicas",
    "tags": [
      "devops",
    ],
    "title": "Docker + NodeJS + Buenas Prácticas",
    "userPicture": "",
    "username": "Yodra López",
  },
  {
    "category": "react",
    "cover": "https://swcrafters.fra1.cdn.digitaloceanspaces.com/Categories/ReactJS_category.png",
    "date": "",
    "description": "¿TDD en el FrontEnd? En este post veremos como aplicarlo con React y TypeScript.",
    "id": "tdd-react-typescript",
    "markdownBody": "En los últimos años ha habido un auge en la comunidad referente al interés por el [codigo limpio](/javascript/clean-code-javascript), el tener unos buenos 
tests para nuestras aplicaciones y una preocupación por buscar la forma correcta o más viable de llevar a cabo estas tareas.

Lo cierto es que no existe una forma que podamos replicar de forma automática en cada proyecto y que nos de un resultado
de calidad por igual, por ejemplo: En un proyecto podemos tener una mayor cantidad de tests *e2e* y que esto nos aporte un 
mayor valor que en otros, ya que se carece de apenas lógica y la aplicación se basa en meras interacciones del usuario;
mientras que en otro caso, nos puede aportar mayor relevancia el tener unos tests unitarios
más granulares debido a la reutilización de componentes.

No te preocupes, lo importante no es decantarse por unos u otros, sino dejar que la propia aplicación defina cual es la 
mejor solución para si misma de forma iterativa. Para ello, [el desarrollo dirigido por test (Test Driven Development, TDD)](/javascript/tdd-test-driven-development) 
es la mejor herramienta que he adoptado en mi día a día y que me permite tener un buen balance en mis desarrollos.

Cabe destacar que en base a mi experiencia, [TypeScript](/typescript/typescript-tutorial-javascript-introduccion) es clave en el mantenimiento de los proyectos. Nunca sabemos que grado de 
conocimiento o nivel de rigurosidad en el desarrollo tendrá la persona que pueda acabar en el proyecto que empezamos, por lo que, el poder apoyarnos en los tipos para definir un esqueleto sólido para nuestros componentes y ser capaz de prevenir los errores más básicos sin tener que añadir pruebas para estos, es sin duda una gran herramienta que debemos tener en cuenta. A demás, al ser un lenguaje tipado la mayoría de editores/IDEs tienen soporte para aplicar refactors de forma automática.

## Pero... ¿En frontend?

Muchos desarrolladores (entre los cuales me incluía) piensan que hay dos posibles enfoques: Si quieres comprobar la 
interfaz de tu aplicación, utiliza tests e2e. Sin embargo, si lo que deseas es verificar que tu código cumple con lo
esperado, utiliza tests unitarios.

Este enfoque no es para nada negativo, pero nos limita mucho a la hora de definir una buena arquitectura. Como comentan 
desarrolladores como *Martin Fowler* o *Robert C. Martin*, un código que no puede ser probado, no es la mejor implementación
del mismo. Por otro lado, añadir una funcionalidad específica a nuestro código para que pueda ser comprobado, sin 
aportar nada de valor, tampoco es una buena opción. ¿Entonces?

Recordemos que el desarrollo dirigido por test tiene como finalidad definir una funcionalidad, mientras que los 
tests generados para ello serán un "daño colateral" (si preferimos llamarlo así) de decantarnos por esta metodología.

Sin ir más lejos, [React](/react/tutorial-react-js-introduccion) es una librería mediante la cual podremos realizar interfaces (tanto web, móviles como de escritorio)
y hacer que haga llamadas a nuestro código javascript para que este a su vez se desarrolle como se requiera: llamar a una API,
persistir en local storage, emitir una acción de callback... etc. Así pues, podemos aplicar esta metodología con total normalidad.

## ¿Cómo empezamos?

Para ponernos manos a la obra, lo primero es que tengamos claro qué funcionalidad vamos a desarrollar, o por lo menos,
cual es el flujo a seguir por el usuario, es decir: necesitamos tener claro cual va a ser el caso de uso que vamos a implementar.

Es muy importante que pensemos en ello desde el punto de vista de la persona que va a utilizar la aplicación, y no desde
el punto de vista del programador. Pensemos que es la capa más cercana al usuario, cuanto más cercana sea la definición de este a como interactuará el usuario final, tendrá un mayor nivel de abstracción y por tanto requerirá menos mantenimiento. Dicho de otra forma:
El código es susceptible de cambiar, la forma en la que el usuario interactúa con la aplicación no (ya que sería otra funcionalidad distinta). 
Si no queremos invertir tiempo en editar tests de algo que ya estaba funcionando, porque hemos cambiado nuestro código, lo mejor será, acercarnos lo más posible a lo que menos debería de cambiar.

Para este ejemplo buscaremos dos casos de uso lo suficientemente simples y que podamos representar de forma sencilla:
- El usuario visitará nuestra web y recibirá un catálogo de productos.
- El usuario seleccionará uno de los productos que tiene en pantalla y podrá añadirlo al carrito.

Daremos por sentado que hemos creado una aplicación \`React\` y que hemos configurado \`jest\` en el proyecto. Es independiente
si hemos utilizado \`create-react-app\`, \`create-next-app\`, si lo hemos creado a mano, o si hemos utilizado otra herramienta.

## e2e tests

En primer lugar definiremos los tests e2e. Estos nos permitirán simular de forma exacta como va a operar el usuario con 
la web. 

Existen muchas herramientas para simular esta interacción, sin embargo, las más utilizadas hoy en día son:
- Cypress
- Puppeteer
- Nightwatch 

En este caso utilizaremos \`cypress\` junto con \`jest\` para ello.

Nos dirigiremos a nuestra aplicación \`React\` (da igual si la hemos creado con CRA, Next o con otra solución a medida) e instalaremos la dependencia:

\`\`\`
npm i -D cypress
\`\`\`

Una vez instalado, debemos arrancar nuestra aplicación y ejecutar cypress para comprobar que todo funciona de forma correcta:

\`\`\`
npx start
npx cypress open
\`\`\`

> Puedes profundizar un poco más en esta área visitando la [documentación oficial](https://docs.cypress.io/guides/getting-started/installing-cypress.html).

Una vez hayamos ejecutado cypress por primera vez, podremos proceder a crear los tests, para ello crearemos un fichero 
\`products-catalog.spec.js\` en el directorio \`cypress/integration\`

Y definiremos el siguiente bloque:

\`\`\`javascript
describe('Product Catalog', () => {

  it('shows the catalog', () => {
    cy.visit('/');
    cy.contains('.products > li');
  });
});
\`\`\`

En este caso lo que haremos es navegar a la raíz de nuestra aplicación y verificar que somos capaces de encontrar un 
listado de productos.

Como handicap, pensemos... ¿Es el usuario capaz de visualizar el árbol DOM? La respuesta es **no**, por lo tanto el 
haber utilizado este tipo de enfoque, va a hacer nuestro test muy frágil. Si por cuestiones de diseño, cambiase el
nombre de la clase \`css\`, o peor aún, si no se utilizase un \`li\`, nuestro test se rompería y tendríamos que dedicar 
tiempo a arreglarlo.

Así pues, pensemos ¿Qué es lo que representa a un producto que indiscutiblemente va a ver el usuario?
A priori se me ocurre que el título. Así pues lo que podemos hacer es buscar por dicho campo.  

\`\`\`javascript
describe('Product Catalogue', () => {

  it('shows the catalog', () => {
    const productTitles = ['Clean Code', 'Clean Architecture', 'Spider-man: Life Story', 'Mastering React']
    cy.visit('/');
    productTitles.map( title => {
      cy.contains(title);
    });
  });
});
\`\`\`

Vale, es muy buena idea... salvo por otro pequeño detalle. ¿De donde vienen los datos? ¿Podemos garantizar que la fuente
de datos no va a cambiar? Por desgracia no. Así que tenemos dos opciones:

- Lanzar los tests e2e, levantando nuestra API con una base de datos específica para pruebas. Esto nos daría un mayor nivel de seguridad, pero tendríamos que invertir mucho tiempo en lo que a configuración se refiere.

- Interceptar la llamada \`http\` y sobrescribir la llamada con unos valores predefinidos, a los que comúnmente se les denomina
[\`fixtures\`](https://en.wikipedia.org/wiki/Test_fixture#Software).

Por suerte, este último método es más sencillo y ya \`cypress\` nos da herramientas para ello, pero vayamos por partes:

En primer lugar debemos crear un fichero \`json\` en el directorio \`cypress/fixtures/catalog/products.json\`:
\`\`\`json
{
  "products": [
    { "title": "Clean Code", "price": 20 },
    { "title": "Clean Architecture", "price": 20 },
    { "title": "Spider-man: Life Story", "price": 20 },
    { "title": "Mastering React", "price": 20 }
  ]
}
\`\`\`

A continuación en nuestro test, tendremos que definir el endpoint que vamos a consumir:
\`\`\`javascript
const productsEndpoint = {
  method: 'GET',
  url: 'http://localhost:4000/products',
};
\`\`\`

Luego definiremos que para cada test, debe de iniciar un servidor de escucha:
\`\`\`javascript
beforeEach(() => {
  cy.server();
});
\`\`\`


Y por último tendremos que interceptar la petición:

\`\`\`javascript
cy.route({...productsEndpoint, response: 'fixture:catalog/products', status: 200 });
\`\`\`

Por lo tanto, el resultado de nuestro test sería el siguiente:

\`\`\`javascript
import { products } from '../fixtures/catalog/products.json'

describe('Product Catalogue', () => {

  const productsEndpoint = {
    method: 'GET',
    url: 'http://localhost:4000/products',
  };

  beforeEach(() => {
    cy.server();
  });

  it('shows the catalog', () => {
    cy.route({...productsEndpoint, response: 'fixture:catalog/products', status: 200 });

    cy.visit('/');
    products.map( ({title}) => {
      cy.contains(title);
    })
  });
})
\`\`\`

> Estos tests, se pasarán en rojo (red) la mayor parte del tiempo, hasta que completemos el desarrollo en su totalidad,
así que si te es más cómodo, puedes marcarlos como \`skipped\` y lanzarlos cada cierto tiempo.

[Github code](https://github.com/adrian-afergon/software-crafters-tdd-react/blob/feature/e2e-tests/e2e/cypress/integration/index.spec.js)

Ahora que ya tenemos nuestro primer test **e2e**, podremos comenzar a implementar nuestra aplicación.

## Unit tests

Ahora bien, una vez hemos definido cual es el caso de uso y cual es la funcionalidad que queremos realizar, pasemos a 
los tests unitarios. En este caso puede haber cierta colisión de intereses, ya que a priori nuestro caso de uso puede 
parecer el mismo, pero su finalidad es completamente distinta:

Mientras que el test e2e nos permite identificar cuando se cumplen las expectativas del cliente; el test unitario nos va
a ayudar a definir una arquitectura que se va a caracterizar por ser modular.

### Instalación
En el siguiente ejemplo vamos a hacer uso de \`testing-library/react\` para montar nuestros componentes y de 
\`testing-library/jest-dom\` para conseguir unas aserciones más humanas.

Para ello ejecutaremos el siguiente comando:

\`\`\`
npm i --save-dev test-library/jest-dom testing-library/react
\`\`\`

Una vez se haya completado la instalación podemos proceder a crear nuestro primer test \`Home.spec.js\`

> Personalmente, al tratarse de test unitarios suelo preferir crearlos en el mismo directorio en el que voy a crear el 
componente

### Primer test - Visualizar datos

El test deberá tener la siguente estructura:
\`\`\`ts
import * as React from 'react';

describe('Home Container', () => {
  it('shows a list of products', () => {
    // ... no code yet
    expect(foundProducts.length).toBe(products.length)
  });
});
\`\`\`

Pero... un segundo, ¿hemos definido un \`expect\`? ¿Y la definición de variables? Es aquí donde empieza a surgir la magia.

Empezando por este punto entendemos que, el número de productos encontrados debe ser igual a uno previamente definido 
en el test y que de alguna forma tendremos que pasárselo al componente, pero ¿cómo? Es a partir de este punto donde 
empezamos a definir arquitectura.

Debemos ser prácticos, no vale buscar soluciones complicadas, debemos dar solvencia al test en el menor tiempo posible. 
Una vez demos con la solución e implementemos la funcionalidad podremos valorar si realmente puede interesar el complicar 
la solución, entendiendo por complicar el hacer nuestra solución genérica a varios casos, en lugar de específica a este caso en concreto.

Para poder recuperar el listado de productos a nuestro componente, que serán devueltos por la API, lo que podemos hacer 
es pasarle a través de propiedades el método encargado de recuperar dicha información. A esto se le conoce como *inyección
de dependencias*. 

Por lo tanto, crearemos un objeto *mock*, el cual devuelva una promesa con nuestros datos:

\`\`\`ts
  it('shows a list of products', () => {
    // Define a data source
    const products: Product[] = [buildProduct({}), buildProduct({})];
    const productsRepository = {
      getProducts: jest.fn(() => Promise.resolve(products))
    };
    const view = render(<Home productsRepository={productsRepository}/>);
    // ... no code yet
    expect(foundProducts.length).toBe(products.length);
  });
\`\`\`

Como podrás observar, hacemos uso de un \`buildProduct\` para definir nuestros valores y no añadir información irrelevante al test (Puedes leer más a cerca del patrón builder [aquí](https://medium.com/lean-mind/make-more-human-readeable-test-14d4230898c)). 
Así pues ya solo nos quedaría buscar a nivel visual la representación de dichos datos. Una de las ventajas de \`testing-library\`
es que nos da unos selectores muy cercanos a la capa de usuario, por lo que como ya comentamos anteriormente, dará una 
mayor longevidad a nuestros tests:

\`\`\`ts
  it('shows a list of products', async () => {
    // Define a data source
    const products: Product[] = [
      buildProduct({handle: 'handle-1', title:'title 1'}),
      buildProduct({handle: 'handle-2', title:'title 2'})
    ];
    const productsRepository = {
      getProducts: jest.fn(() => Promise.resolve(products))
    };
    const view = render(<Home productsRepository={productsRepository}/>);
    // Search in async way all the product titles at the screen
    const foundProducts = await Promise.all(products.map((product) => view.findByText(product.title)));
    expect(foundProducts.length).toBe(products.length);
  });
\`\`\`

Quizás en este proceso te hayan surgido dudas, o incluso durante la definición de entidades, como por ejemplo 
¿qué ocurriría si en lugar de una promesa resuelta, nos devolviese una promesa rechazada? ¿Y si me devuelve un listado vacío?
El pararnos a pensar en definir un caso de uso, nos ayuda a prestar mayor atención a nuestro código y dar con casos límite
más comunes de lo que esperarías. 

Recordemos que hacer varias implementaciones al mismo tiempo, no es la mejor de las ideas; Así pues, a medida que vamos
definiendo un test, podemos anotar el resto de casos para contemplarlos a posteriori.

\`\`\`ts
  // what happen when request fails?
  // what happen when list is empty?  

  it('shows a list of products', async () => {
    // irrelevant for now
  });
\`\`\`
Ahora bien, dado el test, ya hemos asumido ciertas cosas, como que nuestro componente va a recibir un objeto con un método
que recuperará los productos y que por tanto, tendremos que iterar por ellos para visualizarlos. Por el momento, es obligatorio
ejecutar el test y verificar que falla (red). Hecho esto, podemos generar el código del componente en el propio fichero de test: 

\`\`\`ts
interface HomeProps {
  productsRepository: ProductsRepository;
}

export const Home: React.FC<HomeProps> = ({ productsRepository }) => {
  const [products, setProducts] = React.useState<Product[]>([]);
  React.useEffect(() => {
    productsRepository.getProducts().then(setProducts);
  }, []);
  return (
    <section>
      {products.map(product => <article key={product.handle}>{product.title}</article>)}
    </section>
  );
};
\`\`\`

Al ejecutar nuevamente el test, vemos como ahora funciona correctamente (green), por lo que es el momento de **hacer commit**
y plantearnos si aplica algún refactor. En este caso, es el momento de mover nuestro componente al fichero \`Home.jsx\`.

A este proceso se le conoce como **RGR, Red - Green - Refactor**. Solo vamos a modificar código cuando 
nos encontremos en **Green**. Plantear nuevos casos, o refactorizar código en **Red** solo nos llevará a aumentar la 
complegidad de la aplicación e incurrir en errores.

[Github code](https://github.com/adrian-afergon/software-crafters-tdd-react/blob/feature/shown-products/src/components/Home/Home.spec.tsx)

### Casos límite - Lista vacía

Prosigamos con los otros dos casos. ¿Qué ocurre cuando nuestro listado de productos está vacío? A priori lo más sensato es
darle feedback al usuario de que la lista está vacía:

\`\`\`ts
  // what happen when request fails?
  // what happen when list is empty?  

  it('shows a list of products', async () => {
    // completed
  });

  it('shows a message when list is empty', () => {
    // Not implemented yet
    expect(view.queryByText(emptyMessage)).toBeInTheDocument();
  });
\`\`\`

Siguiendo el proceso anterior, podemos darnos cuenta que el mensaje va a ser algo compartido entre el componente y el test,
pero recordemos, ahora no es momento de hacer estos cambios, estamos en **red**.

En esta ocasión cambiaremos el valor que nos devuelve nuestro \`productsRepository\` por un listado vacío, y definiremos una variable\`emptyMessage\`:

\`\`\`ts
  it('shows a message when list is empty', async () => {
    // Define a data source
    const products: Product[] = [];
    const productsRepository = {
      getProducts: jest.fn(() => Promise.resolve(products))
    };
    const emptyMessage = 'No products were found';
    const view = render(<Home productsRepository={productsRepository}/>);

    expect(await view.findByText(emptyMessage)).toBeInTheDocument();
  });
\`\`\`

Lanzamos nuestro test y vemos que efectivamente falla. Actualicemos el componente:

\`\`\`ts
interface HomeProps {
  productsRepository: ProductsRepository;
}

export const Home: React.FC<HomeProps> = ({ productsRepository }) => {
  const [products, setProducts] = React.useState<Product[]>([]);
  React.useEffect(() => {
    productsRepository.getProducts().then(setProducts);
  }, []);
  return (
    <section>
      { products && products.length > 0
        ? products.map(product => <article key={product.handle}>{product.title}</article>)
        : <p>No products were found</p>
      }
    </section>
  );
};
\`\`\`

Estamos en **Green** ahora, podríamos aplicar varios refactors como podría ser:
- Exponer una constante desde el componente con el mensaje de *"No products were found"*.
- Refactorizar nuestro test para mover la definición del servicio a un \`builder\` y que el test sea más legible.
- Mejorar la legibilidad de la condición para mostrar el mensaje

Estos cambios quedarían de la siguiente forma:

\`\`\`ts
  // what happen when request fails?

  const buildProductRepository = (products: Product[]): ProductsRepository => ({
    getProducts: jest.fn(() => Promise.resolve(products))
  });

  it('shows a list of products', async () => {
    // Define a data source
    const products: Product[] = [
      buildProduct({handle: 'handle-1', title:'title 1'}),
      buildProduct({handle: 'handle-2', title:'title 2'})
    ];
    const productsRepository: ProductsRepository = buildProductRepository(products);
    const view = render(<Home productsRepository={productsRepository}/>);
    // Search in async way all the product titles at the screen
    const foundProducts = await Promise.all(products.map((product) => view.findByText(product.title)));
    expect(foundProducts.length).toBe(products.length);
  });

  it('shows a message when list is empty', async () => {
    // Define a data source
    const products: Product[] = [];
    const productsRepository: ProductsRepository = buildProductRepository(products);
    const view = render(<Home productsRepository={productsRepository}/>);

    expect(await view.findByText(HomeText.emptyMessage)).toBeInTheDocument();
  });

\`\`\`

Y nuestro componente:

\`\`\`ts
export enum HomeText {
  emptyMessage = 'No products were found'
}

interface HomeProps {
  productsRepository: ProductsRepository;
}

export const Home: React.FC<HomeProps> = ({ productsRepository }) => {
  const [products, setProducts] = React.useState<Product[]>([]);
  React.useEffect(() => {
    productsRepository.getProducts().then(setProducts);
  }, []);

  const hasProducts = () => products && products.length > 0;

  return (
    <section>
      { hasProducts()
        ? products.map(product => <article key={product.handle}>{product.title}</article>)
        : <p>{HomeText.emptyMessage}</p>
      }
    </section>
  );
};
\`\`\`

[Github code](https://github.com/adrian-afergon/software-crafters-tdd-react/blob/feature/empty-list/src/components/Home/Home.spec.tsx)

### Casos límite - Excepciones

Para finalizar, vamos a manejar el caso de error. Lo más cómodo sería que cambiásemos nuestro \`Promise.resolve\`, por un 
\`Promise.rejected\`, sin embargo, si hacemos este cambio en el builder, romperemos los tests anteriores. Esto nos da a
entender que hemos tomado la decisión de aplicar un refactor a nuestro código, sin tener la información suficiente para hacerlo.

Sin embargo, aprovecharemos la situación para dar con la mejor forma de solucionar este caso, eso si, primero el test en cuestión:
\`\`\`ts
  it('shows a error when products can not be retrieved', async () => {
    // Define a data source
    const error = new Error('irrelevant error');
    const productsRepository: ProductsRepository = {
      getProducts: jest.fn(() => Promise.reject(error))
    };
    const view = render(<Home productsRepository={productsRepository}/>);

    expect(await view.findByText(error.message)).toBeInTheDocument();
  });
\`\`\`

Ahora, vemos fallar el test y pasamos a actualizar nuestro componente con la nueva funcionalidad:

\`\`\`ts
const Home = ({ productsRepository }) => {
  const [products, setProducts] = React.useState<Product[]>([]);
  const [error, setError] = React.useState<Error|null>(null);
  React.useEffect(() => {
    productsRepository.getProducts()
      .then(setProducts)
      .catch(setError);
  }, []);
  return (
    <section>
      { error && <p>{error.message}</p> }
      { hasProducts()
        ? products.map(product => <article key={product.handle}>{product.title}</article>)
        : <p>{HomeText.emptyMessage}</p>
      }
    </section>
  );
};
\`\`\`

Estupendo, ahora todo funciona correctamente, es el momento de refactorizar nuestro \`builder\` sin romper nuestros tests.
La forma más fácil para ello es cambiar el parámetro de entrada por el siguiente:

\`\`\`ts
  const buildProductRepository = (promise: Promise<Product[]>) => ({
    getProducts: jest.fn(() => promise)
  });
\`\`\`

Y por tanto en la definición de los \`productsRepository\` de cada test:

\`\`\`ts
  it('shows a list of products', async () => {
    const products: Product[] = [
      buildProduct({handle: 'handle-1', title:'title 1'}),
      buildProduct({handle: 'handle-2', title:'title 2'})
    ];
    const productsRepository: ProductsRepository = buildProductRepository(Promise.resolve(products));
    // ...
  });

  it('shows a message when list is empty', () => {
    const products: Product[] = [];
    const productsRepository: ProductsRepository = buildProductRepository(Promise.resolve(products));
    // ...
  });

  it('shows a error when products can not be retrieved', () => {
    const error = new Error('irrelevant error');
    const productsRepository: ProductsRepository = buildProductRepository(Promise.reject(error));
    // ...
  });
\`\`\`

Ahora bien, este último paso nos ha permitido cerrar el ciclo del componente y poder pasar a otros componentes.
Estos componentes, no tienen por qué contener ningún test si se tratan de componentes meramente representacionales y
carentes de lógica, tengamos presente que las propias funcionalidades de \`React\` ya están verificadas por su equipo, y
que nosotros solo nos debemos preocupar de nuestra lógica.

A demás, el haber empezado por el componente más alto en el árbol DOM, nos permite que estos componentes que envuelve se
verifique su visualización desde nuestro test principal.

[Github Code](https://github.com/adrian-afergon/software-crafters-tdd-react/blob/feature/handle-exceptions/src/components/Home/Home.spec.tsx)

## Cambios de arquitectura

Para no extendernos demasiado, vamos a dar por sentado que hemos definido el componente \`ProductCard\`:
\`\`\`ts
interface ProductCardProps {
  product: Product;
  onClick?: (handle: string) => void;
}

export const ProductCard: React.FC<ProductCardProps> = ({ product, onClick}) => (
  <div>
    <h3>{product.title}</h3>
    <p>
      Price:
      <span>{product.price}</span>
    </p>
    {
      onClick &&
      <button type="button" onClick={() => { onClick(product.handle); }}>Add to cart</button>
    }
  </div>
);
\`\`\`

Con el siguiente test:

\`\`\`ts
  it('calls with product identifier when is clicked', () => {
    const product = buildProduct({ handle: 'irrelevant-handle' });
    const clickMock = jest.fn();
    const view = render(<ProductCard product={product} onClick={clickMock} />);

    const button = view.getByRole('button');
    fireEvent.click(button);
    expect(clickMock).toHaveBeenCalledWith(product.handle);
  });
\`\`\`
Y que por tanto este componente se utiliza en nuestro \`Home\`:

\`\`\`ts
export const Home: React.FC<HomeProps> = ({ productsRepository }) => {
  const [products, setProducts] = React.useState<Product[]>([]);
  const [error, setError] = React.useState<Error|null>(null);
  React.useEffect(() => {
    productsRepository.getProducts()
      .then(setProducts)
      .catch(setError);
  }, []);

  const hasProducts = () => products && products.length > 0;

  return (
    <section>
      { error && <p>{error.message}</p> }
      { hasProducts()
        ? products.map(product =>
          <article key={product.handle}>
            <ProductCard product={product} />
          </article>)
        : <p>{HomeText.emptyMessage}</p>
      }
    </section>
  );
};
\`\`\`

Ahora bien, somos conscientes de que nuestro \`ProductCard\` tiene un evento de click asociado, y que al ser usado desde \`Home\`,
este debe añadirlo al carrito. Este carrito no tiene nada que ver con la forma en la que recuperamos nuestros productos, sino que es otra nueva entidad que entra en juego.

Para ser consistentes, hemos hecho el test correspondiente para verificar que el comportamiento se cumple:

\`\`\`ts
  it('add item to cart', async () => {
    const firstProduct: Product = buildProduct({handle: 'first-product'});
    const secondProduct: Product = buildProduct({handle: 'second-product'});
    const productsRepository = buildProductRepository(Promise.resolve([firstProduct, secondProduct]));
    const cartRepository = {
      addItem: jest.fn(),
    };

    const view = render(<Home productsRepository={productsRepository} cartRepository={cartRepository} />);

    const [, item] = await view.findAllByRole('button');
    fireEvent.click(item);

    expect(cartRepository.addItem).toHaveBeenCalledWith(secondProduct.handle);
  });
\`\`\`

Y tras ver que falla, hemos actualizado el componente:

\`\`\`ts
export const Home: React.FC<HomeProps> = ({ productsRepository, cartRepository }) => {
  const [products, setProducts] = React.useState<Product[]>([]);
  const [error, setError] = React.useState<Error|null>(null);
  React.useEffect(() => {
    productsRepository.getProducts()
      .then(setProducts)
      .catch(setError);
  }, []);

  const hasProducts = () => products && products.length > 0;

  return (
    <section>
      { error && <p>{error.message}</p> }
      { hasProducts()
        ? products.map(product =>
          <article key={product.handle}>
            <ProductCard
              product={product}
              onClick={cartRepository.addItem}
            />
          </article>)
        : <p>{HomeText.emptyMessage}</p>
      }
    </section>
  );
};
\`\`\`

Ahora bien, tenemos nuestras dependencias y aparentemente nuestros componentes funcionan, pero tendremos que utilizar unos \`repository\` reales.
Para ello simplemente crearemos dichas entidades que serán las encargadas de hacer el fetch a la API real, y definiremos esas constantes como valor por defecto a el componente:

\`\`\`typescript
export const cartRepository: CartRepository = {
  addItem: (handle) => fetch('http://localhost:4000/cart', {
      method: 'PUT',
      body: JSON.stringify({ handle })
  }).then(response => response.json())
};

export const productsRepository: ProductRepository = {
  getProducts: () => 
    fetch('http://localhost:4000/products')
      .then(response => response.json())
      .then(data => data.products)
}
\`\`\`

Y el componente:

\`\`\`ts
import { productsRepository as productsRepositoryInstance, ProductsRepository } from '../../repositories/ProductsRepository';
import { cartRepository as cartRepositoryInstance, CartRepository } from '../../repositories/CartRepository';

interface HomeProps {
  productsRepository?: ProductsRepository;
  cartRepository?: CartRepository;
}

export const Home: React.FC<HomeProps> = ({
  productsRepository = productsRepositoryInstance,
  cartRepository = cartRepositoryInstance,
}) => {
  // ...
}
\`\`\`

Ahora bien, ¿por qué no hemos hecho test de nuestros objetos? Realmente no es necesario, ya que únicamente actúan de proxy a la librería de fetch.
Sin embargo, en caso de que tuviéramos lógica propia, como pudiese ser la transformación de la respuesta a una estructura propia, si podría ser de interés llevar a cabo dicha validación.

[Github Code](https://github.com/adrian-afergon/software-crafters-tdd-react/tree/feature/change-architecture/src)

### Nota final

Te habrás dado cuenta que los test e2e no pasan, ya que no es capaz de interceptar la petición http. Esto se debe a que \`cypress\` solo es capaz de interceptar peticiones \`xhr\`, y el \`fetch\` que estamos utilizando en nuestros \`repository\` no utiliza este tipo de solicitud. Cypress comenzará a dar soporte a partir de la versión \`4.9.0\`.

Para que funcione correctamente tendremos que aplicar el siguiente \`workaround\`: 

\`\`\`ts
/e2e/cypress/support/index.js

import './commands';

let polyfill;

before(() => {
  const polyfillUrl = 'https://unpkg.com/whatwg-fetch@3.0.0/dist/fetch.umd.js';
  cy.request(polyfillUrl).then(response => {
    polyfill = response.body;
  });
});

Cypress.on('window:before:load', win => {
  delete win.fetch;
  win.eval(polyfill);
});
\`\`\`

O como otra opción, podemos cambiar nuestros \`repository\` para que utilicen \`xhr\` y **demostrar que nuestra arquitectura 
se encuentra totalmente desacoplada** entre la vista y el acceso a datos.

[Github Code](https://github.com/adrian-afergon/software-crafters-tdd-react/blob/feature/e2e-workaround/e2e/cypress/support/index.js)

## Conclusión

Como hemos visto, los tests nos ayudan a tomar decisiones sobre nuestro código, a descubrir casos de uso que no nos hayamos planteado inicialmente y por supuesto a verificar de forma automática que nuestro código funciona.

Sin embargo, esto no quiere decir que tengamos que ir a un extremo de que cada línea de código debe ser comprobada, principalmente porque en muchos casos carecerá de sentido o porque esto llevará un tiempo adicional para aprender como comprobar cada cosa en la forma correcta, frente a lo que nos aporta esa comprobación.

Usar TDD como herramienta de desarrollo te abre un mundo de posibilidades como desarrollador, aprenderás como funcionan las tecnologías, entenderás el por qué muchas tecnologías funcionan de una determinada forma, a demás que te permitirá aprender a tomar decisiones técnicas y crecer profesionalmente.

Espero que este artículo te sirva de ayuda y te incentive a comenzar a dar tus primeros pasos en esta metodología de desarrollo.
Puedes visitar el repositorio público en [github](https://github.com/adrian-afergon/software-crafters-tdd-react) para ver el resultado final. 

Ante cualquier duda, o simplemente por el placer de debatir sobre este tema, puedes contactar conmigo a través de my 
twitter [@AdrianFerrera91](https://twitter.com/AdrianFerrera91), o a través de mi [página web](https://adrianferrera.com/) donde también podrás encontrar otros muchos artículos referentes al tema.",
    "slug": "tdd-react-typescript",
    "tags": [
      "react",
    ],
    "title": "TDD en React con TypeScript",
    "userPicture": "",
    "username": "Adrián Ferrera",
  },
  {
    "category": "javascript",
    "cover": "https://swcrafters.fra1.cdn.digitaloceanspaces.com/Categories/JS_category.png",
    "date": "",
    "description": "Clean code o código limpio en español, es un término al que ya hacían referencia desarrolladores de la talla de Ward Cunningham o Kent Beck",
    "id": "clean-code-javascript",
    "markdownBody": "
<blockquote>
    <strong>"Programar es el arte de decirle a otro humano lo que quieres que el ordenador haga."</strong><strong> -- </strong><a href="https://es.wikipedia.org/wiki/Donald_Knuth"><strong>Donald Knuth</strong></a>
</blockquote>

<p>En los &uacute;ltimos a&ntilde;os, JavaScript se ha convertido en uno de los lenguajes m&aacute;s utilizados del mundo. Su principal ventaja, y a la vez su mayor debilidad, es su versatilidad. Esa gran versatilidad ha derivado en algunas malas pr&aacute;cticas que se han ido extendiendo en la comunidad, a&uacute;n as&iacute;, Javascript se encuentra en infraestructuras cr&iacute;ticas de <a href="https://stackshare.io/javascript">empresas muy importantes</a> (Facebook, Netflix o Uber lo utilizan), en las cuales limitar los costes derivados del mantenimiento del <em>software</em> se vuelve esencial.</p>
<p>El coste total de un producto <em>software</em> viene dado por la suma de los costes de desarrollo y de mantenimiento, siendo este &uacute;ltimo mucho m&aacute;s elevado que el coste del propio desarrollo inicial. A su vez, como expone Kent Beck en su libro <a href="https://amzn.to/2BHRU8P"><em>Implementation Patterns</em></a><em>, </em>el coste de mantenimiento viene dado por la suma de los costes de <strong>entender el c&oacute;digo</strong>, <strong>cambiarlo</strong>, <strong>testearlo</strong> y <strong>desplegarlo</strong>. </p>
<img class="align-center" style="width: 75%" src="https://res.cloudinary.com/software-crafters/image/upload/v1551009219/posts/clean_code_javascript/Esquema_costes_Kent_Beck.png" alt="costes-software"/>
<small class="align-center">Esquema de f&oacute;rmula de costes de Kent Beck</small>
<p>La idea de este art&iacute;culo es tratar de minimizar el coste relacionado con la parte de entender el c&oacute;digo, para ello&nbsp;tratar&eacute; de sintetizar y ampliar algunos de los conceptos relacionados con esto que exponen <a href="https://twitter.com/unclebobmartin">Robert C. Martin</a>, <a href="https://twitter.com/KentBeck">Kent Beck</a>, <a href="https://twitter.com/WardCunningham">Ward Cunningham</a> y otros autores aplic&aacute;ndolos a JavaScript. </p>

<h2>&iquest;Qu&eacute; es Clean Code?</h2>
<p><em>Clean code</em> o c&oacute;digo limpio en espa&ntilde;ol, es un t&eacute;rmino al que ya hac&iacute;an referencia desarrolladores de la talla de Ward Cunningham o Kent Beck, aunque no se populariz&oacute; hasta que Robert C. Martin, tambi&eacute;n conocido como <em>Uncle Bob</em>, public&oacute; su libro &ldquo;<a href="https://amzn.to/2TUywwB"><em>Clean Code: A Handbook of Agile Software Craftsmanship</em></a>&rdquo; en 2008. </p>
<p>El libro, aunque sea bastante dogm&aacute;tico y quiz&aacute;s demasiado focalizado en la programaci&oacute;n orientada a objetos, se ha convertido en un cl&aacute;sico que no debe faltar en la estanter&iacute;a de ning&uacute;n desarrollador que se precie, aunque sea para criticarlo. &nbsp;</p>
<img class="align-center" style="width: 75%" src="https://res.cloudinary.com/software-crafters/image/upload/v1549281084/posts/clean_code_javascript/cleancode_wtf.jpg" alt="clean-code"/>
<small class="align-center">Vi&ntilde;eta de <a href="https://www.osnews.com/comics/">osnews.com/comics/</a> sobre la calidad del c&oacute;digo </small>
<p>Existen muchas definiciones para el t&eacute;rmino clean code, pero yo personalmente me quedo con la de mi amigo Carlos Bl&eacute;, ya que adem&aacute;s casa muy bien con el objetivo del art&iacute;culo.</p>
<blockquote><strong>"C&oacute;digo</strong><strong> limpio es aquel que se ha escrito con la intenci&oacute;n de que otra persona (o t&uacute; mismo en el futuro) lo entienda." -- </strong><a href="https://twitter.com/carlosble"><strong>Carlos Bl&eacute;</strong></a></blockquote>
<p>Los desarrolladores solemos escribir c&oacute;digo sin la intenci&oacute;n expl&iacute;cita de que vaya a ser entendido por otra persona, ya que la mayor&iacute;a de las veces nos centramos simplemente en implementar una soluci&oacute;n que funcione y que resuelva el problema. </p>
<p>Tratar de entender el c&oacute;digo de un tercero o incluso el que escribimos nosotros mismos hace tan solo unas semanas, se puede volver una tarea realmente dif&iacute;cil. Es por ello que hacer un esfuerzo extra para que nuestra soluci&oacute;n sea legible e intuitiva es la base para reducir los costes de mantenimiento del <em>software</em> que producimos.</p>
<p>A continuaci&oacute;n veremos algunas de las secciones del libro de Uncle Bob que m&aacute;s relacionadas est&aacute;n con la legibilidad del c&oacute;digo. Si conoces el libro o lo has le&iacute;do, podr&aacute;s observar que he a&ntilde;adido algunos conceptos y descartado otros, adem&aacute;s de incluir ejemplos sencillos aplicados a JavaScript. </p>
<h2>Variables y nombres</h2>
<blockquote><strong>&ldquo;Nuestro c&oacute;digo tiene que ser simple y directo, deber&iacute;a leerse con la misma facilidad que un texto bien escrito&rdquo; -- <a href="https://es.wikipedia.org/wiki/Grady_Booch" target="_blank">Grady Booch</a></strong></blockquote>
<p>Nuestro c&oacute;digo deber&iacute;a poder leerse con la misma facilidad con la que leemos un texto bien escrito, es por ello que <strong>escoger buenos nombres</strong> es fundamental. Los nombres de variables, m&eacute;todos y clases deben seleccionarse con cuidado para que den expresividad y significado a nuestro c&oacute;digo. </p>
<img class="align-center" style="width: 75%" src="https://res.cloudinary.com/software-crafters/image/upload/v1549360879/posts/clean_code_javascript/hardest-problem-naming.jpg" alt="costes-software"/>
<small class="align-center">Vi&ntilde;eta de Commit Strip sobre el nombrado de variables.</small>
<p>A continuaci&oacute;n veremos algunas pautas y ejemplos para tratar de mejorar a la hora de escoger buenos nombres:</p>
<h3><strong>Nombres pronunciables y expresivos</strong></h3>
<p>Los nombres, imprescindiblemente en ingl&eacute;s, deben ser pronunciables. Esto quiere decir que no deben ser abreviaturas ni llevar guion bajo o medio, priorizando el estilo <em>CamelCase</em>. Por otro lado, debemos intentar no ahorrarnos caracteres en los nombres, la idea es que sean lo m&aacute;s expresivos posible.</p>
<pre class="language-javascript"><code>//bad
const yyyymmdstr = moment().format('YYYY/MM/DD');

//better
const currentDate = moment().format('YYYY/MM/DD');
</code></pre>

<h3>Uso correcto de var, let y const</h3>
<p>Debemos evitar a toda costa el uso de <em>var</em>, ya que define las variables con alcance global. Esto no ocurre con las variables definidas con let y const, ya que se definen para un &aacute;mbito en concreto. </p>
<p>La diferencia entre <em>let</em> y <em>const</em> radica en que a esta &uacute;ltima no se le puede reasignar su valor (aunque s&iacute; modificarlo). Es por ello que usar const en variables a las que no tengamos pensado cambiar su valor puede ayudarnos a mejorar la intencionalidad de nuestro c&oacute;digo.</p>
<pre class="language-javascript"><code>// old school JavaScript
var variable = 5;
{
  console.log('variable); // 5
  var variable = 10;
}

console.log(variable); // 10
variable = variable*2;
console.log(variable); // 20

// modern JavaScript (let)
let variable = 5;

{
   console.log(variable); // error
   let variable = 10;
}

console.log(variable); // 5
variable = variable*2;
console.log(variable); // 10

// modern JavaScript (const)
const variable = 5;
variable = variable*2; // error
console.log(variable); // doesn't get here
</code></pre>

<h3><strong>Evitar que los nombres contengan informaci&oacute;n t&eacute;cnica </strong></h3>
<p>Si estamos construyendo un <em>software</em> de tipo vertical (orientado a negocio), debemos intentar que los nombres no contengan informaci&oacute;n t&eacute;cnica en ellos, es decir, evitar incluir informaci&oacute;n relacionada con la tecnolog&iacute;a, como el tipo de dato o la <a href="https://es.wikipedia.org/wiki/Notaci%C3%B3n_h%C3%BAngara">notaci&oacute;n h&uacute;ngara,</a> el tipo de clase, etc. Esto s&iacute; se admite en desarrollo de <em>software</em> horizontal o librer&iacute;as de prop&oacute;sito general.</p>
<pre class="language-javascript"><code>//bad
class AbstractUser(){...}

//better
class User(){...}
</code></pre>

<h3><strong>L&eacute;xico coherente</strong></h3>
<p>Debemos usar el mismo vocabulario para hacer referencia al mismo concepto, no debemos usar en algunos lados <em>User</em>, en otro <em>Client</em> y en otro <em>Customer</em>, a no ser que representen claramente conceptos diferentes. </p>
<pre class="language-javascript"><code>//bad
getUserInfo();
getClientData();
getCustomerRecord();

//better
getUser()
</code></pre>

<h3><strong>Usa el nombre adecuado según el tipo de dato</strong></h3>
<p><strong>Arrays</strong></p>
<p>Los arrays son una lista iterable de elementos, generalmente del mismo tipo. Es por ello que pluralizar el nombre de la variable puede ser una buena idea:</p>

<pre class="language-javascript"><code>//bad
const fruit = ['manzana', 'platano', 'fresa'];
// regular
const fruitList = ['manzana', 'platano', 'fresa'];
// good
const fruits = ['manzana', 'platano', 'fresa'];
// better
const fruitNames = ['manzana', 'platano', 'fresa'];
</code></pre>

<p><strong>Booleanos</strong></p>
<p>Los booleanos solo pueden tener 2 valores, verdadero o falso. Dado esto, el uso de prefijos como "is", "has" y "can" ayudará inferir el tipo de variable, mejorando así la legibilidad de nuestro código.</p>


<pre class="language-javascript"><code>//bad
const open = true;
const write = true;
const fruit = true;

// good
const isOpen = true;
const canWrite = true;
const hasFruit = true;
</code></pre>

<p><strong>Números</strong></p>
<p>Para los números es interesante escoger palabras que describan números, como “min”, “max”, “total”:</p>


<pre class="language-javascript"><code>//bad
const fruits = 3;

//better
const maxFruits = 5;
const minFruits = 1;
const totalFruits = 3;
</code></pre>


<p><strong>Funciones</strong></p>
<p>Los nombres de las funciones deben representar acciones, por ello que deben construirse usando el verbo que representa la acción seguido de un sustantivo. Estos deben de ser descriptivos y, a su vez, concisos. Esto quiere decir que el nombre de la función debe expresar lo que hace, pero también debe de abstraerse de la implementación de la función.</p>
<pre class="language-javascript"><code>//bad
createUserIfNotExists()
updateUserIfNotEmpty()
sendEmailIfFieldsValid()

//better
createUser(...)
updateUser(...)
sendEmail()
</code></pre>

<p>En el caso de las funciones de acceso, modificación o predicado, el nombre debe el prefijo get, set, e is, respectivamente. [i]</p>

<pre class="language-javascript"><code>
getUser()
setUser(...)
isValidUser()
</code></pre>

<p><strong>Clases</strong></p>
<p>Las clases y los objetos deben tener nombres formados por un sustantivo o frases de sustantivo como User, UserProfile, Account, AdressParser. Debemos evitar nombres como Manager, Processor, Data o Info.</p>
<p>Hay que ser cuidadosos a la hora de escoger estos nombres, ya que son el paso previo a la hora de definir la responsabilidad de la clase. Si escogemos nombres demasiado genéricos tendemos a crear clases con múltiples responsabilidades.</p>
",
    "slug": "clean-code-javascript",
    "tags": [
      "javascript",
    ],
    "title": "Clean Code aplicado a Javascript",
    "userPicture": "",
    "username": "Miguel A. Gómez",
  },
  {
    "category": "typescript",
    "cover": "https://swcrafters.fra1.cdn.digitaloceanspaces.com/Categories/TS_category.png",
    "date": "",
    "description": "TypeScript es un lenguaje que extiende JavaScript para dotarlo de tipado estático.",
    "id": "introduccion-typescript-react",
    "markdownBody": "[TypeScript](https://www.typescriptlang.org/) es un lenguaje que extiende JavaScript para dotarlo de un *tipado estático*. Esto quiere decir que la comprobación y verificación de los tipos se realiza en tiempo de *compilación* (cuando se convierte de TS a JS) en vez de en tiempo de *ejecución* (cuando el motor de JS interpreta el código).

Una de las características principales de JavaScript es su dinamismo. Una variable se puede asignar a cualquier tipo, sin necesidad de declararlo previamente.

Este código, aunque engorroso e inútil, sería perfectamente válido en JS:

\`\`\`js
let return;

function cb(value) {
  return = value;
}
\`\`\`

Sin embargo, el compilador de TS necesita conocer previamente qué tipo de valores vamos a asignar a esta variable, de tal forma que se pueda operar con ella con seguridad (por ejemplo evitando que se puedan sumar un *string* y un *number*, dando lugar a resultados impredecibles).

\`\`\`typescript
// la forma de declarar el tipado es añadiendo
// dos puntos ":" junto a la declaración
let return: number;

function cb(value: number) {
  return = value;
}
\`\`\`

Dada la filosofía modular y orientada a componentes de React, TypeScript se convierte en el aliado perfecto, asegurando la perfecta cohesión de todos los elementos de nuestra arquitectura.

## Instalando y configurando el entorno de trabajo

Tal y como cuando trabajamos con JavaScript, la forma más sencilla de configurar el entorno de desarrollo para un proyecto basado en React es usando [create-react-app](https://create-react-app.dev/), con la salvedad de que le pasaremos el parámetro adecuado para configurar nuestra **template** en modo **typescript**:

\`\`\`sh
# yarn
yarn create react-app miproyecto --template typescript

# npx
npx create-react-app miproyecto --template typescript
\`\`\`

Una opción siempre interesante es configurar eslint con el estándar de preferencia, por ejemplo el de [AirBnB](https://www.npmjs.com/package/eslint-config-airbnb-typescript).

## Conceptos básicos

### Variables

En TypeScript todas las variables están designadas dentro de un ámbito (scope), por lo que sólo se puede usar **let** o **const**. Esta última además impide su reasignación. Más sobre el concepto de hoisting: [https://developer.mozilla.org/es/docs/Glossary/Hoisting](https://developer.mozilla.org/es/docs/Glossary/Hoisting).

Cuando declaramos una constante (mediante el uso de **const**) usualmente no necesitamos declarar el tipo, puesto que este se *infiere* automáticamente. Es decir, al declarar un valor, que no se puede reasignar, el compilador es capaz de "adivinar" cuál es el tipo adecuado para ese valor.

\`\`\`typescript
const myStr = 'a'; // el tipo sería 'a', que es un subconjunto de 'string'
const myNumber = 5; // el tipo sería 5, que es un subconjunto de 'number'
\`\`\`

En el caso de una variable (definida con **let**), también se produciría esta inferencia. Sin embargo, puesto que si que se puede reasignar, el tipo sería menos restrictivo que en el caso anterior.

\`\`\`typescript
let myStr = 'a'; // el tipo sería 'string'
let myNumber = 5; // el tipo sería 'number'

myStr = 'b'; // el tipo sigue siendo 'string'
myNumber = 6; // el tipo sigue siendo 'number'
\`\`\`

Llegados a este punto nos preguntamos: *¿Qué pasaría si necesitasemos reasignar cualquiera de las variables y asignarles el valor \`null\`?*

Además de un valor, \`null\` también es un tipo, y el compilador se "quejaría", puesto que no hemos previsto que nuestra variable pueda almacenar ese tipo de valor. Es por esto que la inferencia por sí sola no sería suficiente, y tenemos que "echar un cable" a nuestro intérprete declarando un tipo menos restrictivo para nuestra variable:

\`\`\`typescript
let myStr: string | null = 'a'; // esto se llama "Union Type" y nos permite aplicar un operador "OR" a nuestros tipos

myStr = 'b'; // podríamos seguir asignando un string a nuestra variable

myStr = null; // pero también podríamos declararla como "null"
\`\`\`

Los tipos básicos más usados son:

- \`null\`
- \`undefined\`
- \`number\`
- \`string\`
- \`boolean\`
- \`void\`

### Arrays

Cuando declaramos un tipo Array en TypeScript, debemos declarar qué tipos diferentes puede almacenar en sus posiciones. La forma más sencilla de hacer esto es mediante la palabra reservada \`Array\`, pasando los \`genéricos\` (luego veremos qué son) entre "menor que" y "mayor que":

\`\`\`typescript
let myArr: Array<string | number>;

myArr.push('a');
myArr.push(2);
\`\`\`

Otra forma equivalente de hacer lo mismo es declarando el tipo del item (que en este caso coincidiría con el genérico anterior) y añadiendo al final unos \`corchetes\` \`[]\`. Como el tipo de cada item es un **Union Type**, debemos recordar englobarlo entre paréntesis para que los corchetes afecten a cada uno de los tipos. 

\`\`\`typescript
let myArr: (string | number)[];

myArr.push('a');
myArr.push(2);
\`\`\`

Uno de los problemas más comunes en JS es la *mutabilidad*. Cuando le asignamos un array, un objeto o una función a una variable, en realidad lo que hacemos es hacer que apunte hacia una referencia, que es compartida cuando se copia a otra variable. Si modificamos cualquiera de las dos variables, la referencia original se verá afectada.

\`\`\`js
const a = ['uno'];
const b = a;
b.push('dos'); // ahora, tanto "a" como "b" valen ['uno', 'dos'];
\`\`\`

Para evitar este problema han surgido multitud de soluciones. Desde envolver nuestro array con \`Object.freeze\` hasta el uso de librerías como [Immutable](https://immutable-js.github.io/immutable-js/).

En TypeScript, la immutabilidad en los arrays está asegurada gracias al uso de \`ReadonlyArray\`, incluso en estructuras de datos encadenadas (objetos dentro de arrays):

\`\`\`typescript
const myArr: ReadonlyArray<number | string> = ['a', 2];

// si intentásemos hacer un "push" a "myArr" el compilador nos devolvería un error, porque no se puede mutar
\`\`\`

Obviamente podríamos generar un nuevo array usando datos del primero sin problemas, puesto que no habríamos mutado el array original:

\`\`\`typescript
const myArr: ReadonlyArray<number | string> = ['a', 2];

const myDerivedArr = [...myArr, 'b', 3];
\`\`\`

Otra posibilidad para declarar nuestro array es hacerlo por medio de las *const assertions*:

\`\`\`typescript
const roles = ['can_read', 'can_write'] as const;
\`\`\`

Con esto, estamos declarando nuestro array como \`Readonly\` automáticamente, y además, hacemos que el tipo del array coincida con su valor, en vez de con su primitiva. Esta sería la declaración del mismo array declarado sin y con *const assertion*:

\`\`\`typescript
declare const noConstRoles: string[];
declare const roles: readonly ["can_read", "can_write"];
\`\`\`

### Objetos

Podemos declarar un objeto en Typescript de varias formas. La más sencilla es declarar un \`type\` que contenga cada una de las propiedades del objeto:

\`\`\`typescript
type Person = {
  name: string,
  email: string,
  age: number,
};

let person: Person;

person = {
  name: 'Bruce Wayne',
  email: 'bruce@wayneindustries.com',
  age: 57,
}
\`\`\`

Otra opción bastante similar es declarar el tipo de nuestro objeto por medio de una \`interface\`:

\`\`\`typescript
interface Person {
  name: string;
  email: string;
  age: number;
};

let person: Person;

person = {
  name: 'Bruce Wayne',
  email: 'bruce@wayneindustries.com',
  age: 57
}
\`\`\`

Merece la pena reseñar que es posible generar un tipo para un objeto a partir de otros dos tipos existentes por medio de un *Intersection type*. Funcionaría tanto con \`types\` como con \`interfaces\`:

\`\`\`type
interface Profile {
  name: string;
  age: number;
}

interface Contact {
  email: string;
}

type Person = Profile & Contact;

let person: Person;

person = {
  name: 'Bruce Wayne',
  email: 'bruce@wayneindustries.com',
  age: 57
}
\`\`\`

Una de las preguntas que se nos pueden venir a la cabeza es: "¿Qué pasa si alguna de las propiedades es opcionales?". Para ello tan solo tenemos que añadir una interrogación \`?\` detrás del nombre de la propiedad:

\`\`\`typescript
type Person = {
  name: string,
  email: string,
  age?: number,
};

let person: Person;

person = {
  name: 'Bruce Wayne',
  email: 'bruce@wayneindustries.com',
  age: 57,
}

person = {
  name: 'Jordi Hurtado',
  email: 'jordi.hurtado@rtve.es',
}

\`\`\`

Otra posibilidad de definir nuestro objeto es mediante el uso de \`Record\`. Este recibe dos genéricos, el primero define el tipo para las claves, y el segundo el tipo para los valores.

\`\`\`typescript
type Messages = Record<string, string>;

let messages: Messages = {
  success: 'La operación se ha completado con éxito',
  notFound: 'No se ha encontrado',
  error: 'Error general',
};
\`\`\`

Como en el caso de los arrays, también podemos inferir el tipo de un objeto si lo declaramos con una *const assertion*:

\`\`\`typescript
const config = {
  apiURL: 'http://0.0.0.0:9000',
  apiVersion: 'v2',
  publicKey: 'pl3as3d0nthackm3'
} as const;
\`\`\`

...y este sería el tipo correspondiente generado:

\`\`\`typescript
declare const config: {
    readonly apiURL: "http://0.0.0.0:9000";
    readonly apiVersion: "v2";
    readonly publicKey: "pl3as3d0nthackm3";
};
\`\`\`

### Funciones

En muchos casos, tan solo necesitamos tipar los argumentos recibidos. El tipo de respuesta será inferido automáticamente.

\`\`\`typescript
function double(x: number) {
  return x * 2;
}
\`\`\`

Ocurre lo mismo para las *arrow functions*:

\`\`\`typescript
const double = (x: number) => x * 2;
\`\`\`

Podemos extraer el tipado de una función tanto a un \`type\`:

\`\`\`typescript
type ChangeNumber = (x: number) => number;
\`\`\`

como a una interface

\`\`\`typescript
interface ChangeNumber {
    (x: number): number
}

const double: ChangeNumber = function(x) {
    return x * 2;
}
\`\`\`

### \`any\` y \`unknown\`

Cuando usamos el valor \`any\`, permitimos que se asigne o se reciba cualquier tipo de valor. Sin embargo, esto es peligroso, porque podríamos ejecutar cualquier código problemático sin que el compilador nos advierta:

- Incrementar un *array* como si fuera un numérico
- Acceder a una posición de un array cuando en realidad el valor es un numérico

\`unknown\` es bastante similar, pero en este caso el compilador nos obliga a realizar las comprobaciones necesarias antes de ejecutar cualquier acción que solo esté disponible para un tipo concreto:

\`\`\`typescript
const stringify = (value: unknown): string => {
  if (value instanceof Date) {
    return value.toISOString();
  }
  if (Array.isArray(value) || typeof value === 'object') {
    return JSON.stringify(value);
  }
  if (typeof value === 'number') {
    return value.toLocaleString();
  }
  return String(value);
}
\`\`\`

### Genéricos

Ya hemos visto anteriormente cómo usar genéricos para definir los tipos que se podían almacenar en un array, por ejemplo \`ReadonlyArray<string\`.

Otro de los usos más comunes es para definir el tipo de un argumento cuando no lo conocemos previamente. Imaginemos la siguiente función en JavaScript:

\`\`\`js
const castArray = (x) => Array.isArray(x) ? x : [x];

castArray(1); // [1]
castArray([1]); // [1]
castArray('b'); // ['b']
castArray({ name: 'Bruce Wayne' }); // [{ name: 'Bruce Wayne' }]
\`\`\`

Si quisieramos convertir esta función a TypeScript tendríamos que declarar el argumento como \`unknown\` o bien crear un *Union Type* a partir de todos los posibles. Sin embargo, aún así, se perdería la inferencia, puesto que la respuesta también sería un array de cualquiera de esos tipos, en vez de especificar el concreto para cada caso. Para solucionar este problema podemos hacer uso de los genéricos.

En el siguiente ejemplo, declaramos un argumento que puede ser un array que a su vez incluya cualquier tipo, o bien un elemento individual de cualquier tipo. En el primer caso devuelve el propio array, mientras que en el segundo lo envuelve en un array. En los dos casos, el tipo devuelto es el mismo.

\`\`\`typescript
function castArray<T>(x: T | T[]): T[] {
  return Array.isArray(x) ? x : [x];
}
\`\`\`

### @types

Habrá muchas ocasiones en las que tengamos que trabajar con una librería externa. Aquí pueden pasar 3 cosas:

- Que la librería esté escrita en TS, o que incluya un fichero de definiciones de tipos.
- Que la librería no incluya ese fichero de forma nativa, pero que esté disponible de forma externa.
- Que la librería no soporte TS

En el primer caso, no necesitaremos hacer nada más para interactuar con la librería. En la mayor parte de las ocasiones no cubiertas por el primer caso, alguien se ha tomado la molestia de crear este fichero de definiciones en el repositiorio de [definitelytyped](https://definitelytyped.org/).

Este es el caso de **react-router-dom**. Si queremos trabajar con esta librería en nuestro proyecto, tan solo debemos instalar la definición de tipos al mismo tiempo que la librería:

\`\`\`sh
yarn add react-router-dom @types/react-router-dom
\`\`\`

Y ya estarían incorporados los tipos de react-router-dom de forma automática en nuestro proyecto.

## Componentes

En el caso de los componentes más simples (aquellos que no esperan ninguna propiedad), el compilador es capaz de inferir automáticamente el tipo devuelto (\`JSX.Element\`):

\`\`\`typescript
import React from 'react';

const MyComponent = () => (
    <div>Simple Component</div>
)

export default MyComponent;
\`\`\`

En caso contrario, debemos hacer uso del tipo \`FC\` o \`FunctionalComponent\`. Este tipo recibe un genérico correspondiente a las props:

\`\`\`typescript
import React, { FC, ReactNode, SyntheticEvent } from 'react';

interface Props {
  onClick: (e: SyntheticEvent) => void;
  children: ReactNode;
}

const MyButton: FC<Props> = ({ onClick, children }) => (
    <button type="button" onClick={onClick}>{children}</button>
)

export default MyButton;
\`\`\`

Como habrás observado, aquí estamos utilizado otros dos tipos nuevos:

- **ReactNode**: Cualquier tipo de valor que React pueda renderizar (\`ReactElement\`, \`string\`, \`number\`, \`Fragment\`, \`null\`...)
- **SyntheticEvent**: Una instancia del contenedor que usa React para manejar los eventos

La declaración de \`children\` es opcional al usar el tipo \`FC\` puesto que ya la incluye. En el caso de los componentes cuya única propiedad es \`children\` podemos omitir el uso del genérico:

\`\`\`typescript
import React, { FC } from 'react';

const MyComponent: FC = ({ children }) => (
    <div>{children}</div>
)

export default MyComponent;
\`\`\`

En cualquier momento podemos marcar una propiedad como opcional, así como pasarle un valor por defecto:

\`\`\`typescript
import React, { FC } from 'react';

type Props = {
  id: string;
  tabIndex: number;
  role?: string;
  hidden?: boolean;
}

const MyComponent: FC<Props> = ({ children, id, tabIndex, role, hidden = false }) => (
    <div id={id} tabIndex={tabIndex} role={role} hidden={hidden}>{children}</div>
)

export default MyComponent;
\`\`\`

### types + prop-types

Cuando estamos desarrollando una librería usando TS, no debemos olvidar que puede ser consumida en un proyecto de JS, por lo que siempre es buena idea incluir la validación de tipos dinámica (en tiempo de ejecución) con prop-types.

Para evitar tener que hacer esto a mano podemos usar la utilidad \`InferProps\` de la propia librería *prop-types*. No obstante, debemos recordar que TS proporciona mucha más información en algunos casos (especialmente para funciones), por lo que siempre es buena idea combinarlo con nuestra propia declaración de tipos por medio de un *Intersection Type*:

\`\`\`typescript
import React, { FC, SyntheticEvent, ButtonHTMLAttributes } from 'react';
import PropTypes, { InferProps } from 'prop-types';

const propTypes = {
  onClick: PropTypes.func.isRequired,
  children: PropTypes.node.isRequired,
  type: PropTypes.oneOf(['button', 'submit', 'reset']),
};

export type Props = InferProps<typeof propTypes> & {
  onClick: (e: SyntheticEvent) => void,
  type: ButtonHTMLAttributes<HTMLButtonElement>['type']
};

const Button: FC<Props> = ({ children, onClick, type }) => (
  <button type={type} onClick={onClick}>
    {children}
  </button>
);

Button.defaultProps = {
  type: 'button',
};

export default Button;
\`\`\`

Aquí, básicamente estamos infiriendo las props a partir del tipo de nuestras prop-types, pero lo extendemos:

- Mejoramos el tipado de *onClick*, para proveer del tipo del argumento (un \`SyntheticEvent\`) y del retorno
- Mejoramos el tipado para el atributo \`type\`, recogiéndolo de forma automática a partir de las propiedades que puede recibir un botón

Por otro lado, mi buen amigo [Iván Trujillo me recomendó un plugin de Babel](https://twitter.com/Ivanbtrujillo/status/1314280593807609857) que extrae los \`prop-types\` a partir de nuestro tipado.

## TypeScript + CSS

Sea cual sea la solución que elijamos para aplicar estilos a nuestra aplicación, podemos estar seguros de que tiene soporte de TS, bien de forma nativa, o bien a partir del repo de \`@types\`.

### Estilos en línea

Podemos usar el tipo \`CSSProperties\` que incorpora *React* para asegurarnos que las propiedades declaradas son válidas.

Si escribiésemos cualquier propiedad no reconocida por CSS, el compilador emitiría un error:

\`\`\`typescript
import React, { FC, CSSProperties } from 'react';

const styles: CSSProperties = {
  backgroundColor: 'red',
  color: 'white',
  padding: '20px',
};

const MyComponent: FC = ({ children }) => <div style={styles}>{children}</div>;

export default MyComponent;
\`\`\`

### Clases CSS

El caso de pasar el nombre de **una clase CSS** como propiedad es todavía más sencillo, puesto que no deja de ser un simple string:

\`\`\`typescript
import React, { FC } from 'react';

type Props = {
  className: 'string'
};

const MyComponent: FC<Props> = ({ children, className }) => <div className={className}>{children}</div>;

export default MyComponent;
\`\`\`

### CSS-in-JS

Pongámonos en el caso de que usamos una librería de *CSS-in-JS* como [emotion](https://emotion.sh/) con una solución para definir nuestros tokens de diseño en forma de tema, como [emotion theming](https://emotion.sh/docs/theming).

Una de las mayores ventajas que nos aporta aquí TS es la comprobación de tipos a la hora de acceder a nuestro tema desde los componentes, de tal forma que nos aseguremos que no accedemos a una propiedad inexistente.

Lo primero que deberíamos hacer es declarar nuestro tema, y exponerlo por contexto al resto de componentes por medio de un \`ThemeProvider\`:

\`\`\`typescript
import React, { FC } from 'react';
import { ThemeProvider } from 'emotion-theming';

import theme from '../theme';

const AppStyles: FC = ({ children }) => (
  <ThemeProvider theme={theme}>
    {children}
  </ThemeProvider>
);

export default AppStyles;
\`\`\`

A continuación, generamos nuestra propia versión de la utilidad \`styled\`, para inyectarle el tipado de nuestro tema:


\`\`\`typescript
import styled, { CreateStyled } from '@emotion/styled';

import theme from './theme';

export default styled as CreateStyled<typeof theme>;
\`\`\`

A partir de este momento, cualquier componente declarado con nuestra versión de \`styled\` tendrá acceso a una propiedad "theme" de forma automática, que se corresponderá con el tema declarado anteriormente, y será capaz de avisarnos sobre las propiedades a las que estamos accediendo de forma incorrecta. Si además declaramos el tipo del tema con una \`const assertion\`, tendremos acceso en tiempo real al valor de la propiedad a la que accedemos.

\`\`\`typescript
import React, { FC } from 'react';

import styled from '../../styled';

const SWrapper = styled.section\`
  padding: 20px 40px;
  background-color: \${(props) => props.theme.colors.muted};
  max-width: 600px;
  margin: 40px auto;
  box-shadow: 0 5px 12px rgba(0,0,0,0.25);
  border-radius: 6px;
\`;

const STitle = styled.h1\`
  font-family: \${(props) => props.theme.fonts.heading};
  font-size: \${(props) => props.theme.fontSizes[6]}px;
  margin: 0 0 32px;
\`;

const SImage = styled.img\`
  display: block;
  width: 100%;
\`;

type Props = {
  title: string,
  imageSrc: string
};

const Intro: FC<Props> = ({ title, imageSrc }) => (
  <SWrapper>
    <STitle>{title}</STitle>
    <SImage src={imageSrc} alt="" />
  </SWrapper>
);

export default Intro;
\`\`\`
## React Hooks
### useState

En los casos más simples (cuando almacenamos en el estado datos del mismo tipo definido con el valor inicial) no necesitamos hacer ninguna declaración especial de nuestro hook:

\`\`\`typescript
import { useState } from 'react';

const useCounter = () => {
  const [value, setValue] = useState(0);
  const increment = () => setValue(prevState => prevState + 1);
  const decrement = () => setValue(prevState => prevState + 1);
  return {
    value,
    increment,
    decrement,
  };
};

export default useCounter;
\`\`\`

La cosa cambia cuando queremos almacenar estados algo más complejos, como el de un usuario, donde el valor depende de si está logueado o no:

En el primer caso, la propiedad "isLogged" tiene que ser \`false\`, y no puede existir ninguna propiedad adicional.

\`\`\`typescript
type UnloggedUser = {
  isLogged: false
};
\`\`\`

En el segundo caso, la propiedad "isLogged" tiene que ser \`true\`, y además tiene que tener una propiedad "email" que definimos como \`string\`.

\`\`\`typescript
type LoggedUser = {
  isLogged: true,
  email: string,
}
\`\`\`

Podríamos expresar el tipo de nuestro \`User\` usando un \`Union Type\` sobre los dos tipos definidos anteriormente:

\`\`\`typescript
type User = UnloggedUser | LoggedUser;
\`\`\`

...y ya solo nos faltaría usarlo como genérico para definir nuestro \`useState\`:

\`\`\`typescript
const INITIAL_STATE = {
  isLogged: false,
} as const;

const useUser = () => {
  const [user, setUser] = useState<User>(INITIAL_STATE);

  const login = (email: string) => {
    setUser({
      isLogged: true,
      email,
    });
  };

  const logout = () => {
    setUser(INITIAL_STATE);
  };

  return {
    user,
    login,
    logout,
  };
};

export default useUser;
\`\`\`

### useReducer

Otra forma de escribir el ejemplo anterior sería mediante el uso de reducers. En este caso, añadiríamos los tipos para los *action types*, así como para las propias acciones.

Posteriormente, tiparíamos el *reducer* usando el \`State\` y las \`Actions\` previamente definidas.

\`\`\`typescript
import { useReducer } from 'react';

const INITIAL_STATE = {
  isLogged: false,
} as const;

type UnloggedState = typeof INITIAL_STATE;

type LoggedState = {
  isLogged: true,
  email: string,
}

type State = UnloggedState | LoggedState;

const ACTION_TYPES = {
  login: 'login',
  logout: 'logout',
} as const;

type ActionTypes = typeof ACTION_TYPES;

type LoginAction = {
  type: ActionTypes['login'],
  payload: string,
};

type LogoutAction = {
  type: ActionTypes['logout'],
};

type Action = LoginAction | LogoutAction;

const reducer = (state: State, action: Action) => {
  switch(action.type) {
    case ACTION_TYPES.login:
      return { isLogged: true, email: action.payload };
    case ACTION_TYPES.logout:
      return INITIAL_STATE;
    default:
      return state;
  }
}

const useUser = () => {
  const [state, dispatch] = useReducer(reducer, INITIAL_STATE);

  const login = (email: string) => dispatch({
    type: ACTION_TYPES.login,
    payload: email,
  });

  const logout = () => dispatch({
    type: ACTION_TYPES.logout,
  });

  return {
    state,
    login,
    logout,
  }
};

export default useUser;
\`\`\`

En el caso de que usásemos [Redux](https://react-redux.js.org/), el procedimiento sería el mismo, con la salvedad de que también podríamos exportar el tipo de los *reducers* combinados. Para ello, podemos hacer uso de la utilidad \`ReturnType\`, que como su propio nombre indica, recoge el tipo del valor devuelto por una función.

\`\`\`typescript
import { combineReducers } from 'react-redux';

import chatReducer from './chat';
import userReducer from './user';

const rootReducer = combineReducers({
  chat: chatReducer,
  user: userReducer,
});

export type RootReducer = ReturnType<typeof rootReducer>;

export default rootReducer;
\`\`\`

### useContext

Imaginemos ahora que queremos compatir el estado anterior con muchos componentes, pero sin tener que hacer el llamado *prop drilling*, es decir, pasar las propiedades de padre a hijo en distintos niveles.

Para ello podemos hacer uso del [API de contexto de React](https://es.reactjs.org/docs/context.html). Lo que haremos será reemplazar nuestro hook \`useReducer\` para que devuelva el contexto que almacena el valor devuelto por el hook que hacía uso del reducer, que ahora llamaremos \`useUserState\` para distinguirlo.

Lo primero que deberíamos hacer es crear el tipo para nuestro contexto. Como no conocemos su valor de antemano, simplemente le asignaremos un objeto vacío y forzaremos el tipo asignado por medio del operador \`as\`.

\`\`\`typescript
import { createContext } from 'react';

import useUserState from './useUserState';

const UserContext = createContext({} as ReturnType<typeof useUserState>);

export default UserContext;
\`\`\`

Ahora crearemos un \`Provider\`, cuya misión será ejercer de "host" para el hook que almacena el estado, y pasar el valor por contexto a todos sus descendientes:

\`\`\`typescript
import React, { FC } from 'react';

import useUserState from './useUserState';
import UserContext from './UserContext';

const UserProvider: FC = ({ children }) => {
  const value = useUserState();
  return <UserContext.Provider value={value}>{children}</UserContext.Provider>;
};

export default UserProvider;
\`\`\`

Por último, tan solo tendríamos que crear nuestro hook para facilitar la exportación del contexto del usuario:

\`\`\`typescript
import { useContext } from 'react';

import UserContext from './UserContext';

const useUser = () => useContext(UserContext);

\`\`\`",
    "slug": "introduccion-typescript-react",
    "tags": [
      "typescript",
    ],
    "title": "Introducción a TypeScript con ReactJS",
    "userPicture": "",
    "username": "Jose Manuel Lucas",
  },
  {
    "category": "typescript",
    "cover": "https://swcrafters.fra1.cdn.digitaloceanspaces.com/Categories/TS_category.png",
    "date": "",
    "description": "Un patrón de diseño es un conjunto de recomendaciones que podemos aplicar para resolver problemas de diseño comunes. Comportamiento y UI",
    "id": "patrones-diseno-comportamiento-ui",
    "markdownBody": "Este artículo es la continuación del post [Patrones de con TypeScript en el mundo real: creacionales y estructurales](/typescript/patrones-diseno-creacionales-estructurales), en ese post definía el concepto de patrón de diseño y profundizaba en algunos patrones creacionales y estructurales.

En este segundo artículo nos centraremos en los patrones de comportamiento y de UI.

## Patrones de comportamiento

### Strategy

La motivación principal del patrón *Strategy* es tener la posibilidad de ejecutar distintas implementaciones para una misma funcionalidad de forma dinámica. De esta forma, imaginemos que tenemos que ejecutar una funcionalidad específica representada por un método *strategicMethod*:

\`\`\`ts
interface Strategy {
    strategicMethod(): void;
}
\`\`\`

Y dicha funcionalidad puede ser ejecutada de dos maneras (estrategias) diferentes:

\`\`\`ts
class ConcreteStrategyA implements Strategy {
    public strategicMethod(): void {
        console.log('Strategy A');
    }
}

class ConcreteStrategyB implements Strategy {
    public strategicMethod(): void {
        console.log('Strategy B');
    }
}
\`\`\`

Definimos una clase *Context* que conoce la implementación o estrategia que debe ejecutarse en cada momento para acometer la funcionalidad:

\`\`\`ts
class Context {
    private strategy: Strategy;

    constructor(strategy: Strategy) {
        this.strategy = strategy;
    }

    setStrategy(strategy: Strategy) {
        this.strategy = strategy;
    }

    performStrategicMethod(): void {
        this.strategy.strategicMethod();
    }
}
\`\`\`

Con ella, podemos desde el cliente **variar dinámicamente la estrategia a ejecutar**. Además, delegamos la implementación interna de cada comportamiento o estrategia a las subclases *ConcreteStrategy*. El punto negativo de este patrón, es que el cliente necesita conocer y referenciar las clases de cada una de las estrategias.

\`\`\`ts
export class Client {
    run(): void {
        const context = new Context(new ConcreteStrategyA());
        context.performStrategicMethod();

        context.setStrategy(new ConcreteStrategyB());
        context.performStrategicMethod();
    }
}
\`\`\`

En nuestro caso particular, registrábamos cada cambio en cada campo de cada formulario y lo almacenábamos en el estado centralizado de la aplicación. Utilizamos el patrón *Strategy* en el componente que tenía que representar este historial de cambios, ya que necesitábamos una representación diferente dependiendo del tipo de dato modificado.

Definimos por ello un formateador por cada posible tipo de dato que hubiera que representar:

\`\`\`ts
export interface FieldFormatter<T> {
    format(field: Field<T>): string;
}
export class BooleanFormatter implements FieldFormatter<boolean> {

    format(field: Field<boolean>): string {
        return field.value ? 'True' : 'False';
    }
}
export class StringFormatter implements FieldFormatter<string> {

    format(field: Field<string>): string {
        return field.value;
    }
}
\`\`\`

Y en el componente visual, utilizamos un servicio de *Angular*, que a través de una factoría, obtenía el formateador adecuado en base al tipo de dato de cada registro:

\`\`\`ts
@Injectable()
export class FieldFormatterService {
    private formattersDictionary: { [key: number]: FieldFormatter<any> };

    constructor() {
        this.formattersDictionary =
            FieldTypeFormatsFactory.buildFormattersDictionary();
    }

    format(field: Field<any>): string {
        const typeFormatter = this.formattersDictionary[field.type];
        return typeFormatter !== undefined && typeFormatter.format(field);
    }
}
    
export class FieldTypeFormatsFactory {

    static buildFormattersDictionary(
    ): { [key: number]: FieldFormatter<any> } {
        return {
            [FieldTypes.String]: new StringFormatter(),
            [FieldTypes.Boolean]: new BooleanFormatter()
        };
    }
}

@Component({
    selector: 'strategy',
    templateUrl: './real-world.component.html'
})
export class StrategyRealWorldComponent implements OnInit {
    fieldsFormatted: Array<string>;

    constructor(private fieldFormatter: FieldFormatterService) { }

    ngOnInit() {
        const fields: Array<Field<any>> = [
            { type: FieldTypes.Boolean, value: true },
            { type: FieldTypes.String, value: 'a field value' }
        ]
        this.fieldsFormatted = fields.map(f => this.fieldFormatter.format(f));
    }
}
\`\`\`

Como podéis ver en el ejemplo, casi siempre que aplicamos el patrón *Strategy*, se elige la estrategia o implementación a ejecutar en base a algún tipo de condición o parámetro. En nuestro caso, como hemos dicho, fue el tipo de dato.

### Observer

Este patrón seguramente es de los más utilizados después del *Singleton*. La motivación principal es **desacoplar la comunicación entre distintos objetos**. Desde el punto de vista teórico, empezamos definiendo los *Observers*:

\`\`\`ts
interface Observer {
    update(): void;
}

class ConcreteObserver implements Observer {
    update(): void { }
}
\`\`\`

Por otro lado, tendremos los objetos *Subjects*, que serán los encargados de tener una referencia directa a los *observers* para poder comunicarse con ellos:

\`\`\`ts
interface Subject {
    registerObserver(observer: Observer);
    unregisterObserver(observer: Observer);
    notifyObservers();
}

class ConcreteSubject implements Subject {
    observers: Array<Observer>;

    registerObserver(observer: Observer) {
        this.observers.push(observer);
    }

    unregisterObserver(observer: Observer) {
        // Find and remove observer from the collection.
    }

    notifyObservers() {
        this.observers.forEach(o => o.update());
    }
}
\`\`\`

Desde el cliente o cualquier punto del sistema, podremos crear los *observers* y suscribirlos a cada *subject* específico, de forma que podrán comunicarse con ellos y notificarles en cualquier momento mediante el método *notifyObservers*:

\`\`\`ts
export class Client {
    run() {
        const subject = new ConcreteSubject();
        const observer1 = new ConcreteObserver();
        const observer2 = new ConcreteObserver();

        subject.registerObserver(observer1);
        subject.registerObserver(observer2);

        subject.notifyObservers();
    }
}
\`\`\`

Como podéis observar, con este patrón logramos **desacoplar totalmente** a los *observers*, ya que no conocen ni tienen ninguna referencia a ningún *subject*. Además, no estamos atados a un orden concreto de notificación entre observers.

En nuestro caso particular, teníamos un estado centralizado implementado con *Redux* y debíamos notificar a cada uno de los componentes visuales cuando una propiedad del estado se veía modificada. Esta notificación la implementamos mediante el patrón *observer*, donde cada *observer* era cada uno de los componentes a los que se debía notificar:

\`\`\`ts
@Component({
    selector: 'observer1',
    templateUrl: './observer1.component.html'
})
export class Observer1Component {
    public productNames: Array<string> = [];
    private model: Order;

    @Input() set order(orderFromState: Order) {
        this.model = orderFromState;
        this.buildFormattedOrderList();
    }
    get order() { return this.model; }

    constructor(private connector: ConnectorService) {
        this.connector.registerObserver(this);
    }

    private buildFormattedOrderList(): void {
        this.productNames = this.model.productList.map(p => p.name);
    }

    addNewProduct() {
        this.connector.updateState(
            addNewProductStateAction(this.model)
        );
    }
}
\`\`\`

El *subject* o encargado de llevar a cabo dicha notificación, era un servicio de *Angular* al que bautizamos como *connector*:

\`\`\`ts
@Injectable()
export class ConnectorService {
    private currentState: Order;
    private observers = [];

    constructor(private store: Store) {
        this.currentState = this.store.state;
    }

    registerObserver(component) {
        this.observers.push(component);
        this.notifyObserver(component);
    }

    updateState(newState: Order) {
        if (this.isStateChanged(newState)) {
            this.currentState = newState;
            this.notifyObservers();
        }
    }

    private notifyObservers() {
        this.observers.forEach(o => this.notifyObserver(o));
    }

    private notifyObserver(observer) {
        observer.order = this.currentState;
    }

    private isStateChanged(newState: Order): boolean {
        return this.currentState.id !== newState.id;
    }
}
\`\`\`

Este servicio llevaba el registro de cada componente a notificar (que se autoregistraban en sus correspondientes constructores llamando al método *registerObserver*) y se suscribía él mismo a la *store* de *Redux* para saber cuando se modificaba cualquier propiedad y poder notificar a cada uno de los componentes.

## Patrones de UI

### Page-Object

Este último patrón que revisaremos en el artículo de hoy, no encajaba en ninguna de las categorías comunes, ya que su motivación es muy específica y está muy ligada a la parte de UI. La motivación es crear una abstracción de una vista en forma de objeto, de forma que **se desacoplan los consumidores de la propia vista**.

En nuestro caso, estos consumidores eran nuestros tests de componentes UI de *Angular*. Lo que hicimos es, en vez de acceder directamente al código HTML de cada componente desde el código de los tests, creamos un *PageObject* del componente:

\`\`\`ts
export class ProductListPageObject {
    getProductId(): number {
        const productId = this.getHTMLElementByClass('id')[0].textContent;
        return parseInt(productId);
    }

    getProductName(): string {
        const productName = this.getHTMLElementByClass('name')[0].textContent;
        return productName;
    }

    openDetail(): void {
        const viewDetailButton = this.getHTMLElementByClass('view-detail')[0];
        viewDetailButton.click();
    }

    private getHTMLElementByClass(className: string): Array<HTMLElement> {
        return [new HTMLElement()];
    }
}
\`\`\`

Que expone métodos *get* para obtener valores de la vista y algún método como *openDetail* para hacer *click* e interactuar sobre elementos de ésta:

\`\`\`html
<ul>
    <li class="id">1</li>
    <li class="name">A product</li>
    <li><a href="#" class="view-detail">View Detail</a></li>
</ul>
<ul>
    <li class="id">2</li>
    <li class="name">Another product</li>
    <li><a href="#" class="view-detail">View Detail</a></li>
</ul>
\`\`\`

Así, tendremos el código de nuestros tests totalmente desacoplado de la vista (además de ser mucho **más legible y mantenible**). En el caso en que cambie el HTML del componente (que suele ser muy habitual), sólo habrá que adaptar la clase *PageObject*, pero el código de nuestros tests quedará intacto, lo que conllevará que el mantenimiento de éstos sea mucho más fácil y no se acabarán abandonando.

\`\`\`ts
export class TestClient {
    private pageObject = new ProductListPageObject();**

    is_a_valid_product_id(): boolean {
        const productId** = this.pageObject.getProductId();
        return productId > 0;
    }

    is_a_valid_product_name(): boolean {
        const productName = this.pageObject.getProductName();
        return productName.length < 255;
    }

    is_a_product_detail_visible(): boolean {
        this.pageObject.openDetail();
        // ...
        return false;
    }
}
\`\`\`

# Y aún hay mas...

Estos han sido sólo algunos de los patrones que usamos en nuestra aplicación, si queréis conocer todos los que llegamos a aplicar, podéis consultar la [charla](https://www.youtube.com/watch?v=ZlhKj32KlfI) que impartimos en la JSDay Canarias 2019 y su [repositorio de código](https://github.com/cbastos/jsdaycan2019-typescript-patterns) correspondiente con ejemplos.

Además, no puedo dejar de recomendar el libro que más me ha servido de ayuda y que mejor explica la mayoría de patrones (para mi gusto): **Head First Design Patterns** de *Eric Freeman*, *Elisabeth Freeman*, *Kathy Sierra* y *Bert Bates*.

Espero que os haya resultado útil el artículo, y cualquier duda/pregunta/sugerencia podéis encontrarme en twitter como [@ivanirega](https://twitter.com/ivanirega). Y recordad: *"Donde hay patrón, no manda marinero"* 😉",
    "slug": "patrones-diseno-comportamiento-ui",
    "tags": [
      "typescript",
    ],
    "title": "Patrones de diseño con TypeScript en el mundo real: comportamiento y UI",
    "userPicture": "",
    "username": "Iván Reinoso",
  },
  {
    "category": "vuejs",
    "cover": "https://swcrafters.fra1.cdn.digitaloceanspaces.com/Categories/vuejs_category.png",
    "date": "",
    "description": "Vuex es librería oficial de Vue para la administración del estado de la aplicación, veremos como tiparla con TypeScript.",
    "id": "aumenta-productividad-vuex-typescript",
    "markdownBody": "Cuando trabajamos con librerías de terceros a veces tenemos que lidiar con un tipado débil. Es el caso de la librería oficial de Vue para la administración del estado de la aplicación: **Vuex**

A pesar de ser una librería muy utilizada en multitud de proyectos, la definición de su API respecto a los tipos deja mucho que desear: poco soporte de tipos genéricos y muchos tipos \`any\` por todo el código.

Esto conlleva a que cuando quieres utilizarla en tu desarrollo no tengas soporte del intellisense (autocompletado, definición de propiedades y métodos, etc...) ni seguridad de tipos. En resumen, es como si tuviéramos desactivado el soporte de TypeScript en ese código y fuéramos a ciegas.

![Sample getters with errors](https://swcrafters.fra1.cdn.digitaloceanspaces.com/Posts/aumenta-productividad-vuex-typescript/getters-without-types.gif)

Pues bien, la buena noticia es que podemos "vitaminar" el tipado de Vuex mediante una serie de interfaces genéricas y el uso del estilo de objeto que soporta las mutaciones y acciones de Vuex. En este artículo aportaré una solución sencilla que nos permitirá tener un punto de partida sobre cómo ayudarnos con TypeScript para completar las carencias de Vuex.

## Conociendo el entorno

Como ejemplo de este artículo, trabajaremos sobre una aplicación típica de carrito de la compra.

Tendremos que manejar mediante Vuex las siguientes características:

- Estado raíz de la aplicación: \`loading\` y \`snackbar\`.
- Dos módulos sin espacio de nombres: \`products\` y \`cart\` (aunque sólo veremos el código del primero).

Una de las primeras tareas que hacemos cuando desarrollamos con una librería de terceros que expone tipos de TypeScript es, precisamente, ver los tipos que expone para ser usada. Así que vamos a vamos a ver los tipos principales que expone Vuex:

> Se ha omitido código de la definición para evitar ruido (···)

_vuex/types/index.d.ts_

\`\`\`ts

export declare class Store<S> {
  constructor(options: StoreOptions<S>);

  readonly state: S;
  readonly getters: any;

  dispatch: Dispatch;
  commit: Commit;

  ···
}
\`\`\`

Como vemos, tenemos la declaración de una clase \`Store\` que admite un tipo genérico llamado \`S\`.

> Los tipos genéricos en TypeScript nos permiten definir estructuras reutilizables aplicando un determinado tipo de dato en varios puntos de nuestro código.

En este caso, el genérico \`S\` que le pasamos a \`Store\` será el que definirá la propiedad de sólo lectura \`state\` y que será el estado de nuestra aplicación. Por ahora, no tenemos que hacer nada especial, tan sólo definir una interface que contendrá nuestro estado raíz.

_./src/store/root.models.ts_

\`\`\`ts

export interface RootState {
  loading: boolean;
  snackbar: Snackbar;
}

interface Snackbar {
  message: string;
  isActive: boolean;
  type?: "success" | "info" | "error";
}

export type SetSnackbar = Pick<Snackbar, "message" | "type">;
\`\`\`

Para definir el tipo \`Snackbar\` hemos utilizado un tipo literal de string. De esta forma le decimos que la propiedad \`type\` sólo podrá contener como valores posibles "success", "info" o "error".

Y para el tipo a exportar \`SetSnackbar\` utilizamos el tipo de utilidad de TypeScript \`Pick<T,K>\`. Este tipo genérico crea un nuevo tipo con las propiedades de \`T\` referidas en \`K\`. En nuestro caso, crearemos un tipo nuevo con las propiedades \`message\` y \`type\` de la interface \`Snackbar\`. Podíamos haber usado \`Omit\` pero lo veremos en otro caso más adelante.

Ahora sólo nos falta crear un objeto que utilizaremos para setear el estado inicial de nuestro estado raíz.

_./src/store/root.models.ts_

\`\`\`ts
···

export const initialRootState: RootState = {
  loading: false,
  snackbar: {
    message: "",
    isActive: false,
    type: undefined,
  },
};
\`\`\`

Vamos a alimentar nuestro store con este estado raíz y utilizaremos la interface creada \`RootState\` para tipar el objeto _store_:

_./src/store/index.ts_

\`\`\`ts
import { RootState, initialRootState } from "./root.models";
···

export const store = new Vuex.Store<RootState>({
  state: initialRootState,
});
\`\`\`

## Mutations

Lo primero que haremos será analizar los **tipos que expone Vuex** para las mutaciones.

_vuex/types/index.d.ts_

\`\`\`ts
···

export interface MutationTree<S> {
  [key: string]: Mutation<S>;
}

export type Mutation<S> = (state: S, payload?: any) => any;
\`\`\`

Para empezar, \`MutationTree\` es un tipo genérico que permite pasarle la interface del estado (\`RootState\` en nuestro caso).

Cada propiedad en un objeto creado conmgom el tipo \`MutationTree\` tendrá como valor una función de tipo \`Mutation<S>\`. Esta última interface viene a definirse como una función que admite dos parámetros de entrada: \`state\` con el tipado del estado raíz (\`RootState\`) y un \`payload\` con un tipo \`any\`.

**¿Qué consecuencias nos trae manejar valores definidos con el tipo \`any\`?**

Pues básicamente le estamos diciendo a TypeScript que queremos deshabilitar la verificación de tipos y esto no es nada óptimo para nosotros.

Normalmente el tipo \`any\` se utiliza cuando no conocemos el tipo de variables con el que vamos a trabajar, pero en nuestro caso, sí que sabemos qué objetos vamos a definir como mutaciones, acciones, etc... así que no tiene mucho sentido mantener este tipado. En breve veremos cómo podemos mejorarlo.

Primero, vamos a hacer una introducción al **estilo de objeto** que permite Vuex para acometer las mutaciones y despachar las acciones.

### Estilo de objeto

\`\`\`ts

store.commit("increment", { amount: 10 });

/** Son equivalentes */

store.commit({
  type: "increment",
  payload: { amount: 10 },
});
\`\`\`

Esta característica permite pasar un objeto que contenga una propiedad \`type\` con el nombre de la mutación o acción y una propiedad \`payload\` con los parámetros que queremos hacer llegar al método \`commit\` o \`dispatch\` del **store**, respectivamente.

Aprovechando esta característica podemos crear una función que admita un \`payload\` y devolver un objeto con esa definición (\`type\` y \`payload\`) para que el _store_ lo entienda.

\`\`\`ts

const increment = (payload: { amount: 10 }) => ({ type: "increment", payload: { amount: 10 } });

store.commit(increment({ amount: 10 }));
\`\`\`

Sabiendo esto, mi propuesta se basa en utilizar esta característica para crear un objeto que contenga estas funciones y utilizarlas donde sea necesario. De este modo tendremos la inferencia de tipos que no nos provee Vuex en nuestro _store_ y componentes.



![Object Style Mutation](https://swcrafters.fra1.cdn.digitaloceanspaces.com/Posts/aumenta-productividad-vuex-typescript/object-style-mutation.gif)

Vamos a comenzar creando nuestros primeros tipos llamados _helpers_, y para ello, definiremos un fichero _root.helpers.ts_ en el raíz de nuestro _store_:

### DefineMutationTree

Este tipo genérico vendrá a sustituir a \`MutationTree\` de Vuex. Lo que admite este tipo genérico es la definición de la interface de las mutaciones \`Mutation\` y del estado \`State\`.

Por cada propiedad definida en la interface que le pasaremos como mutaciones (genérico \`Mutation\`) existirá una propiedad en este objeto cuyo valor será una función que admitirá el estado tipado y un \`handler\` (que hará referencia al objeto \`type\` y \`payload\` anterior). Este \`handler\` recibirá un objeto con una propiedad \`payload\` cuyo tipo será el que hemos definido previamente en nuestra interface \`Mutation\`.

_./src/store/root.helpers.ts_

\`\`\`ts

export type DefineMutationTree<Mutation, State> = {
  [Prop in keyof Mutation]: (state: State, handler: { payload: Mutation[Prop] }) => void;
};
\`\`\`

Quedará más claro cuando lo usemos. Primero, definimos la interface de nuestras mutaciones:

_./src/store/root.mutations.ts_

\`\`\`ts

import { RootState } from "./root.models";

export interface RootMutations {
  setLoading: RootState["loading"];
  setSnackbar: RootState["snackbar"];
}
\`\`\`

Fíjate que el tipo de dato que asignamos a cada propiedad será el tipo del \`payload\` que queremos pasar a las mutaciones.

Ahora, cuando vayamos a definir el objeto **mutations** con nuestra interface \`DefineMutationTree\`, al pasarle \`RootMutations\` y \`RootState\` nuestro IDE nos irá indicando los valores que debemos rellenar sin posibilidad de equivocarnos, lo cual se traduce en menos errores, más rapidez y más control de tu código.

![Mutations with types works](https://swcrafters.fra1.cdn.digitaloceanspaces.com/Posts/aumenta-productividad-vuex-typescript/add-mutations.gif)

_./src/store/root.mutations.ts_

\`\`\`ts
···
const mutations: DefineMutationTree<RootMutations, RootState> = {
  setLoading(state, { payload }) {
    state.loading = payload;
  },
  setSnackbar(state, { payload }) {
    state.snackbar = {
      message: payload.message,
      type: payload.type || "success",
      isActive: payload.isActive,
    };
  },
};

export default mutations;
\`\`\`

### DefineTypes

Al principio comenté que usaríamos el **estilo de objeto de Vuex** para usarlo de forma segura, ¿verdad? Pues primero tenemos que definir la interface que deberán cumplir estos objetos.

En el fichero de _root.helpers.ts_ crearemos el siguiente tipo genérico llamado \`DefineTypes\`.

_./src/store/root.helpers.ts_

\`\`\`ts
···
export type DefineTypes<Methods> = {
  [Prop in keyof Methods]: Methods[Prop] extends undefined
    ? () => { type: keyof Methods }
    : (payload: Methods[Prop]) => { type: keyof Methods; payload: Methods[Prop] };
};
\`\`\`

Estamos definiendo un tipo genérico que admite una interface llamada \`Methods\` (ya que nos servirá tanto para las mutaciones como para las acciones) la cual tendrá una propiedad existente en \`Methods\` y a través del tipo condicional \`T extends U ? X : Y\`, le estamos diciendo que si el tipo de dato es \`undefined\` asigne la definición a la derecha del interrogante \`?\` y en caso contrario, la definición a la derecha de los dos puntos \`:\`. Sí, es un operador ternario de tipos y lo tenemos disponible en TypeScript desde la versión 2.8.

La primera función no indica parámetros de entrada y devolverá un objeto con una propiedad \`type\` con el nombre del método. La segunda función, admitirá un parámetro de entrada \`payload\` con el tipo de dato indicado en la interface y devolverá un objeto con una propiedad \`type\` igual que la anterior y el \`payload\` recibido anteriormente.

Vamos a usarlo.

_./src/store/root.mutations.ts_

\`\`\`ts
···
export const rootMutationsTypes: DefineTypes<RootMutations> = {
  setLoading: payload => ({ type: "setLoading", payload }),
  setSnackbar: payload => ({ type: "setSnackbar", payload }),
};
\`\`\`

![Root mutations types](https://swcrafters.fra1.cdn.digitaloceanspaces.com/Posts/aumenta-productividad-vuex-typescript/root-mutations-types.gif)

A la hora de utilizarlo en conjunto con el resto de propiedades en el _store_ haremos lo siguiente:

_./src/store/index.ts_

\`\`\`ts
import mutations, { rootMutationsTypes, RootMutations } from "./root.mutations";
···
export const store = new Vuex.Store<RootState>({
  strict: true,
  state: initialRootState,
  mutations, // <- Agregamos el objeto con las mutaciones
});

// Exportamos nuestro objeto ayudante para usarlo en los componentes (contiene nuestras funciones con el estilo de objeto)
export const rootTypes = {
  mutations: rootMutationsTypes,
};
\`\`\`

Y para usarlo importaremos este objeto \`rootTypes\` y lo pasaremos como parámetro de entrada al método \`commit\` del **store** (o \`this.$store\` si estamos en los componentes, por ejemplo):

\`\`\`ts

const actions = {
  getAllProducts: ({ commit }) => {
    commit(rootMutationsTypes.setLoading(true));
  },
};
\`\`\`

Veamos cómo se comporta:

![Mutations types works](https://swcrafters.fra1.cdn.digitaloceanspaces.com/Posts/aumenta-productividad-vuex-typescript/use-mutations-store-types.gif)

## Actions

Para las acciones haremos exactamente lo mismo que con las mutaciones.

Primero, vamos a ver qué tipos nos ofrece Vuex al respecto.

_vuex/types/index.d.ts_

\`\`\`ts
···
export interface ActionTree<S, R> {
  [key: string]: Acocltion<S, R>;
}

export type Action<S, R> = ActionHandler<S, R> | ActionObject<S, R>;

export type ActionHandler<S, R> = (this: Store<R>, injectee: ActionContext<S, R>, payload?: any) => any;
export interface ActionObject<S, R> {
  root?: boolean;
  handler: ActionHandler<S, R>;
}
\`\`\`

Al igual que con \`MutationTree\` tenemos una tipado muy débil con \`any\`, tanto en el \`payload\` como en el retorno de las acciones. Así que vamos a ver cómo solucionarlo.

Esta vez comenzaremos definiendo la interface que deberá cumplir nuestras acciones. Recuerda, al igual que con las mutaciones, vamos a definir el nombre de nuestra acción como clave de la propiedad y como tipo de dato el parámetro de entrada de la acción.

_./src/store/root.actions.ts_

\`\`\`ts

import { RootState, SetSnackbar } from "./root.models";

export interface RootActions {
  showSnackbar: SetSnackbar;
}
\`\`\`

### DefineActionTree

Ahora crearemos un nuevo tipo llamado \`DefineActionTree\` en nuestro fichero de _helpers_.

_./src/store/root.helpers.ts_

\`\`\`ts

import { Store, ActionContext } from "vuex";
···
export type DefineActionTree<Action, State, RootState> = {
  [Prop in keyof Action]: Action[Prop] extends undefined
    ? (
        this: Store<RootState>,
        ctx: ActionContext<State, RootState>,
      ) => void | Promise<any>
    : (
        this: Store<RootState>,
        ctx: ActionContext<State, RootState>,
        handler: { payload: Action[Prop] },
      ) => void | Promise<any>;
};
\`\`\`

Muy parecido a la definición de \`DefineMutationTree\`, la diferencia es que las acciones reciben el contexto del **store** y para ello hacemos uso de \`ActionContext\` de Vuex.

Vamos a usarlo todo en conjunto en nuestro fichero de acciones:

_./src/store/root.actions.ts_

\`\`\`ts

import { RootState, SetSnackbar } from "./root.models";
import { DefineActionTree, DefineTypes } from "./store.helpers";
import { rootMutationsTypes } from "./root.mutations";

export interface RootActions {
  showSnackbar: SetSnackbar;
}

const actions: DefineActionTree<RootActions, RootState> = {
  showSnackbar({ commit }, { payload }) {
    commit(rootMutationsTypes.setSnackbar({ ...payload, isActive: true }));

    setTimeout(() => {
      commit(rootMutationsTypes.setSnackbar({ ...payload, isActive: false }));
    }, 3000);
  },
};

export const rootActionsTypes: DefineTypes<RootActions> = {
  showSnackbar: payload => ({ type: "showSnackbar", payload }),
};

export default actions;
\`\`\`

![Define Actions Tree](https://swcrafters.fra1.cdn.digitaloceanspaces.com/Posts/aumenta-productividad-vuex-typescript/define-actions-tree.gif)

Fíjate que estamos importando el objeto \`rootMutationsTypes\` para hacer uso de las mutaciones previamente definidas. Todo este código te aporta seguridad de tipos para trabajar más cómodamente, y lo mejor es que cuando lo usamos en nuestros componentes también tenemos seguridad de tipos, cosa que antes no teníamos.

Vamos a alimentar nuestro **store** con los objetos creados:

_./src/store/index.ts_

\`\`\`ts
···
import actions, { rootActionsTypes, RootActions } from "./root.actions";

export const store = new Vuex.Store<RootState>({
  strict: true,
  state: initialRootState,
  mutations,
  actions,
});

export const rootTypes = {
  actions: rootActionsTypes,
  mutations: rootMutationsTypes,
};
\`\`\`

![Define Actions works](https://swcrafters.fra1.cdn.digitaloceanspaces.com/Posts/aumenta-productividad-vuex-typescript/define-types-actions-in-action.gif)

## Getters

Si recordamos cómo estaba definida la propiedad de sólo lectura \`getters\` en la clase \`Store\` de Vuex...

_./vuex/types/index.d.ts_

\`\`\`ts

export declare class Store<S> {
  constructor(options: StoreOptions<S>);

  readonly state: S;
  readonly getters: any;

  dispatch: Dispatch;
  commit: Commit;

  ···
}
\`\`\`

Vemos que se nos presenta un gran problema respecto a lo que el tipado se refiere.

La propiedad \`getters\` está definida con el tipo \`any\` de TypeScript, lo que significa que \`getters\` podrá ser cualquier cosa y por tanto, nuestro IDE no podrá trabajar adecuadamente.

Cuando vayamos a utilizar esta propiedad en nuestros componentes estaremos totalmente a ciegas con los problemas que conlleva. Pero es que además en el propio uso en el store tendremos los mismos problemas... observa la definición:

_./vuex/types/index.d.ts_

\`\`\`ts

export interface GetterTree<S, R> {
  [key: string]: Getter<S, R>;
}

export type Getter<S, R> = (state: S, getters: any, rootState: R, rootGetters: any) => any;
\`\`\`

Seguimos teniendo tipos \`any\` por todos lados...

Vamos a ver cómo podríamos implementar una solución rápida para subsanarlo. Trabajaremos en nuestro fichero _store.helpers.ts_

_./src/store/store.helpers.ts_

\`\`\`ts
···

export type DefineGetterTree<Getter, State, RootState = {}, RootGetter = {}> = {
  [K in keyof Getter]: (
    state: State,
    getters: Getter,
    rootState: RootState,
    rootGetters: RootGetter,
  ) => Getter[K];
};

export type GetterHelper<Getter> = { [Prop in keyof Getter]: Getter[Prop] };

export type StoreTS<State, Getters> = Omit<Store<State>, "getters"> & {
  readonly getters: GetterHelper<Getters>;
};

\`\`\`

Vamos por partes. Primero, \`DefineGetterTree\`.

### DefineGetterTree

\`\`\`ts

export type DefineGetterTree<Getter, State, RootState = {}, RootGetter = {}> = {
  [Prop in keyof Getter]: (
    state: State,
    getters: Getter,
    rootState: RootState,
    rootGetters: RootGetter
  ) => Getter[Prop];
};
\`\`\`

Hemos creado un tipo genérico que admitirá la definición de los getters \`Getter\`, el estado local \`State\`, el estado raíz \`RootState\` (si estuviéramos en un módulo) y los getters del raíz \`RootGetter\` (si estuviéramos también en un módulo).

Antes de ver cómo podemos usarlo, vamos a crear la definición de nuestros **Getters**:

_./src/store/root.getters.ts_

\`\`\`ts

import { RootState } from "./root.models";

export interface RootGetters {
  snackbar: RootState["snackbar"];
}

export default getters;
\`\`\`

En esta definición lo que hacemos es decir qué propiedades tendrá nuestros **getters** (en este caso, una propiedad \`snackbar\`) y que la misma tendrá un tipo \`RootState["snackbar"]\`. Estamos aprovechando la funcionalidad de TypeScript de acceder a los tipos de una interface mediante su índice.

Si recordamos el funcionamiento de Vuex, un \`getter\` no es más que una función que retorna el estado manipulado, es decir, como una \`computed property\`. Gracias a esta interface que hemos definido, _lo que estamos indicando es el retorno que tendrá esa función getter llamada snackbar_.

Ahora podemos ver el uso de nuestra interface genérica \`DefineGetterTree\`.

Vamos a crear el objeto que expondremos como **getters** para nuestro _store_:

_./src/store/root.getters.ts_

\`\`\`ts

import { DefineGetterTree } from "./store.helpers";
import { RootState } from "./root.models";

export interface RootGetters {
  snackbar: RootState["snackbar"];
}

const getters: DefineGetterTree<RootGetters, RootState> = {
  snackbar: state => state.snackbar,
};

export default getters;
\`\`\`

Fíjate que cuando creamos \`DefineGetterTree\`, dijimos que por cada propiedad en \`RootGetters\` (\`[Prop in keyof Getter]\`) crearíamos una propiedad en este nuevo objeto que tendría como valor una función que recibiría como parámetros de entrada, entre otras cosas, el estado \`State\`; y que tendría como retorno de dicha función el tipo que le dijimos en nuestra interface (\`Getter[Prop]\`):

\`\`\`ts

export type DefineGetterTree<Getter, State, RootState = {}, RootGetter = {}> = {
  [Prop in keyof Getter]: (
    state: State,
    getters: Getter,
    rootState: RootState,
    rootGetters: RootGetter
  ) => Getter[Prop];
};
\`\`\`

Bien, por ahora hemos definido cómo será nuestros **getters** pero no hemos dicho cómo le decimos a Vuex que lo use.

Vamos a alimentar nuestro \`store\` con este objeto y veremos cómo podemos salvar el \`any\` que vimos al principio.

## StoreTS

_./src/store/store.helpers.ts_

\`\`\`ts
···

export type GetterHelper<Getter> = { [Prop in keyof Getter]: Getter[Prop] };

export type StoreTS<State, Getters> = Omit<Store<State>, "getters"> & {
  readonly getters: GetterHelper<Getters>;
};

\`\`\`

Aquí estamos usando algunos tipos avanzados de TypeScript para ayudarnos a conseguir nuestro objetivo. Vamos por partes:

Primero, \`StoreTS\` es una interface genérica que admite la interface del estado \`State\` y la interface de los getters \`Getters\`. Esta interface genérica hace una unión de tipos un poco especial:

- Por una parte, tenemos un tipo de utilidad \`Omit<T,K>\` que construye un tipo tomando todas las propiedades de \`T\` excepto \`K\`. En nuestro caso, todas las propiedades de la interface \`Store<State>\` excepto la propiedad \`getters\` (recuerda, \`Store\` viene de los tipos de Vuex y esta propiedad _getters_ estaba con tipo \`any\`, por eso no nos interesa).
- Por otra parte, y mediante la unión \`&\` le decimos que agregue una propiedad de sólo lectura llamada \`getters\` y para la cual su tipo será \`GetterHelper<Getters>\`.

Así que el resultado será una sobreescritura de tipos donde la instancia de nuestro _store_ será el tipado que viene por defecto en Vuex excepto para los getters, que ahora tendrán inferencia de tipos gracias a esta definición de tipos.

¿Y cómo lo usamos? Veamos:

_./src/store/index.ts_

\`\`\`ts
···
import getters, { RootGetters } from "./root.getters";

Vue.use(Vuex);

export const store = new Vuex.Store<RootState>({
  strict: true,
  state: initialRootState,
  mutations,
  actions,
  getters, // <- alimentamos con nuestro objeto getters, por tanto this.$store.getters no tendrá inferencia de tipos (funcionamiento normal)
});

···
// Pero exportaremos este objeto que sí tendrá la inferencia de tipos para getters, p.ej: store.getters.snackbar
export default store as StoreTS<RootState, RootGetters & CartGetters>;
\`\`\`

De esta forma, cuando queramos usar los getters tipados en nuestros componentes tan sólo deberemos importar este objeto cuyo tipos estarán ampliados.

_./src/store/index.ts_

\`\`\`ts
<script lang="ts">
import Vue from "vue";
import store from "../store";

export default Vue.extend({
  name: "Snackbar",
  computed: {
    snackbar() {
      return store.getters.snackbar;
    },
  },
});
</script>
\`\`\`

Y ahora con los nuevos tipos, vamos a verlo en funcionamiento:

![Typings getters](https://swcrafters.fra1.cdn.digitaloceanspaces.com/Posts/aumenta-productividad-vuex-typescript/typings-getters.gif)

> Fíjate que ya no es necesario indicar el tipo de retorno de las computed property porque es capaz de inferir el tipo

## Módulos

Por ahora hemos cubierto cómo trabajar con la librería Vuex y sus tipos en el raíz, pero normalmente usaremos la característica de módulos para escalar nuestro estado.

### Products State

Vamos a comenzar por definir el estado del módulo "Products" y el objeto que usaremos para inicializarlo:

_./src/store/modules/products/products.models.ts_

\`\`\`ts

export interface ProductsState {
  all: Product[];
}

export interface Product {
  id: number;
  title: string;
  price: number;
  inventory: number;
}

export const initialProductsState: ProductsState = {
  all: [],
};
\`\`\`

Además vamos a necesitar extender la interface del estado raíz para darle cabida al estado de este módulo mediante la propiedad \`products\` que tendrá el estado raíz.

_./src/store/modules/products/products.models.ts_

\`\`\`ts
···
export type ExtendedProductsState = { products?: ProductsState };
\`\`\`

Y ahora debemos utilizarlo en el estado raíz para ampliarlo.

_./src/store/root.models.ts_

\`\`\`ts
···
import { ExtendedProductsState } from "./modules/products";

/** Root State */
export interface RootState extends ExtendedProductsState {
  loading: boolean;
  snackbar: Snackbar;
}
···
\`\`\`

### Products Mutations

Por simplicidad, vamos a mostrar el fichero completo de \`products.mutations.ts\`

_./src/store/modules/products/products.mutations.ts_

\`\`\`ts

import { DefineMutationTree, DefineTypes } from "../../store.helpers";
import { RootState } from "../../root.models";
import { ProductsState, Product } from "./products.models";

export interface ProductsMutations {
  setProducts: Product[];
  decrementProductInventory: Product["id"];
}

const mutations: DefineMutationTree<ProductsMutations, ProductsState> = {
  setProducts: (state, { payload }) => {
    state.all = payload;
  },

  decrementProductInventory: (state, { payload }) => {
    state.all.find(p => p.id === payload)!.inventory--;
  },
};

export const productsMutationsTypes: DefineTypes<ProductsMutations> = {
  setProducts: payload => ({ type: "setProducts", payload }),
  decrementProductInventory: payload => ({
    type: "decrementProductInventory",
    payload,
  }),
};

export default mutations;
\`\`\`

### Products Actions

Por simplicidad, vamos a mostrar el fichero completo de \`products.actions.ts\`

_./src/store/modules/products/products.actions.ts_

\`\`\`ts
···
import { rootMutationsTypes } from "../../root.mutations";

export interface ProductsActions {
  getAllProducts: undefined;
}

const actions: DefineActionTree<ProductsActions, ProductsState> = {
  getAllProducts: ({ commit }) => {
    commit(rootMutationsTypes.setLoading(true));
    ···
  },
};

export const productsActionsTypes: DefineTypes<ProductsActions> = {
  getAllProducts: () => ({ type: "getAllProducts" }),
};

export default actions;
\`\`\`

> Fíjate cómo importando los helpers del raíz podemos hacer uso de las funciones tipadas

## Products Getters

Por simplicidad, vamos a mostrar el fichero completo de \`products.getters.ts\`

_./src/store/modules/products/products.getters.ts_

\`\`\`ts

import { DefineGetterTree } from "../../store.helpers";
import { RootState } from "../../root.models";
import { ProductsState, Product } from "./products.models";

export interface ProductsGetters {
  allProducts: Product[];
}

const getters: DefineGetterTree<ProductsGetters, ProductsState, RootState> = {
  allProducts: state => state.all,
};

export default getters;
\`\`\`

Una vez creado el fichero de mutaciones vamos a añadirlo a nuestro **store**.

\`\`\`ts
···
import { products, productsTypes } from "./modules/products";

export const store = new Vuex.Store<RootState>({
  strict: true,
  state: initialRootState,
  mutations,
  actions,
  getters,
  modules: {  // Agregamos los módulos al store
    products,
  },
});

export const rootTypes: HelperTypes<RootMutations, RootActions> = {
  actions: rootActionsTypes,
  mutations: rootMutationsTypes,
};

/** Helper types Object */
export const storeTypes = {
  root: rootTypes,
  products: productsTypes,
};
\`\`\`

Yo por comodidad he creado un objeto que he llamado \`storeTypes\` donde voy agregando, bajo el nombre de los módulos o del raíz, los objetos correspondientes con las acciones y mutaciones de todo el store.

Así cuando vaya a utilizarlo sólo debes indicar la ruta al método:

\`\`\`ts
<script lang="ts">
import Vue from "vue";
import store, { storeTypes } from "../store";
import { Product } from "../store/modules/products";

export default Vue.extend({
  name: "ProductList",
  computed: {
    products() {
      return store.state.products!.all;
    },
  },
  methods: {
    addToCart(product: Product) {
      store.dispatch(storeTypes.cart.actions!.addToCart(product));
    },
  },
});
</script>
\`\`\`

![Store with types](https://swcrafters.fra1.cdn.digitaloceanspaces.com/Posts/aumenta-productividad-vuex-typescript/store-with-types.gif)

Y hasta aquí el post sobre cómo aumentar tu productividad usando Vuex con TypeScript. 

Este post nace de la [charla](https://youtu.be/FmHcLbVYqec) que impartí en el JSDay Canarias 2019. El código completo lo puedes encontrar en este [enlace](https://github.com/LissetteIbnz/jsdaycan2019-vuex-typescript).

Además, de esta charla surgió la idea de crear **un paquete de npm con los tipos más completos ya disponibles para trabajar**, así que si te ha parecido interesante el tema y quieres usarlos, los tienes a tu disposición en [@lissette.ibnz/vuex-extended-types](https://www.npmjs.com/package/@lissette.ibnz/vuex-extended-types)

Ya sabes \`npm i -D @lissette.ibnz/vuex-extended-types\`

Espero que te haya resultado útil el artículo, y cualquier duda/pregunta/sugerencia podéis encontrarme en twitter como @LissetteIbnz

Nos vemos 🖖😄",
    "slug": "aumenta-productividad-vuex-typescript",
    "tags": [
      "vuejs",
    ],
    "title": "Aumenta tu productividad con Vuex gracias a TypeScript",
    "userPicture": "",
    "username": "𝕊𝕒𝕣𝕒 𝕃𝕚𝕤𝕤𝕖𝕥𝕥𝕖 🍋",
  },
  {
    "category": "react",
    "cover": "https://swcrafters.fra1.cdn.digitaloceanspaces.com/Categories/ReactJS_category.png",
    "date": "",
    "description": "¿Testing en el FrontEnd? En este post veremos todo lo necesario para introducirse en el mundo del testing en frontend.",
    "id": "testing-frontend",
    "markdownBody": "Hace calor, mucho calor, y nadie quiere perder mucho tiempo haciendo tests, leyendo sobre tests y sobre todo escribiendo sobre tests así que voy a intentar condensar en un pequeño artículo todo lo necesario para introducirse en el mundo del testing en frontend.

Voy a saltarme la parte aburrida con un pequeño resumen:

**¿Qué es un test?**

Un test automático es un programa que permite verificar rápidamente que otro programa funciona de la forma esperada.

**¿Qué ventajas tienen los tests?**

Principalmente los tests se utilizan para detectar bugs antes de que los detecten los usuarios del software, contribuyen a aumentar la calidad del código porque facilita a los programadores realizar refactorizaciones más frecuentemente, aceleran la velocidad de desarrollo, sirven como documentación y ayudan a que la arquitectura del software sea más limpia.

**Probablemente ya hagas tests**

Siempre que doy la turra sobre testing a alguien intento hacerle ver que sin darse cuenta está haciendo <u>tests manuales</u> mientras programa. Probablemente te habrás encontrado alguna vez saltando entre el editor de código y la applicación en desarrollo siguiendo una secuencia como esta:

Escribir una linea de código para mostrar un popup, abrir el navegador para ver que se muestra un popup, no se muestra el popup :thinking: abrir el editor, borrar todo y escribir \`console.log('hola')\` volver al navegador, recargar con la consola abierta, no se muestra nada... el script no se estaba importando... repetir hasta completar la tarea.

El proceso en el que abres el navegador y pruebas a mano algo justo después de escribir código relacionado es un TEST. La clave de todo esto es entender que este proceso <u>se puede</u>, y se debe, <u>automatizar</u>.

**¿Qué forma tiene un test?**

Cuando escribimos un test nos interesa saber cómo se comporta el sistema ante una situación determinada para determinar si este comportamiento es el esperado. Generalmente se habla de 3 fases claramente diferenciadas:

- Una fase inicial en la que establecemos un entorno conocido para ver cómo se comporta el sistema.
- Una fase en la que ejecutamos el código que queremos probar.
- Una fase final en la que comprobamos que el comportamiento del sistema es correcto.

Además, es importante que el test tenga una descripción que indique precisamente:

- Qué parte del sistema se está probando.
- En qué condiciones se está ejecutando ese código.
- Cuál es el resultado esperado.

**Un test debe tener una descripción significativa!**

Para ayudarnos a escribir tests existen librerias cómo por ejemplo [Jest](https://jestjs.io/) sobre las que podríamos dedicar todo el artículo pero en nuestro caso simplemente vamos a ver un ejemplo de cómo escribir un test básico de la función [isArray](https://developer.mozilla.org/es/docs/Web/JavaScript/Referencia/Objetos_globales/Array/isArray) del objeto Array.

Lo primero es escribir las descripciones de los tests de forma que se entienda claramente lo que queremos probar:

\`\`\`js
describe('Array.isArray', () => {
  it('should return true when the parameter is an array');
  it('should return false when the parameter is not an array');
});
\`\`\`

Esto es muy importante! Mucha gente no le da importancia a escribir buenas descripciones y te encuentras cosas como estas:

\`\`\`js
describe('isArr', () => {
  it('works ok with object')
  it('pass with array')
});
\`\`\`

Recuerda, la descripción del test debe responder siempre a las siguientes cuestiones: ¿Qué parte del sistema estamos probando? ¿Bajo que condiciones se está ejecutando el código? ¿Cuál es el resultado esperado?

> Existe una metodolgía para escribir descripciones llamada SWA por sus siglas Should When And que facilita mucho este proceso.

**Implementación**

Una vez tenemos la descripcion escrita, pasamos a implementar el test, siguiendo las tres fases comentadas previamente:

\`\`\`js
describe('Array.isArray', () => {
  it('should return false when the parameter is not an array', () => {
    const parameter = 'dummy_string'; // Arrange
    const actual = Array.isArray(parameter); // Act
    expect(actual).toBe(false); // Assert
  });
  it('should return true when the parameter is an array', () => {
    const parameter = ['dummy', 'array']; // Arrange
    const actual = Array.isArray(parameter);  // Act
    expect(actual).toBe(true);  // Assert
  });
});
\`\`\`

**De donde venimos**

Se puede ver que resulta relativamente sencillo probar lógica de negocio escribiendo tests con Jest pero ¿Cómo se aplica esto al mundo del frontend?

Tradicionalmente se recomendaba tener la lógica de negocio escrita en archivos llamados controladores y probados mediante test de unidad y por otro lado tener componentes de "vista" encargados de pintar el html de nuestra aplicación.

El problema es que los tests unitarios sólamente probaban una parte de la aplicación (los controladores) y aunque la lógica esté bien, esto no garantiza que la aplicación funcione correctamente y la única opción que quedaba para probar la aplicación era recurrir a los llamados tests End to End (de principio a fin) con herramientas como [Protractor](https://www.protractortest.org/#/) o [Selenium](https://www.selenium.dev/).

Estos tests lanzaban un navegador automatizado y realizaban tareas similares a las de un usuario o un tester: *Navegar a cierta URL, Comprobar que X boton es visible y está activo, Escribir usuario y contraseña, Hacer click en el botón "login" etc...*

Por desgracia estos tests eran terriblemente engorrosos, el navegador se quedaba colgado, había que recurrir a timeouts, necesitas tener un servidor de desarrollo corriendo...una serie de penurias que los hacían inviables.

**Hacia donde vamos.**

Hace relativamente poco, el proyecto [JSDOM](https://github.com/jsdom/jsdom) se volvió maduro y estable, JSDOM es una implementación para NodeJS de las APIS del DOM, es decir, nos permite tener una especie de navegador web virtual en Node.

Esto entre otras cosas, permitiría montar un componente de Angular/React/Vue, rellenar inputs, o hacer click en sus elementos de forma totalmente sincrona y estable.

Esto hizo que Kent C Dodds escribiese una librería llamada [Testing Library](https://testing-library.com/docs/guiding-principles) cuyo principio fundamental se basa en **escribir tests que imiten el comportamiento del usuario/tester, en lugar de centrarse en detalles de implementación**.

**Un ejemplo sencillo**

Imaginemos una aplicación para comprar tickets de un evento cuya interfaz sería más o menos así:

![](https://user-images.githubusercontent.com/2657897/91171743-4babd480-e6db-11ea-939d-ed299e763047.png)

y se espera que al hacer click en el checkbox *VIP* el precio cambie a 0€. Al final la lógica de negocio es muy sencilla: *Un usuario VIP tiene derecho a entradas gratis y un usuario normal tiene que pagar 20€*

Tradicionalmente, escribiríamos por un lado la [lógica de negocio](https://github.com/IagoLast/frontend-testing-examples/blob/master/src/tickets.service.js) y [su test](https://github.com/IagoLast/frontend-testing-examples/blob/master/src/tickets.service.spec.js) y por otro [un componente de vista](https://github.com/IagoLast/frontend-testing-examples/blob/master/src/AppHooks.js) que utilize esta lógica de negocio pero ¿Cómo probarías esto a mano? ¿Cómo probarías esto si no supieses nada de tests automáticos?

Probablemente abrirías la aplicación, verías que el precio de la entrada son 20€ por defecto, harías click en el checkbox y comprobarías que el precio ha cambiado a 0€ entonces... ¿Por qué no hacer justo esto en los tests automáticos? Esto es justamente lo que se puede conseguir con testing-library y es la corriente dominante en los tests de frontend:

\`\`\`js
// Importamos las dependencias necesarias, librerías de testing, react y el componente
import { render, screen } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import React from 'react';
import App from './AppHooks'; 


it('should display 20€ when the user is not VIP ', () => {
  // Renderizamos la app en una pantalla virtual
  render(<App />);
  // Comprobamos que el texto 20€ está visible en la pantalla
  expect(screen.queryByText('20€')).toBeVisible();
});

it('should display 0€ when the user clicks on VIP checkbox ', () => {
  // Volvemos a renderizar la app
  render(<App />); 
  // Hacemos click en el checkbox con la etiqueta "VIP"
  userEvent.click(screen.queryByLabelText('VIP'));
  // Comprobamos que el texto 0€ es visible
  expect(screen.queryByText('0€')).toBeVisible();
});
\`\`\`

Evidentemente esto es un pequeño ejemplo de todo lo que se puede hacer, pero creeme que una vez empiezas a hacer tests no hay vuelta atrás porque en menos de 10 segundos tienes un feedback realista sobre el comportamiento de tu aplicación que te evitará bugs, regresiones y dolores de cabeza.

Si te interesa saber más sobre el tema, puedes echarle un vistazo a mi libro en [frontend-testing.org](http://frontend-testing.org/) o seguirme en [@iagolast](https://twitter.com/iagolast).",
    "slug": "testing-frontend",
    "tags": [
      "react",
    ],
    "title": "Testing en el FrontEnd",
    "userPicture": "",
    "username": "Iago Lastra",
  },
  {
    "category": "typescript",
    "cover": "https://swcrafters.fra1.cdn.digitaloceanspaces.com/Categories/TS_category.png",
    "date": "",
    "description": "La Inyección de Dependencias es un patrón de orientación a objetos que nos ayuda a mantener el codigo desacoplado, permitiendo que este sea mas tolerante al cambio.",
    "id": "inyeccion-de-dependencias-componentes",
    "markdownBody": "Hoy en día es bien sabido que la utilización de patrones y buenas prácticas de programación nos ayudan en la creación y mantenimiento de nuestro software.

Hay una gran variedad de patrones interesantes, a medida que los vas aplicando descubres que cada uno de ellos te ayuda a cumplir que tu software sea más ***-ble** (mantenible, extensible, entendible, testeable, etc.)

En este artículo me gustaría introducirte el patrón **Inyección de Dependencias** relacionado con una serie de buenas prácticas y patrones que veremos a continuación, empecemos.

## ¿Por qué aprender este patrón?

Una de las principales razones para las que me gusta aplicarlo, es para **reducir el acoplamiento** entre las diferentes piezas de mi software.

La práctica me demuestra que si **reduzco el acoplamiento** tendré una mejora en mis **-ble**(recuerda: mantenible, extensible, entendible, testeable, etc.) Pero… ¿Por qué quiero cumplir todo esto? Pues entre otras cosas podré hacer mejor software con menor coste que no tenerlos en cuenta. ¿Qué más me da tener menos costes? Bueno parece que si cumplo todo esto reduciré mis tiempos en las mismas tareas, menos estrés y quién sabe si una vida más feliz.

Es decir, si usará un poco de *clickbait*, podría cambiar el título por **Cómo ser más feliz gracias a la inyección de dependencias :)**

![](https://swcrafters.fra1.cdn.digitaloceanspaces.com/Posts/inyeccion-de-dependencias-componentes/1.gif)

Aun así, puede ser que el *clickbait* no sea suficiente para convencerte, veamos algunas otras ideas, para ello necesito presentarte a la **D** de [**SOLID](https://softwarecrafters.io/cleancode-solid-testing-js).**

¿Los principios qué? Los principios [SOLID](https://softwarecrafters.io/cleancode-solid-testing-js), son unos principios pensados para hacer nuestro software más **-ble** son un resumen de las buenas prácticas propuestas en el año 2000 por el famoso **Uncle Bob ([Robert C. Martin](https://en.wikipedia.org/wiki/Robert_C._Martin)) **y son unos principios básicos del mundo del software que deberías conocer (y no solo porqué los pregunten en las entrevistas).

Si quieres profundizar en SOLID, te recomiendo que le eches un vistazo al e-book de Software Crafters:

* [https://softwarecrafters.io/cleancode-solid-testing-js](https://softwarecrafters.io/cleancode-solid-testing-js)

## Inversión de Dependencias

El principio de **Inversión de Dependencias** más conocido como [*Dependency Inversion](https://en.wikipedia.org/wiki/Dependency_inversion_principle)** nos introduce que dados dos módulos relacionados entre si, por ejemplo **A** y **B**. Ninguno de ellos dos debería depender del otro, deberíamos usar una **abstracción** para esa relación. Eso permite que **A** o **B** no conozcan realmente al otro, simplemente entienden que cumple esa abstracción mencionada anteriormente.

En la mayoría de los lenguajes *(en casi todos los que se me ocurren)* a esa abstracción la llamamos **Interfaz** y las interfaces en software no son más que **contratos** que deben ser cumplidos, es decir si **A** necesita a **B**, oficialmente diremos que **A** necesita a alguien que cumpla la interfaz (el contrato) **IB** (la mayoría de las veces si tenemos un módulo llamado **B**, al contrato le pondremos una **I** delante para identificarlo como interfaz de **B**). Y en este caso **B** cumplirá ese contrato, aunque a **A** le da igual que quién cumpla **IB** sea **B, C, D **o** Z.**

![](https://swcrafters.fra1.cdn.digitaloceanspaces.com/Posts/inyeccion-de-dependencias-componentes/2.gif)

¿Interesante verdad? Antes de pasar a la inyección de dependencias me gustaría hablarte de un **Patrón de Diseño** también muy interesante y relacionado.

## Inversión de Control

El patrón de diseño, **Inversión de Control** conocido como [*Inversion of Control* (IoC)](https://en.wikipedia.org/wiki/Inversion_of_control). Nos explica que cuando una clase (o componente, pieza de software) depende de otra clase la primera no debería gestionar el **ciclo de vida** de la segunda, esto debería ser hecho en **otro ámbito**.

En palabras sencillas, viene a decir que si en el constructor de tu clase haces un new B(); parece que puedes hacerlo mejor. 

Este otro ámbito no suele estar especificado, aunque casi siempre acabaremos llamándolo **Contenedor**.

Lo que haremos cuando estemos en **A** y queramos usar **B** no será crear una nueva instancia del segundo, le pediremos a este **Contenedor** (o el elemento correspondiente) que nos provee de **B** y será en este en el que caerá la responsabilidad de gestionar todo el ciclo de vida de **B**.

![](https://swcrafters.fra1.cdn.digitaloceanspaces.com/Posts/inyeccion-de-dependencias-componentes/3.gif)

## ¿Y entonces qué es la Inyección de Dependencias?

Una vez damos por hecho que nos interesa la **Inversión de Dependencias** y la **Inversión de Control** puede ser muy interesante tener una herramienta (o en este caso un patrón) que nos ayude a cumplir ambas. 

Esto es la **Inyección de Dependencias**, un patrón que nos da una solución a las dos prácticas anteriores, pero no tiene por qué ser la única solución a esas prácticas, puede haber otras distintas. Esta simplemente nos da solución a ambas a la vez.

Cuando estamos en **A** y queremos **B**, le pedimos a nuestro **Contenedor** que por favor nos provee a alguien que cumpla el contrato **IB** y dependiendo del caso este contenedor nos dará **B** o un equivalente que corresponda. Por ejemplo, si estamos testeando quizá recibimos **MockB**.

![](https://swcrafters.fra1.cdn.digitaloceanspaces.com/Posts/inyeccion-de-dependencias-componentes/4.gif)

## Empezando a trabajar con Inyección de Dependencias

Después de toda la teoría expuesta, vamos a empezar a trabajar con la Inyección de Dependencias de forma práctica, poco a poco.

Imaginemos primero que tenemos un **Servicio** llamado **CartService** básicamente es un servicio que nos ayuda a gestionar el carrito de la compra de nuestro software. Pero tenemos la necesidad de usar otro servicio de **Insights** para saber cuando un usuario añade un producto, lo borra, etc.

![](https://swcrafters.fra1.cdn.digitaloceanspaces.com/Posts/inyeccion-de-dependencias-componentes/5.gif)

Podemos importar este otro servicio de **Insights** de diferentes modos, una forma seria importar el objeto entero de tal modo que en cualquier otro servicio que importemos **Insights** tendremos la misma instancia.

Esto sería lo más parecido a un [**’’’Singleton’’’](https://en.wikipedia.org/wiki/Singleton_pattern)** que hagamos en Frontend.

![](https://swcrafters.fra1.cdn.digitaloceanspaces.com/Posts/inyeccion-de-dependencias-componentes/6.png)

Y si no queremos que cada vez que se importe **Insights** sea la misma instancia, lo que podemos hacer es importar la clase e instanciar cada vez que lo necesitemos. Muy bien esto parece algo más de tipo **’’’Transient’’’.**

![](https://swcrafters.fra1.cdn.digitaloceanspaces.com/Posts/inyeccion-de-dependencias-componentes/7.png)

¡Felicidades! Con esto tendríamos una aproximación muy simple a lo que es **Inyección de Dependencias** pero una vez leída la teoría podemos al menos entender que está pasando.

El problema es que siguen faltando muchos puntos a comentar, las clases tienen mucha responsabilidad, no he hablado de ningún contenedor, ni siquiera menciono las abstracciones, etc.

Vamos a ver la **Inyección de Dependencias** paso a paso, hasta llegar a lo que considero el escenario ideal en Frontend para inyectar dependencias.

## Paso 1: Semi-Inyección

![](https://swcrafters.fra1.cdn.digitaloceanspaces.com/Posts/inyeccion-de-dependencias-componentes/8.png)

En este caso ya no importamos **Insights** directamente, sino que importamos una [**Factoría](https://es.wikipedia.org/wiki/Factory_Method_(patr%C3%B3n_de_dise%C3%B1o))**, esto nos ayuda a abstraernos y no saber (desde **CartService**) si este primero es **Singleton** o **Transient** de hecho nos da igual.

Además pasamos las dependencias por el constructor de **CartService** lo que empieza a parecer una **Inyección** al uso.

Este primer nivel es un nivel académico y no tiene por qué ser un patrón ideal para usar en proyectos, pero a veces puede ser más que suficiente (tal y como me demostró mi compañero [Carlos de Miguel](https://twitter.com/demiguelfer)).

## Paso 2: Auto-Inyección

![](https://swcrafters.fra1.cdn.digitaloceanspaces.com/Posts/inyeccion-de-dependencias-componentes/9.png)

En el siguiente ejemplo académico, lo que buscamos es que no tengamos que depender siquiera de ninguna factoría, y además utilizamos unos decoradores para ocultar el hecho de que tengamos que pasar las dependencias por el constructor. 
Se parece un poco a como lo hacía Angular 1 y los decoradores se parece a librerías más modernas.

De momento sigue siendo **Insights** quién decide que tipo de inyección va a realizar, lo cual es bueno porqué no lo hace **CartService** pero se puede mejorar.

## Paso 3: Inyección con Contenedores

![](https://swcrafters.fra1.cdn.digitaloceanspaces.com/Posts/inyeccion-de-dependencias-componentes/10.png)

Este ejemplo empieza ya a ser interesante y algo más práctico, añadimos un **Contenedor** que se encargue de manejar todo lo relacionado con las dependencias del proyecto (o del módulo).

Esto nos ayuda mucho ya que ahora los **Servicios** son solo responsables de su lógica y es este **Contenedor** el encargado de decidir:

* Cuando se instancias las dependencias.

* Cómo se instancia cada una de ellas (*Singleton, Transient*)

* En qué orden se van a registrar.

Hemos llegado al ecuador de los pasos, pero todavía no tenemos algo totalmente funcional, sigamos con el paso 4.

## Paso 4: Un mundo más realista

![](https://swcrafters.fra1.cdn.digitaloceanspaces.com/Posts/inyeccion-de-dependencias-componentes/11.png)

Aunque en el ejemplo anterior tenemos algo bastante funcional, es verdad que eso de pasar al constructor un parámetro y que mágicamente aparezca ahí sin darle un tipo o un id o algo es bastante automágico (Angular 1 :D).

En este siguiente paso decoramos los parámetros asignando un ID que van a ser con los que nuestro contenedor identifique la dependencia.

Esto nos da una solución bastante sencilla y real, pero en otros lenguajes utilizamos **Abstracciones** para ahorrarnos el ID.

## Paso 5: Añadiendo Abstracciones

![](https://swcrafters.fra1.cdn.digitaloceanspaces.com/Posts/inyeccion-de-dependencias-componentes/12.png)

Si añadimos [**TypeScript](https://www.typescriptlang.org/)** a la mezcla podemos usar **Interfaces** como **Abstracción.**

Primero, permíteme comentar que esto no es un paso obligatorio si trabajas en Frontend, pero si quieres una capa de **Abstracción** va a ayudarte mucho.

Ahora identificamos las dependencias por su **Interfaz** además de por su ID y aquí es donde se abre un pequeño debate.

Aunque solo con la **Interfaz** debería ser más que suficiente, por el momento los navegadores no interpretan **TypeScript**, así que una vez compilado el navegador no va a tener nada que interpretar si no tenemos ese ID, por suerte si ponemos un poco de la famosa automagia, podemos llegar a ocultar eso con un poco de [**Reflection](https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Reflect).**

## Paso 6: Implementando DI en los Componentes

![](https://swcrafters.fra1.cdn.digitaloceanspaces.com/Posts/inyeccion-de-dependencias-componentes/13.png)

Aunque en la mayoría de lenguajes de programación usamos **Inyección de Dependencias** a través del constructor, en los componentes puede ser más sencillo cambiar a inyección por propiedad, como por ejemplo se hacía en algunas versiones de Android.

La funcionalidad es exactamente la misma pero nos quedará un código más parecido al de la foto anterior, al que también se le ha añadido **Reflection** para que no tengamos que usar los id* (aunque debe ser siempre un paso opcional).*

¿Pero hay de verdad algo real detrás de todo esto?

## La librería para inyectar dependencias

Cómo siempre en el software, podríamos crear nuestra propia librearía de **Inyección de Dependencias** o utilizar una que ya exista. En mi caso me gusta mucho [Inversify](http://inversify.io/) de [Remo H. Jansen](https://twitter.com/RemoHJansen).

Tras mucho tiempo utilizándola en proyectos reales y en producción, creamos un pequeño *wrapper* llamado [**Inversify-Props](https://github.com/CKGrafico/inversify-props)** que ayuda en el **Paso 6** de los ejemplos anteriores.

![](https://swcrafters.fra1.cdn.digitaloceanspaces.com/Posts/inyeccion-de-dependencias-componentes/14.gif)

En la [documentación](https://github.com/CKGrafico/inversify-props) se pueden observar ejemplos de cómo usar la librería, pero analicemos un par de ellos.
\`\`\`javascript
    import 'reflect-metadata'; // Import only once
    import { container, inject } from 'inversify-props';
    
    container.addSingleton<IService1>(Service1);
    container.addSingleton<IService2>(Service2);
    
    export default class extends Component {
      @inject() service1: IService1;
      @inject() service2: IService2;
    }
\`\`\`

Esta librería ya gestiona el contenedor por ti, simplemente lo importas y añades los servicios que quieras, después en cada componte *(de cualquier framework)* inyectas la dependencia utilizando decoradores.

En el ejemplo anterior se usa *reflection* para no tener que utilizar IDs pero es algo totalmente opcional y la librería autogenera IDs para que puedas utilizarlos si no quieres usar *reflection*.
\`\`\`javascript
    import 'reflect-metadata'; // Import only once
    import { cid, container, inject } from 'inversify-props';
    
    container.addSingleton<IService1>(Service1);
    
    export default class extends Component {
      @inject(cid.IService1) service1: IService1;
    }
\`\`\`

Incluso puedes usar cualquier ID que prefieras.
\`\`\`javascript
    import 'reflect-metadata'; // Import only once
    import { container, inject } from 'inversify-props';
    
    container.addSingleton<IService1>(Service1, 'myid');
    
    export default class extends Component {
      @inject('myid') service1: IService1;
    }
\`\`\`

Para marcar un servicio como candidato a ser inyectado utilizamos el decorador propio de **Inversify**.
\`\`\`javascript
    // iservice1.ts
    export interface IService1 {
        method1(): string;
    }
    
    // service.ts
    @injectable()
    export class Service1 implements IService1 {
      method1(): string {
        return 'method 1';
      }
    }
\`\`\`

Pues esto es todo sobre **Inyección de Dependencias, Inversión de Control e Inversión de Dependencias** ¿Qué te parece? ¿Sueles inyectar dependencias en tus proyectos de Frontend? ¿Y en los de Backend? Empieza ahora mismo y disfruta de las facilidades de uno de los patrones más interesantes que podrás aprender este año.

**BONUS:** ¿Usas *hooks*? No te pierdas la [versión simplificada para usar en Hooks](https://github.com/CKGrafico/inversify-hooks).
",
    "slug": "inyeccion-de-dependencias-componentes",
    "tags": [
      "typescript",
    ],
    "title": "Inyección de dependencias en componentes",
    "userPicture": "",
    "username": "Quique Fdez",
  },
  {
    "category": "css",
    "cover": "https://swcrafters.fra1.cdn.digitaloceanspaces.com/Categories/postcss_category.png",
    "date": "",
    "description": "PostCSS Preset Env le permite convertir CSS moderno en algo que la mayoría de los navegadores pueden entender, determinando los polyfills que necesita.",
    "id": "postcss-preset-env-babel-css",
    "markdownBody": "La definición oficial de **PostCSS Preset Env** dice:

> PostCSS Preset Env le permite convertir CSS moderno en algo que la mayoría de los navegadores pueden entender, determinando los polyfills<sup>(1)</sup> que necesita en función de sus navegadores de destino o entornos de tiempo de ejecución, utilizando cssdb<sup>(2)</sup>.

Lo primero que me llamó la atención de la definición es lo de **CSS moderno**, pero creo que encajaría mejor si dijera **"Funcionalidades CSS de la especificación"**. Espera, ¿eso qué quiere decir?

Pues que podemos utilizar las funcionalidades que se están definiendo en el CSSWG<sup>(3)</sup> antes de que acaben como un estándar de la W3C<sup>(4)</sup> y lo tengamos disponible en los navegadores.

## ¿Cómo funciona el estándar CSS?

El **CSS Working Group** es un grupo de personas profesionales de la web, la mayoría de ellas empleadas de las grandes marcas que están detrás de los navegadores, sistemas operativos y dispositivos, como Apple, Google, Microsoft, Adobe, Mozilla o Amazon, aquí os dejo un enlace a la lista completa de [miembros de la CSSWG](https://www.w3.org/Style/CSS/members/members.en.php3)

El foco de ese grupo de trabajo es estandarizar las funcionalidades de CSS, así como la definición de nuevas. Es aquí donde nos vamos a centrar. Esas nuevas funcionalidades en muchas ocasiones tardan mucho en llegar a los navegadores de los usuarios. Sí, sí, de los usuarios. Nosotros como freakis de la tecnología tenemos las últimas versiones de los navegadores, además tenemos más de uno para poder validar el correcto funcionamiento de nuestros desarrollos, pero los usuarios suelen tener el navegador instalado por defecto en los dispositivos y muchos de ellos no actualizan el software por miedo a perder configuraciones.

Aquí es donde en muchas ocasiones sentimos una gran frustración, vemos que aparecen nuevas e impresionantes funcionalidades en las que están trabajando, pero tardan en llegar al usuario.

## ¿Qué tiene que ver esto con Babel?

De igual forma que para CSS existe el CSSWG, para Javascript existe el **TC39**<sub>(5)</sub>, donde de forma similar, un grupo de personas debaten y definen las nuevas funcionalidades para el lenguaje de la web.

La adopción de esas nuevas funcionalidades no tienen la misma velocidad de implementación por parte de los diferentes navegadores, en la tabla **compat-table** podemos ver una lista del soporte por cada una de las features.

![](https://swcrafters.fra1.cdn.digitaloceanspaces.com/Posts/postcss-babel-css/compat-table.png)
Aquí podemos ver la tabla para [ES2016+](https://kangax.github.io/compat-table/es2016plus/)

Para gestionar y versionar las propuestas, el TC39 definió los siguientes estados:

| Estado                  | Descripción                                                                                                                                                                                                                                                                                                                                                                                                                             |
| :---------------------- | :-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **stage-0** (Strawman)  | En este estado se suben ideas del comité TC39 o de alguien registrado como contribuidor. De estas características, algunas se llegan a implementar y otras són descartadas.                                                                                                                                                                                                                                                             |
| **stage-1** (proposal)  | El "champion" se convierte en el responsable de la propuesta. En este punto ya existe una descripción formal de la idea, descrita en forma de ejemplos, una API, semántica y algoritmos.                                                                                                                                                                                                                                                |
| **stage-2** (draft)     | Es una primera versión de lo que se incluirá en la especificación. Normalmente cuando se llega a este punto suele ser segura su inclusión en el estándar. Se necesita tener una descripción usando el lenguaje de **ECMAScript**. Además, se requiere dos implementaciones experimentales, pero una de ellas puede ser haciendo uso de un transpilador como **Babel**.                                                                  |
| **stage-3** (candidate) | La propuesta está casi finalizada y ahora se necesitan las opiniones de los usuarios de las implementaciones para progresar. El texto de la especificación debe estar completo. Los evaluadores designados por el TC39 deben finalizar la especificación. Debe haber al menos dos implementaciones funcionales. Los cambios sólo se harán en respuesta a problemas críticos que se hayan descubierto por las implementaciones y su uso. |
| **stage-4** (finished)  | La propuesta está lista para ser incluida en el estándar.                                                                                                                                                                                                                                                                                                                                                                               |

Como podemos ver en la descripción del stage-2, para poder utilizar las nuevas funcionalidades debemos transpilar el código para que lo pueda entender el navegador. Para ello podemos utilizar **[Babel](https://babeljs.io/)**, pero hay otros, como **[Traceur](https://github.com/google/traceur-compiler)** de Google.

## Babel

**Babel**<sup>(6)</sup> es un transpilador que se encarga de convertir nuestro código JavaScript, con las nuevas funcionalidades y sintaxis, a un código que sea capaz de interpretar el navegador.

Para hacer esta transpilación Babel nos ofrece **[@babel/preset-env](https://babeljs.io/docs/en/babel-preset-env)**, para poder configurar el soporte de navegador que deseamos para nuestro proyecto.

## PostCSS Preset Env

Aquí es donde encontramos la similitud con Babel, **PostCSS Preset Env**, creado por [Jonathan Neal](https://twitter.com/jon_neal), nos ofrece la opción de trabajar con las nuevas funcionalidades CSS que están en modo borrador en la W3C.

Para hacerlo se basa en **cssdb**, que es una lista completa de características CSS y sus posiciones en el proceso de convertirse en estándares web implementados.

Al igual que lo hace Babel, dispone de varios estados:

| Estado                                                                       | Descripción                                                                                                                                                                                                                                                                                                                     |
| :--------------------------------------------------------------------------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| **Stage 0**: Aspirational<br>"Esta es una idea loca"                         | Un borrador no oficial o un borrador de editor defendido por un miembro del W3C Working Group. Debe considerarse altamente inestable y sujeto a cambios. Las características de la etapa 0 están abiertas a ideas y discusión, pero no pueden considerarse serias.                                                              |
| **Stage 1**: Experimental<br>"Esta idea podría no ser una locura"            | Un borrador de editor o un borrador de trabajo inicial defendido por un miembro del W3C Working Group. Debe considerarse altamente inestable y sujeto a cambios. Las características de la etapa 1 se reconocen como un problema real, pero pueden no estar vinculadas a ninguna solución en particular.                        |
| **Stage 2**: Allowable<br>"Esta idea no es una locura"                       | Un borrador de trabajo inicial defendido por un miembro del W3C Working Group. Debe considerarse relativamente inestable y sujeto a cambios. Las características de la etapa 2 están vinculadas a una forma particular de resolver un problema.                                                                                 |
| **Stage 3**: Embraced<br>"Esta idea se está convirtiendo en parte de la web" | Una recomendación candidata defendido por un miembro del W3C Working Group, generalmente implementado por al menos 2 proveedores de navegadores reconocidos, posiblemente detrás de un flag. Debe considerarse estable y sujeto a pocos cambios. Las características de la etapa 3 probablemente se convertirán en un estándar. |
| **Stage 4**: Standardized<br>"Esta idea es parte de la web"                  | Una recomendación defendido por el W3C. Debe ser implementado por todos los proveedores de navegadores reconocidos. Las características de la etapa 4 són estándares web.                                                                                                                                                       |

En PostCSS Preset Env actualmente disponemos de 33 propiedades CSS repartidas entre los diferentes estados.

- **Stage 3**: 6 propiedades
- **Stage 2**: 20 propiedades
- **Stage 1**: 6 propiedades
- **Stage 0**: 1 propiedades

En la web podemos ver un listado muy detallado de todas las propiedades CSS en desarrollo que tenemos disponible, indicando el estado, un enlace a la especificación en la W3C, un enlace al plugin PostCSS que se encarga de transpilar nuestro código y finalmente un ejemplo de código.

![Función CSS image-set()](https://swcrafters.fra1.cdn.digitaloceanspaces.com/Posts/postcss-babel-css/image-set.png)

## Instalación

Vamos a ver cómo podemos instalar PostCSS Preset Env. Como la mayoría de herramientas que tenemos hoy en día en el desarrollo frontend, lo tenemos disponible como un paquete de **npm**. Hay varias maneras de utilizar PostCSS Preset Env, lo podemos integrar con Node, PostCSS CLI, Webpack, Create React App, Gulp, Grunt y recientemente con Rollup. En el fichero [INSTALL.md](https://github.com/csstools/postcss-preset-env/blob/master/INSTALL.md) del repositorio oficial podemos ver detalladamente cada una de esas instalaciones.

Para el ejemplo nos vamos a basar en PostCSS CLI.

\`\`\`bash
npm install postcss-preset-env --save-dev
\`\`\`

Esto nos instalará el paquete *postcss-preset-env* en nuestro proyecto, pero ahora necesitamos utilizarlo con PostCSS CLI. Vamos a instalarlo:

\`\`\`bash
npm install postcss-cli --save-dev
\`\`\`

Utilizaremos el fichero \`postes.config.js\` para configurarlo, esto es lo que tendremos en su interior:

\`\`\`javascript
const postcssPresetEnv = require("postcss-preset-env");

module.exports = {
  plugins: [postcssPresetEnv(/* pluginOptions */)]
};
\`\`\`

En el ejemplo estamos definiendo sólo la parte que afecta a *postcss-preset-env*, pero en este fichero podríamos añadir otros plugins, como *postcss-import* para poder importar archivos CSS, ya que import no está en la especificación.

Ahora vamos a adentrarnos en las opciones de configuración que tenemos disponibles. En lugar del comentario *pluginOptions* pasaremos un objeto. Veamos algunos ejemplos.

### Configuración por estado

Si configuramos **Stage 0** tenemos disponibles todas las nuevas funcionalidades:

\`\`\`javascript
...
	postcssPresetEnv({ stage: 0 })
...
\`\`\`

### Configuración por funcionalidad

En este ejemplo además de definir el estado, en este caso el 3, añadimos la clave *feature* al objeto y le indicamos la funcionalidad que queremos.

\`\`\`javascript
...
	postcssPresetEnv({
	  /* use stage 3 features + css nesting rules */
	  stage: 3,
	  features: {
	    'nesting-rules': true
	  }
	})
...
\`\`\`

Con esta configuración estamos definiendo que queremos las propiedades con estado 3, que són las previas a formar parte del estándar, pero también queremos que se añada *nesting-rukes*, que actualmente pertenece al grupo con estado 1. Esta es una de las cosas que más me gusta de PostCSS Preset Env, podemos configurar y adaptar el entorno de desarrollo en cada proyecto.

### Configuración por navegador

Otra manera que tenemos de configurar las funcionalidades CSS es definiendo el soporte de los navegadores:

\`\`\`javascript
...
	postcssPresetEnv({ browsers: 'last 2 versions' })
...
\`\`\`

Como indica la propia documentación en este caso también podríamos utilizar una clave *browserlist* en *package.json* o añadir el fichero *.browserlist*<sup>(7)</sup>.

### Configuraciones avanzadas

Hay dos de las opciones de configuración que me parecen una auténtica maravilla, són **importFrom** y **exportTo**.

**importFrom** nos permite definir, uno o varios archivos, donde tengamos configuradas variables como Custom Media, Custom Properties, Custom Selectors. Y he dicho variables porque podemos importar CSS, Javascript o Json.

Si tenemos un archivo *src/themes/sw_crafters/settings.css* con el contenido:

\`\`\`css
@custom-media --small-viewport (max-width: 30em);
@custom-selector :--seo-headings h1, h2, h3;
:root {
  --color-primary: #434343;
  --font-family: Monserrat, HelveticaNeue, "Helvetica Neue", Helvetica, Arial,
    sans-serif;
}
\`\`\`

Podremos importar el archivo de configuración del tema **sw_creafter** de la siguiente forma:

\`\`\`javascript
...
	postcssPresetEnv({
	  stage: 0,
	  importFrom: 'src/themes/sw_crafters/settings.css'
	})
...
\`\`\`

Al contrario que importFrom, **exportTo** se encarga de exportar las Custom Media, Custom Properties y Custom Selectors de nuestro proyecto. De igual manera, podemos hacerlo en formato CSS, Javascript y Json, solo tenemos que indicar la ruta, y la extensión del archivo definirá el formato de salida.

\`\`\`javascript
...
	postcssPresetEnv({
	  stage: 0,
	  esportTo: 'data/themes/sw_crafters/settings.js'
	})
...
\`\`\`

Así quedaría la exportación de la configuración del tema sw_crafters:

\`\`\`javascript
module.exports = {
  customMedia: {
    "--small-viewport": "(max-width: 30em)"
  },
  customProperties: {
    "--color-primary": "#434343",
    "--font-family":
      'Monserrat, HelveticaNeue, "Helvetica Neue", Helvetica, Arial, sans-serif'
  },
  customSelectors: {
    ":--seo-headings": "h1,h2,h3"
  }
};
\`\`\`

Estas dos opciones nos van a permitir tener un mayor control de los tokens<sup>(8)</sup> de nuestro Design System<sup>(9)</sup>.

## Recursos

El recurso principal es la web oficial https://preset-env.cssdb.org/

![Web PostCSS Preset Env](https://swcrafters.fra1.cdn.digitaloceanspaces.com/Posts/postcss-babel-css/postcss-preset-env-web.png)

En ella encontraremos todas las nuevas funcionalidades CSS, un playground donde poder probarlo directamente en nuestro navegador.

![PostCSS Playground](https://swcrafters.fra1.cdn.digitaloceanspaces.com/Posts/postcss-babel-css/playground.png)

A la izquierda podemos escribir nuestro código CSS, y a la derecha tendremos el código transpilado para dar soporte a los navegadores actuales según el estado y soporte de navegadores que hayamos elegido.

En la web también encontraremos un enlace a soporte, donde nos lleva a una room<sup>(10)</sup> de Gitter<sup>(11)</sup>, donde encontraremos soporte de una gran comunidad de PostCSS.

![Gitter](https://swcrafters.fra1.cdn.digitaloceanspaces.com/Posts/postcss-babel-css/gitter.png)

Por último también tenemos el enlace al repositorio en GitHub.

### Ask Me Anything!

Como último recurso os quiero compartir este repositorio [ama](https://github.com/nucliweb/ama)<sup>(12)</sup> en GitHub, donde a través de los issues estoy abierto a resolver cualquier duda de temas relacionados con CSS, PostCSS, SVG, CSS Houdini, Web Animation y Media Optimization. Así que si tenéis alguna duda sobre PostCSS o alguno de los otros temas, estaré encantado de ayudar en lo que pueda.

![Ask Me Anything!](https://swcrafters.fra1.cdn.digitaloceanspaces.com/Posts/postcss-babel-css/ama.png)

## Conclusiones

Yo aposté por PostCSS desde hace tiempo, aún a día de hoy veo que hay gente que se confunde al acercarse a este preprocesador. Es normal, hay tanta flexibilidad que puede llevar a confusión. Pero creo que utilizar PostCSS Preset Env, que funciona como un paquete para poder seguir desarrollando en CSS nativo, es una gran puerta de entrada, y podemos ampliar y adaptar nuestro entorno de desarrollo poco a poco.

Os invito a utilizarlo en vuestro nuevo proyecto o integrarlo en el proyecto actual, ya que PostCSS puede convivir sin problema con otros preprocesadores como Sass. Seguro que mucha gente ya lo está haciendo... ¿sabes que si estás utilizando [Autoprefixer](https://autoprefixer.github.io/), ya estás utilizando PostCSS?

#### Notas

- (1) [Polyfill](<https://en.wikipedia.org/wiki/Polyfill_(programming)>)
- (2) [Web cssdb](https://cssdb.org/)
- (3) [CSS Working Group](https://drafts.csswg.org/)
- (4) [World Wide Web Consortium](https://www.w3.org/)
- (5) [Technical Committee 39](https://www.ecma-international.org/memento/tc39-rf-tg.htm)
- (6) [Babel](https://babeljs.io/)
- (7) [Configuración de browserlist](https://github.com/browserslist/browserslist#readme)
- (8) [Tokens](https://css-tricks.com/what-are-design-tokens/)
- (9) [Design System](https://www.learnstorybook.com/design-systems-for-developers/)
- (10) Una room en Gitter es como un team en Slack
- (11) Gitter es una herramienta de comunicación, similar a Slack, pero relacionada con un repositorio de GitHub.
- (12) As Me Anything, es una idea original de **‌Avi Flombaum** que creó un repositorio para poder utilizar el sistema de issues de GitHub y resolver dudas.
",
    "slug": "postcss-preset-env-babel-css",
    "tags": [
      "css",
    ],
    "title": "PostCSS Preset Env, el Babel de CSS",
    "userPicture": "",
    "username": "Joan León",
  },
  {
    "category": "javascript",
    "cover": "https://swcrafters.fra1.cdn.digitaloceanspaces.com/Categories/JS_category.png",
    "date": "",
    "description": "Test Driven Development (TDD), o desarrollo dirigido por test en castellano, es una técnica de ingeniería de software para diseñar software. ",
    "id": "tdd-test-driven-development",
    "markdownBody": ">**El testing de software puede verificar la presencia de errores pero no la
ausencia de ellos. – Edsger Dijkstra**

**Test Driven Development (TDD)**, o **desarrollo dirigido por test** en castellano, es una técnica de ingeniería de *software* para, valga la redundancia, diseñar *software*. Como su propio nombre indica, esta técnica dirige el desarrollo de un producto a través de ir escribiendo pruebas, generalmente unitarias.

El TDD fue desarrollado por Kent Beck a finales de la década de los 90 y forma parte de la metodología **extreme programming**. Su autor y los seguidores del TDD aseguran que con esta técnica se consigue un código más tolerante al cambio, robusto, seguro, más barato de mantener e, incluso, una vez que te acostumbras a aplicarlo, promete una mayor velocidad a la hora de desarrollar.

![Viñeta de commit strip sobre la importancia de los tests.](https://swcrafters.fra1.cdn.digitaloceanspaces.com/Posts/tdd_test_driven_development/testing_strip.jpg =90%x*)

###### Viñeta de Commit Strip sobre la importancia de los tests.

**NOTA:** Este artículo es un extracto de la sección de testing y TDD de nuestro libro [Clean Code, SOLID y Testing aplicado a JavaScript](https://softwarecrafters.io/ebook-cleancode-javascript). ¡Espero que lo disfrutes!

## Las tres leyes del TDD

Robert C. Martin describe la esencia del TDD como un proceso que atiende a las siguientes tres reglas:

* No escribirás código de producción sin antes escribir un test que falle.
* No escribirás más de un test unitario suficiente para fallar (y no compilar es fallar).
* No escribirás más código del necesario para hacer pasar el test.
  
Estas tres leyes derivan en la repetición de lo que se conoce como el ciclo *Red-Green-Refactor*. Veamos en qué consiste:

## El ciclo Red-Green-Refactor

El ciclo *Red-Green-Refactor*, también conocido como algoritmo del TDD, se basa en:

* **Red**: Escribir un test que falle, es decir, tenemos que realizar el test antes de escribir la implementación. Normalmente se suelen utilizar test unitarios, aunque en algunos contextos puede tener sentido hacer TDD con test de integración.
* **Green**: Una vez creado el test que falla, implementaremos el mínimo código necesario para que el test pase.
* **Refactor**: Por último, tras conseguir que nuestro código pase el test, debemos examinarlo para ver si hay alguna mejora que podamos realizar.
* Una vez que hemos cerrado el ciclo, empezamos de nuevo con el siguiente requisito.

![Ciclo Red-Green-Refactor](https://swcrafters.fra1.cdn.digitaloceanspaces.com/Posts/tdd_test_driven_development/testing_tdd_rgr.png =85%x*)

###### Ciclo Red-Green-Refactor.

Esta forma de programar ofrece dos beneficios principales. El primero y más obvio es que obtenemos un código con una buena cobertura de test, lo que es positivo hasta cierto punto. Recuerda, nos pagan por escribir código que funciona, no por hacer test.

El segundo beneficio es que escribir primero las pruebas nos ayuda a diseñar la API que va a tener nuestro componente, ya que nos obliga a pensar en cómo queremos utilizarlo. Esto suele acabar derivando en componentes con responsabilidades bien definidas y bajo acoplamiento.

## TDD como herramienta de diseño

Cuando Kent Beck desarrolló esta metodología lo hizo centrándose en el segundo de los beneficios que describimos en el apartado anterior, es decir, en TDD como una herramienta de diseño de software que nos ayuda a obtener mejor código, no a obtener más test. Para ello, una vez que tenemos una lista con los primeros requisitos que debe satisfacer el producto, debemos seguir los siguientes pasos:

1. Escogemos un requisito.
2. Escribimos un test que falla.
3. Creamos la implementación mínima para que el test pase.
4. Ejecutamos todos los tests.
5. Refactorizamos.
6. Actualizamos la lista de requisitos.

En el último paso, cuando actualizamos la lista de requisitos, además de marcar como completado el requisito implementado, debemos añadir los nuevos requisitos que hayan podido aparecer.

Normalmente, cuando desarrollamos un producto *software*, los requisitos no están completamente definidos desde el principio, o estos sufren cambios a corto y medio plazo, bien porque son descartados, modificados o porque surgen otros nuevos. TDD encaja muy bien con este tipo de escenarios ya que, además de ir añadiendo test que evalúan que nuestro diseño cumple con los requisitos especificados, ayuda a descubrir nuevos casos que no se habían detectado previamente. A esto último se le conoce como **diseño emergente**.

Esta es la razón por la que para muchos de sus seguidores la última “D” de TDD debería significar *design* en vez de *development*.

## Estrategias de implementación, de rojo a verde.

Quizás uno de los puntos más delicados a la hora de aplicar TDD como herramienta de diseño es en el paso en el que ya tenemos un test que falla y debemos crear la implementación mínima para que el test pase. Para ello Kent Beck, en su libro *[Test Driven Development by Example](https://amzn.to/2mkC2Vt)*, expone un conjunto de estrategias, también conocidas como patrones de barra verde, que nos van a permitir avanzar en pasos pequeños hacia la solución del problema.

### Implementación falsa

Una vez que tenemos el test fallando, la forma más rápida de obtener la primera implementación es creando un fake que devuelva una constante. Esto nos ayudará a ir progresando poco a poco en la resolución del problema, ya que al tener la prueba pasando estamos listos para afrontar el siguiente caso.

La mejor forma de entender el concepto es con un ejercicio práctico. El ejercicio es simple, vamos a construir una función que reciba como parámetro un número entero n y devuelva el n-ésimo número de Fibonacci. Recuerda la sucesión de Fibonacci comienza con 0 y 1, los siguientes términos siempre son la suma de los dos anteriores:

![Sucesión de Fibonacci.](https://swcrafters.fra1.cdn.digitaloceanspaces.com/Posts/tdd_test_driven_development/testing_fibonacci.png =90%x*)

###### Sucesión de Fibonacci

Observando la tabla anterior, podemos darnos cuenta de que los casos *edge* son 0 y 1, además de los más sencillos de implementar. Vamos a empezar por crear el test para n = 0:

\`\`\`javascript
//Fibonacci, primer test.
describe('Fibonacci should', () => {
  it('return zero if receive zero', () => {
    expect(fibonacci(0)).toBe(0);
  });
});
\`\`\`

La implementación *fake* más obvia que permite que el test pase es hacer que la función fibonacci devuelva 0 como una constante:

\`\`\`javascript
function fibonacci(n) {
  return  0;
}
\`\`\`

Puedes acceder al ejemplo interactivo [desde aquí.](https://repl.it/@SoftwareCrafter/TDD-Fibonnacci)

Una vez que tenemos el primer test pasando, la idea es transformar gradualmente la constante en una expresión. Veámoslo en el ejemplo, para ello primero debemos crear un test para el siguiente caso obvio, n = 1;

\`\`\`javascript

it('return one if receive one', () => {
  expect(fibonacci(1)).toBe(1);
});
\`\`\`


Ya tenemos el siguiente test fallando. El siguiente paso obvio es escribir una pequeña expresión con un condicional para una entrada con n = 0 devuelva 0 y para n = 1 devuelva 1:

\`\`\`javascript
function fibonacci(n) {
  if(n ==0)
    return  0;
  else
   return  1;
}
\`\`\`


Puedes acceder al ejemplo interactivo [desde aquí.](https://repl.it/@SoftwareCrafter/TDD-Fibonnacci-1)

Como puedes observar, la técnica de la implementación falsa nos ayuda a progresar poco a poco. Principalmente tienes dos ventajas inherentes, la primera es a nivel psicológico, ya que se hace más llevadero tener algunos test en verde, en vez de en rojo, que nos permitan ir dando pasos pequeños hacia la solución. La segunda tiene que ver con el control del alcance, ya que esta práctica nos permite mantener el foco en el problema real, evitando caer en optimizaciones prematuras.

### Triangular

Triangular, o la técnica de la triangulación, es el paso natural que sigue a la técnica de la implementación falsa. Es más, en la mayoría de los contextos, forma parte de la triangulación, basándose en lo siguiente:

1. Escoger el caso más simple que debe resolver el algoritmo.
2. Aplicar *Red-Green-Refactor*.
3. Repetir los pasos anteriores cubriendo las diferentes casuísticas.

Para comprender cómo funciona la triangulación, vamos a continuar desarrollando el ejemplo de Fibonacci, el cual, en parte, ya hemos empezado a triangular. El siguiente caso que podríamos cubrir es para n = 2.

\`\`\`javascript

it('return one if receive two’, () => {
  expect(fibonacci(2)).toBe(1);
});
\`\`\`


Puedes acceder al ejemplo interactivo [desde aqui.](https://repl.it/@SoftwareCrafter/TDD-Fibonnacci-2)

En esta ocasión el test pasa, por lo tanto, nuestro algoritmo también funciona para n = 2. El siguiente paso sería comprobar qué ocurre para n = 3.

\`\`\`javascript
it('returns two if receive three', () => {
  expect(fibonacci(3)).toBe(2);
});
\`\`\`


Como suponíamos, el test falla. Este paso nos ayudará a aproximarnos a la implementación de una solución más genérica. Ya que podríamos crear una implementación falsa para n = 3 y añadir otro condicional que devuelva 1 para n = 1 y n = 2.

\`\`\`javascript
function fibonacci(n) {
  if(n == 0)
    return  0;
  if(n == 1 || n == 2)
    return  1;
  else
    return  2; 
}
\`\`\`

Puedes ver el ejemplo interactivo [desde aquí](https://repl.it/@SoftwareCrafter/TDD-Fibonnacci-3).

Ahora que tenemos los test pasando, vamos a comprobar qué sucede para n = 4:

\`\`\`javascript
it('returns three if receive four', () => {
  expect(fibonacci(4)).toBe(3);
});
\`\`\`

Al llegar a este punto, ya te habrás dado cuenta de que sería más fácil escribir la implementación obvia que seguir haciendo ramas de decisión:

\`\`\`javascript
function fibonacci(n) {
  if(n == 0)
    return 0;
  
  if(n == 1 || n == 2)
    return 1;
  
  else
    return fibonacci(n - 1) + fibonacci(n - 2);
}
\`\`\`

En este paso, nuestro algoritmo funciona para cualquier valor de n, aunque aún podemos refactorizarlo para eliminar duplicidades y darle un aspecto más funcional:

\`\`\`javascript
function fibonacci(n) {
  const partialFibonacci = (n) => 
    n == 1
      ? 1
      : fibonacci(n - 1) + fibonacci(n - 2)

  return n == 0
    ? 0
    : partialFibonacci(n)
}
\`\`\`

Puedes acceder al ejemplo interactivo [desde aquí](https://repl.it/@SoftwareCrafter/TDD-Fibonnacci-4).

Con este último paso hemos resuelto el algoritmo de Fibonacci aplicando un enfoque funcional y utilizando la triangulación. Quizás en un hipotético siguiente paso deberíamos eliminar los test para n=3, n=4 y n=5, ya que en este punto no aportan demasiado valor, y crear un test que compruebe el algoritmo generando un número aleatorio mayor que 2 cada vez que se ejecuta.

Como puedes observar, la triangulación es una técnica muy conservadora para aplicar TDD, su uso tiene sentido cuando no tenemos clara la implementación obvia de la solución.

### Implementación obvia

Cuando la solución parece muy sencilla, lo ideal es escribir la implementación obvia en las primeras iteraciones del ciclo *Red-Green-Refactor*.

La problemática con esto surge cuando nos precipitamos, creyendo que se trata de un problema sencillo, cuando en realidad no lo es, porque tiene, por poner un ejemplo, algún caso *edge* sobre el que no habíamos reflexionado.

## Limitaciones del TDD


Por muchos beneficios inherentes que tenga (o que nos prometan), la técnica del TDD no debe entenderse como una religión ni como una fórmula mágica que vale para todo. Seguir TDD a rajatabla y en todos los contextos no garantiza que tu código vaya a ser más tolerante al cambio, robusto o seguro, ni siquiera te asegura que vayas a ser más productivo a la hora de diseñar *software*.

Desde mi punto de vista, aplicar TDD no encaja bien en todos los contextos. Por ejemplo, si existe una implementación obvia para un caso de uso, directamente la escribo y luego hago las pruebas. En el caso de estar trabajando en el *frontend* tampoco me planteo hacer TDD para diseñar componentes de la *UI*. Incluso es discutible si se deberían hacer test unitarios para probar elementos de la *UI*, desarrolladores de la talla de Ward Cunningham han comentado repetidas veces que no conviene hacer test automatizados sobre esta, ya que es muy cambiante y los test quedan desactualizados con demasiada frecuencia.

Mi consejo es que pruebes, trates de aplicarlo en tu día a día durante una temporada y luego decidas por ti mismo. 

Recuerda que esta entrada es un extracto de la sección de testing y TDD de nuestro libro [Clean Code, SOLID y Testing aplicado a JavaScript](https://softwarecrafters.io/ebook-cleancode-javascript). Si te ha gustado, valora y comparte en tus redes sociales. No dudes en comentar dudas, aportes o sugerencias. ¡Estaré encantado de responder!",
    "slug": "tdd-test-driven-development",
    "tags": [
      "javascript",
    ],
    "title": "TDD (Test Driven Development). Desarrollo dirigido por pruebas",
    "userPicture": "",
    "username": "Miguel A. Gómez",
  },
  {
    "category": "css",
    "cover": "https://swcrafters.fra1.digitaloceanspaces.com/Categories/css_category.png",
    "date": "",
    "description": "¡Me encanta CSS! Quien me conoce lo sabe, seguro que se notará en este artículo, y estoy orgulloso de ello. No pienso entrar en la guerra de si es un lenguaje de programación o no",
    "id": "css-craftsmanship",
    "markdownBody": "**¡Me encanta CSS!**. Quien me conoce lo sabe, seguro que se notará en este artículo, y estoy orgulloso de ello. No pienso entrar en la guerra de si es un lenguaje de programación o no. Para mí es un lenguaje de estilos y "ATENCIÓN SPOILER" **CSS es parte de la Web**. Es por ello que me sorprende la gran cantidad de personas que se definen como Frontends o FullStack pero dicen: "Ah! no, yo CSS no lo toco, eso no es programar".

Esa frase da para otro artículo, pero no quiero desviarme del objetivo de este, hablar de CSS para Crafters. Sí, me permito añadir la palabra crafters (artesano/a) junto a CSS. Y espero que al final del artículo consiga convencerte de que realmente podemos añadir artesanía a cualquier cosa que queramos trabajar de forma cuidadosa.

## ¿Qué es el CSS para Crafters?

### CSS

Hojas de Estilo en Cascada (del inglés Cascading Style Sheets) o CSS es el lenguaje de estilos utilizado para describir la presentación de documentos HTML o XML _(incluyendo varios languages basados en XML como SVG, MathML o XHTML)_. CSS describe como debe ser renderizado el elemento estructurado en la pantalla, en papel, en el habla o en otros medios. - [MDN web docs](https://developer.mozilla.org/es/docs/Web/CSS)

### Artesania de software

Artesanía se refiere tanto al trabajo de la persona artesana (crafter), como al objeto o producto obtenido en el que cada pieza es distinta a las demás. - [Wikipedia](https://es.wikipedia.org/wiki/Artesan%C3%ADa)

Pero en nuestro contexto vamos a hacer referencia a la Artesanía de Software según la definición del manifiesto de la [Artesanía de Software](http://manifesto.softwarecraftsmanship.org/#/es).

Veamos una lista de las cosas a tener en cuenta y herramientas que tenemos disponibles para ser auténticas/os artesanas/os del CSS.

- [CSS Styleguides](#css-styleguides)
- [CSS Naming](#css-naming)
- [CSS Architecture](#css-architecture)
- [CSS Testing](#css-testing)
- [CSS Frameworks](#css-frameworks)
- [CSS Knowledges](#css-knowledges)
- [CSS for Developers](#css-for-developers)
- [CSS Tools](#css-tools)
- [CSS Audits](#css-audits)
- [CSS Refactor](#css-refactor)
- [CSS Books](#css-books)
- [Conclusiones](#conclusiones)

## CSS Styleguides

Como en cualquier otro lenguaje de programación, existen guías de estilos. Tiene todo el sentido, ya que una guía de estilo no es más que una convención para escribir código legible, mantenible y escalable por uno o varios equipos.

Hay varias guías de estilos en CSS, y todas ellas propuestas por gente muy influyente en el desarrollo de la web.

- [Idiomatic CSS](https://github.com/necolas/idiomatic-css) _(Nicolas Gallagher)_
- [CSS Guidelines](https://cssguidelin.es/) _(Harry Roberts)_
- [Code Guide](https://codeguide.co/) _(Mark Otto)_
- [Primer](https://github.com/primer) _(GitHub)_
- [Airbnb CSS](https://github.com/airbnb/css) _(Airbnb Engineers)_
- [Sass Guidelines](https://sass-guidelin.es/) _(Hugo Giraudel)_

> Un ejemplo de sintaxis

\`\`\`css
/* Bad CSS */
.selector, .selector-secondary, .selector[type=text] {
  padding:15px;
  margin:0px 0px 15px;
  background-color:rgba(0, 0, 0, 0.5);
  box-shadow:0px 1px 2px #CCC,inset 0 1px 0 #FFFFFF
}

/* Good CSS */
.selector,
.selector-secondary,
.selector[type="text"] {
  padding: 15px;
  margin-bottom: 15px;
  background-color: rgba(0,0,0,.5);
  box-shadow: 0 1px 2px #ccc, inset 0 1px 0 #fff;
}
\`\`\`

No hay una mejor que otra. Como he comentado antes son convenciones, reglas a seguir por las personas que forman parte del equipo. Por lo que nos tenemos que sentir cómodas, ser ágiles y pracmáticas. He trabajado en varios equipos, y proyectos, he utilizado casi todas ellas. Es una decisión de equipo, pero eso sí, una vez hemos decidido una (ya sea una de ellas o una mezcla de varias) debemos ser consistentes y aplicarla en nuestro desarrollo.

Hoy en día es una tarea muy simple, ya que podemos configurar el linter para que al guardar los cambios nos "reformatee" el código según las reglas que hayamos decidido seguir. Aquí encontraréis las que estamos utilizando en [SUI Components](https://github.com/SUI-Components/sui/blob/master/packages/sui-lint/stylelint.config.js), utilizando Sass como preprocesador.

## CSS Naming {#css-naming}

En CSS no nos podemos librar de uno de [los dos grandes problemas en las Ciencias de la Computación](https://martinfowler.com/bliki/TwoHardThings.html), nombrar cosas. Si llevas un tiempo en el desarrollo seguro que te has llevado más de una sorpresa con el nombrado de variable, funciones o clases.

A la hora de desarrollar en las hojas de estilo tenemos el mismo problema, tanto para el nombrado de selectores de clases, las [custom properties](https://developer.mozilla.org/es/docs/Web/CSS/Using_CSS_custom_properties), como las variables, funciones o mixins de los preprocesadoes, que nos ofrecen una sintaxis de programación.

Como solución a estos problemas aparecen una serie de convenciones para, como en el punto anterior, conseguir un código más legible, mantenible y escalable. Vamos a ver algunas de ellas (algunas muy conocidas y otras no tanto)

- [OOCSS](https://github.com/stubbornella/oocss/wiki) _(Nicole Sullivan)_
- [SMACSS](http://smacss.com/) _(Jonathan Snook)_
- [BEM](https://en.bem.info/) _(Yandex)_
- [BEMIT](https://csswizardry.com/2015/08/bemit-taking-the-bem-naming-convention-a-step-further/) _(Harry Roberts)_
- [SUIT CSS](https://github.com/suitcss/suit/blob/master/doc/naming-conventions.md) _(Nicolas Gallagher)_
- [Modular CSS naming conventions](http://thesassway.com/advanced/modular-css-naming-conventions) _(The Sass Way)_
- [NCSS](https://ncss.io/) _(Henry Ruhs)_

La primera en ver la luz (2009) fue OOCSS de [Nicole Sullivan](https://twitter.com/stubbornella), donde Nicole ofrecía una nomenclatura orientada a objeto, extendiendo las clases.

> Un ejemplo de la propuesta de Nicole

\`\`\`css
.media {
  @extend %baseSpacing;
  @include clearfix-me(micro);
  > .mediaImg {
    float: left;
    margin-right: 10px;
    > img {
      display: block;
    }
  }
  > .mediaImgExt {
    float: right;
    margin-left: 10px;
    margin-right: 0;
  }
  > .mediaBody {
    @include clearfix-me(facebook);
  }
}
\`\`\`

Pero la más popular ha sido [BEM](https://en.bem.info/methodology/naming-convention/) (Block Element Modifier) del equipo de desarrollo de [Yandex](https://yandex.com/) _(la versión Rusa de Google)_. La popularidad que ha ganado BEM, en mi opinión, se debe a la simplicidad de la solución y a la gran documentación disponible desde el principio. Una de las cosas que supieron hacer es reaccionar a las peticiones de la comunidad y adaptar las ["Naming rules"](https://en.bem.info/methodology/naming-convention/#naming-rules) a unas ["Alternative naming schemes"](https://en.bem.info/methodology/naming-convention/#alternative-naming-schemes).

Personalmente he utilizado BEM en más de un proyecto y en cuanto lo hemos utilizado en un equipo, hemos llegado a hacer alguna modificación para sentirnos cómodos. Recordad que son convenciones, las podemos adaptar a nuestras necesidades.

> Un ejemplo de implementación de BEM

\`\`\`html
<ul class="menu">
  <li class="menu__item">...</li>
  <li class="menu__item">...</li>
  <li class="menu__item menu__item_size_m">...</li>
</ul>
\`\`\`

\`\`\`css
/* Block */
.menu { ... }

/* Element */
.menu__item { ... }

/* Modifier */
.menu__item_size_m { ... }
\`\`\`

En [SUI Components](https://github.com/SUI-Components/sui-components) y los productos de [Adevinta Spain](https://www.adevinta.com/es/spain/) estamos utilizando [SUIT CSS](https://github.com/suitcss/suit/blob/master/doc/naming-conventions.md) de [Nicolas Gallagher](https://twitter.com/necolas). Llegamos a la conclusión de utilizar esta convención porque tiene un enfoque orientado a componente y creemos que ganamos en legibilidad. Cosa que es de agradecer en proyectos de gran tamaño y con un equipo de gente grande.

> Ejemplo de implementación de SUIT CSS

\`\`\`html
<div class="sui-AtomCard">
  <div class="sui-AtomCard-media"> ... </div>
  <div class="sui-AtomCard-info"> ... </div>
</div>
\`\`\`

\`\`\`css
/* ComponentName */
.sui-AtomCard {
  /* Descendent Name */
  &-media { ... }
  &-info { ... }

  /* Modifier Name */
  &--vertical { ... }
  &--responsive { ... }

  /* State Of Component */
  &.is-highlight { ... }
}
\`\`\`

Como se puede apreciar, hemos optado por añadir un prefijo, eso nos ayuda a identificar el scope del componente. En esta captura del HTML de la web de [Coches.net](https://www.coches.net/), podemos ver componentes de Motor \`mt\` dentro de componentes SUI \`sui\`.

![Componentes de Motor dentro de componentes SUI](https://user-images.githubusercontent.com/1307927/95793455-e8efb600-0ce5-11eb-817b-6a174b5c7dc0.png)

Como podéis ver hay varias convenciones, igual que en las Styleguides, no hay ninguna mejor que otra, simplemente hay que decidir usar una convención. En nuestro caso, tuvimos varias reuniones _(hace ya unos años)_ frontends de todos los productos, para conseguir alinearnos y llegar a una convención sólida, y lo más importante, cómoda para todas las personas.

## CSS Architecture

¿Cómo?, ¿arquitectura en CSS?, así es. A mucha gente le sorprende escuchar hablar de arquitectura en CSS, pero en nuestro contexto, arquitectura se refiere a cómo están organizados los recursos, conectadas las dependencias entre ellos, la comunicación, incluso incluimos bajo el mismo paraguas la escalabilidad. Y todos esos temas se deben tener en cuenta a la hora de desarrollar la parte del código que nos ayuda a estilizar la información que consumirán las/os usuarias/os.

Aquí hay que tener algunas cosas en cuenta. Si optamos, o el proyecto en el que trabajamos, usa [CSS in JS](https://octuweb.com/css-in-js/), los estilos estarán incluidos dentro del componente JavaScript. En este caso la parte de arquitectura queda limitada a algunos estilos globales. Así que en nuestro caso vamos a enfocarlo desde el punto de vista que el CSS lo tenemos en otra capa de la aplicación.

De la misma manera que para las Styleguides y el Naming, gente referente en la comunidad frontend, han definido propuestas de cómo resolver el tema de la arquitectura CSS.

- [OOCSS](https://github.com/stubbornella/oocss/wiki) _(Nicole Sullivan)_
- [SMACSS](http://smacss.com/) _(Jonathan Snook)_
- [Atomic Design](https://bradfrost.com/blog/post/atomic-web-design/) _(Brad Frost)_
- [7-1 Pattern](https://sass-guidelin.es/#architecture) _(Hugo Giraudel)_
- [ITCSS](https://itcss.io/) _(Harry Roberts)_
- [haiticss](https://github.com/haiticss/haiticss) _(Dani Fornells)_

Aquí seguro que os llamará la atención que los dos primeros puntos se repiten. Eso es porque las propuestas de Nicole y Jonathan incluyen convención de nombres y de arquitectura.

SMACSS (Scalable and Modular Architecture CSS) de [Jonathan Snook](https://twitter.com/snookca) ganó popularidad, y gran parte de esa popularidad fue gracias a que Jonathan publicó un libro, el cual ahora puedes [descargar](http://smacss.com/) de forma gratuita.

Usé la propuesta de SMACSS en un par de proyectos, pero me dejé llevar por la tendencia seguida por mucha gente de utilizar el 7-1 Pattern, donde [Hugo Giraudel](https://twitter.com/hugogiraudel) proponía la siguiente estructura.

\`\`\`sh
base/
components/
layout/
pages/
themes/
abstracts/
vendors/
main.scss
\`\`\`

> 7 carpetas definiendo la estructura de carpetas y un solo punto de entrada, de ahí su nombre **7-1 Pattern**.

La propuesta de [Brad Frost](https://twitter.com/brad_frost) con **[Atomic Design](https://bradfrost.com/blog/post/atomic-web-design/)** es muy similar.

\`\`\`sh
base/
atom/
molecule/
organism/
template/
page/
style.scss
\`\`\`

Este es otro caso de éxito de una propuesta apoyada por un libro, una buena documentación, un montón de charlas e incontables artículos hablando sobre este enfoque de Diseño Atómico.

Esta es la arquitectura que estamos utilizando en [SUI Components](https://github.com/SUI-Components/sui-components/tree/master/components), la cual nos encaja por el mismo enfoque que se está haciendo desde el departamento de UX/UI.

No quiero dejar de comentar la propuesta de [Harry Roberts](https://twitter.com/csswizardry), ITCSS (Invert Triable CSS), ya que he hecho [algunas charlas](https://slides.com/joanleon/arquitectura-itcss) y un curso hablando de esta arquitectura. He de confesar que en cuanto la conocí, me gustó, y cometí el gran error _(luego me di cuenta)_ de quererlo aplicar en todos los proyectos. Incluso hice la propuesta de aplicarla en los productos de la empresa, pero no era la mejor opción. Un **cambio** de arquitectura sin necesidad, un proyecto grande con mucha gente a la que hacer una formación, cambiar el chip. Y como ya sabemos, las personas, por naturaleza son reacias al cambio. Así que no fué más allá de implementarlo en un par de proyectos en los que colaboré.

> La manera más rápida de entender el enfoque de ITCSS es con este gráfico

![ICSS](https://user-images.githubusercontent.com/1307927/95793441-e2f9d500-0ce5-11eb-949e-9cdc24275a22.png)

## CSS Functional _(Utility-first)_

Functional CSS _(en el título mantengo el patrón del resto 🤷🏽‍♂️)_, también conocido como Utily-first CSS, también lo podemos definir como una arquitectura CSS, pero lo he querido separar del resto por el enfoque tan controvertido y por la etiqueta de "anti-pattern" que rápidamente le fué otorgada por la comunidad frontend. He de confesar que yo estuve entre la comunidad que pensaba (mucha gente lo sigue pensando) que su planteamiento acopla la capa de estilos a la capa de presentación.

En mi opinión, creo que esto pasa continuamente, cuando hay alguien que plantea un nuevo enfoque por naturaleza rechazamos el cambio. Y más aún si ese cambio nos implica modificar la manera de cómo hacemos las cosas. Para poder formarnos una opinión tenemos que documentarnos, entender el motivo que ha llevado a que alguien plantee algo que a priori parece tan disruptivo. Eso es lo que hizo [Sarah Dayan](https://twitter.com/frontstuff_io) en su artículo [In Defense of Utility-First CSS](https://frontstuff.io/in-defense-of-utility-first-css), en él encontrarás frases como:

> “Favor composition over inheritance”. This piece of wisdom from Design Patterns, one of the most influential software engineering books, is the foundation of utility-first CSS. It also shares many principles with functional programming: immutability, composability, predictability, and avoidance of side-effects. The goal behind all those fancy terms is to write code that’s easier to maintain and to scale.

> BEM encourages you to use modifiers to handle component variations. This may seem smart at first, yet unfortunately leads up to other problems: you end up creating tons of modifiers you only use once for a specific use-case.

Tanto si te planteas utilizar Utility-first CSS como si no, te aconsejo leer el artículo de Sarah, ya que te abrirá la mente y te ayudará a poder argumentar los motivos de usarlo o no usarlo en tu próximo proyecto.

Si filtramos en GitHub por el _topic_ [#functional-css](https://github.com/topics/functional-css) podremos ver que hay una gran cantidad de proyectos. En el top 3 podemos encontrar los frameworks [tailwindcss](https://tailwindcss.com/), [Tachyons](https://tachyons.io/) y [Basscss](https://basscss.com/).

Es muy probable que te suenen los dos primeros, ambos disponen de una gran documentación y comunidad. A **Basscss** le tengo cierto aprecio porque [Brent Jackson](https://twitter.com/jxnblk) ya apostó por este enfoque con [Basscss-sass](https://github.com/basscss/basscss-sass) en el 2015.

Veamos un ejemplo de implementación de **tailwindcss**.

\`\`\`html
<div class="md:flex bg-white rounded-lg p-6">
  <img class="h-16 w-16 md:h-24 md:w-24 rounded-full mx-auto md:mx-0 md:mr-6" src="avatar.jpg">
  <div class="text-center md:text-left">
    <h2 class="text-lg">Erin Lindford</h2>
    <div class="text-purple-500">Product Engineer</div>
    <div class="text-gray-600">erinlindford@example.com</div>
    <div class="text-gray-600">(555) 765-4321</div>
  </div>
</div>
\`\`\`

> Este es el ejemplo de cómo, con el patrón composición, podemos encontrar en la home de su site.

Antes de juzgar la legibilidad, si eso es lo mismo que escribir estilos en línea **(que NO lo es)** u opinar sobre la escalabilidad que tiene un desarrollo así, por favor, echa un vistazo al artículo de Sarah.

## CSS Testing

Lo primero que debemos aclarar es que el Testing en CSS se aleja mucho del Testing que conocemos en los lenguajes de programación. Sí, lo sé, con los preprocesadores podemos hacer tests tal y como los conocemos, ya que nos ofrecen una sintaxis, un compilador con gestión de errores y con resultados predecibles. Por ejemplo, para Sass podemos utilizar [True](https://github.com/oddbird/true) un framework que nos permite implementar test unitarios en el código Sass de nuestros proyectos.

Otro punto, y quizás el más importante, es que debemos tener claro que el CSS NO se renderiza igual en todos los navegadores. Si no me crees, puedes entrar en esta web [Do websites need to look exactly the same in every browser?](http://dowebsitesneedtolookexactlythesameineverybrowser.com/) 😊.

> Tenía pensado añadir una imagen con los iconos de los navegadores, pero el primer error es pensar que no dejaré ninguno fuera. Hoy en día existen más navegadores de los que creemos, en [Cam I Use](https://caniuse.com/usage-table) podemos ver una lista de la cantidad de navegadores y versiones.

Seguro que llegado a este punto, puede que pienses que no tiene mucho sentido el testing en CSS, pero deja que te explique las opciones que tenemos disponibles desde el punto de vista de CSS y renderizado en el navegador, ya hemos visto que en los preprocesadores sí que tenemos opción de desarrollar tests unitarios.

### Manual Testing

Como desarrolladores, es complicado hacerse a la idea que a estas alturas debemos hacer testing manual. Ya no por la tarea en sí de tener que probar una nueva funcionalidad en diferentes navegadores y dispositivos, sino por el peligro a error en la revisión. Es una balanza complicada de equilibrar, por un lado tenemos el trabajo y el riesgo a errores, pero por el otro está el validar que nuestras/os usuarias/os no tendrán una mala experiencia al utilizar nuestra aplicación.

Es realmente sorprendente a la vez que esperanzador, ver que la propia W3C tiene test manuales para validar el funcionamiento esperado de las nuevas funcionalidades que poco a poco van adoptando los navegadores, lo podemos encontrar en las [Test suites for Web-platform specs](https://github.com/web-platform-tests/wpt) o incluso personas tan referentes en el mundo web como [Eric Meyer](https://twitter.com/meyerweb), donde podemos ver en su repositorio [css-tests](https://github.com/meyerweb/css-tests) una gran cantidad de tests.

Aun siendo una tarea tediosa, la validación manual, nos permite asegurarnos que podemos ver correctamente renderizado ese componente de una nueva funcionalidad. Eso sí, asumiendo que será imposible llegar a todos los dispositivos y de una manera actualizada.

### Automatic Testing

Existen varias herramientas para poder validar que no hemos roto nada al desplegar una nueva funcionalidad, cambio de copy o al eliminar un test A/B.

Posiblemente la herramienta de testing en el navegador sea [BrowserStack](https://www.browserstack.com/) que nos permite hacer integración con diferentes entornos de despliegue, automatización de frameworks, gestores de proyectos o herramientas de desarrollo, echa un vistazo a la [larga lista](https://www.browserstack.com/integrations). Es un servicio de pago, pero creo que muy asumible teniendo en cuenta el gran beneficio que nos aporta.

Hay más, como [Sauce Labs](https://saucelabs.com/) o [Browserling](https://www.browserling.com/) pero no los conozco.

El servicio que sí he utilizado y me parece una gran herramienta para validar e-mails es [Litmus](https://www.litmus.com/). Nos permite tener una previsualización de nuestra plantilla de mail en un montón de clientes de correo y en varias versiones.

### CSS Regression Testing

Otra opción que tenemos es basar nuestros test en **Visual Regression Testing**, hace un tiempo (2016) dí una charla en [Software Crafters Barcelona](http://slides.com/joanleon/css-regression-testing/) donde hablé de varias herramientas para ello.

En aquel momento la herramienta más completa (IMHO) era [PhantomCSS](https://github.com/HuddleEng/PhantomCSS), proyecto que ya está archivado. Actualmente la herramienta más completa para implementar un sistema de Visual Regression Testing con CLI es [Puppeteer](https://pptr.dev/).

El sistema de regresión visual consiste en guardar un snapshot, imagen en formato PNG, y comparar entre las imágenes los cambios a nivel de pixel.

![Visual Regression Testing](https://user-images.githubusercontent.com/1307927/95793464-ed1bd380-0ce5-11eb-9b8f-30bb59038656.jpg)

Este tipo de test tiene un alto porcentaje de falsos positivos, ya que como podemos ver en el ejemplo los cambios pueden ser intencionados, ya que estamos capitalizando el título de ese bloque.

Seguro que he conseguido desanimarte con todo esto de los test en CSS, pero no pasa nada, está bien darse cuenta que esto de CSS va más allá de convertir los diseños a colores hexadecimales.

Por suerte es un sector que va avanzando poco a poco. En el caso de que estés utilizando [Storybook](https://storybook.js.org/), existe un plugin llamado [chromatic](https://www.chromatic.com/) que te permitirá automatizar los tests de regresión visual a nivel de componente.

En la reciente [JamStackConf 2020](https://jamstackconf.com/), [Angie Jones](https://twitter.com/techgirl1908) dió una charla ["Adding Eyes to your Automation Framework"](https://www.youtube.com/watch?v=spyKZ-p3UgE&ab_channel=JamstackConf) hablando de [Eye](https://applitools.com/products-eyes/) un servicio que apoyándose en Inteligencia Artificial promete dar solución a todas las lagunas que nos hemos encontrado hasta ahora.

Así que creo que no tardaremos mucho en olvidar lo complicado que es validar que no se está rompiendo nada cuando hacemos cambios o añadimos CSS en nuestras nuevas funcionalidades.

## CSS Frameworks

Quiero empezar esta sección recomendando una gran charla de una amiga, [You might not need a CSS framework](https://www.youtube.com/watch?v=kED5eDjMfGM) de [Belén Albeza](https://www.belenalbeza.com/), donde nos habla de que no tenemos la necesidad de utilizar un framework CSS, luego daré mi opinión sobre este punto de vista.

Mi primer recuerdo de un framework CSS me lleva a [960 Grid System](https://960.gs/), he tenido la curiosidad de ver la fecha de inicio y he encontrado el [primer commit](https://github.com/nathansmith/960-Grid-System/commit/0d61cf12e44bacc100f25c08b8b1dcc00b39b0d3) _(Dec 20, 2009)_ en el repositorio, pero es de la versión 1.4. Hay personas que ya estábamos codeando antes del nacimiento de GitHub 😅.

### Objetivo de los frameworks CSS

Los frameworks CSS, como la mayoría de lenguajes y herramientas que utilizamos día a día, surgen de la necesidad de solucionar un problema puntual en un proyecto, sin un objetivo comercial. Simplemente para poder ser más ágiles a la hora de resolver el mismo problema en cada proyecto. Muchas personas ya teníamos nuestras "cajas de herramientas" sin saber que estábamos construyendo un framework, simplemente teníamos estructura y fragmentos de código que utilizamos en cada nuevo proyecto.

El nacimiento de los frameworks hizo mucho más fácil que la información se presentara con más coherencia, con más diseño. Eso los popularizó de forma rápida.

**EL FRAMEWORK CSS** es [Boostrap](https://getbootstrap.com/), durante mucho tiempo era fácil reconocer que una web estaba utilizando Bootstrap sin mirar el código fuente. La mejor baza del creador de Bootstrap [Mark Otto](https://twitter.com/mdo) fue **la documentación**. Una documentación donde cualquier persona solo tenía que incluir el archivo CSS en el proyecto y con un simple a la vez que poderoso \`Copy & Paste\` de la estructura HTML del "componente" necesario, teníamos funcionando una web en unas horas. Curiosamente se veía aparentemente igual en todos los navegadores.

Hay muchos, muchos frameworks CSS. Cada año aparecen varios artículos del estilo "XX Best CSS Frameworks in 20XX", un ejemplo de ello puede ser este [Best CSS Frameworks in 2020](https://dev.to/theme_selection/best-css-frameworks-in-2020-1jjh).

Hay frameworks que nos definen más el aspecto gráfico, como es el caso de [Materialize](https://materializecss.com/) basado en [Material](https://material.io/design) de Google, donde nos facilitan una interfaz, layout e interacciones pensadas para aplicaciones Android. [Bulma](https://bulma.io/) suele estar en el top 10 de las listas de frameworks CSS, su popularidad la ganó por ser uno de los frameworks que basó su layout en Flexbox. Y otro que también está en el top 5 o 3 (según la lista) es [tailwindcss](https://tailwindcss.com/), el cual tiene un enfoque de composición en el lado de HTML, como ya hemos visto en la sección de arquitectura.

> Hay muchos, y no es el objetivo de este artículo nombrarlos o analizarlos todos. Si te interesa profundizar en ellos, puedes echar un vistazo a este artículo [100+ Best CSS Frameworks For Responsive Design](https://cssauthor.com/css-frameworks/)

### Mi opinión sobre los frameworks CSS

Como he comentado, aparecen para resolver problemas o funciones concretas, así que no pueden resolver todos los casos. Un claro ejemplo de ello es [NES.css](https://nostalgic-css.github.io/NES.css/), un framework CSS que emula el estilo de una NES de 8bits, es genial, me encanta, lo podría usar como tema en un blog, la web de un juego pixelart, pero no lo veo como imagen de un producto o eCommerce. Pueden estar bien para un MVP, una landing con objetivos de SEO, un side project, un gestor de contenidos _(yo he usado bootstrap en dos proyectos de gestión)_. Pero creo que no es una buena opción para un producto digital. Los productos evolucionan, se tienen que adaptar a nuevas necesidades, nuevos dispositivos.

Personalmente he sido reacio a utilizar frameworks CSS por mi sensación de falta de control. Creo que se debe a que prefiero tener conocimiento de CSS que a conocer la API de un framework, donde además sé lo que hacen las propiedades CSS que se esconden detrás de una clase.

Durante un tiempo estuve leyendo muchos de esos frameworks, tenía una carpeta con los repositorios con los que me interesaba analizar. Incluso me creé un [alias](https://gist.github.com/nucliweb/c2163e31029255d068eb) para poder mantener todos los repositorios actualizados.

![Listado de Frameworks CSS](https://user-images.githubusercontent.com/1307927/95793467-f016c400-0ce5-11eb-8b8e-dea436999d98.png)

Muy friki sí, pero ahí estaba yo, analizando estructuras, nombres de clases, código, o cómo conseguía Bootstrap que un botón se viera igual en todos los navegadores (la magia está en el \`line-height\`). En algunos proyectos yo tenía que definir la arquitectura, naming y escalabilidad del código CSS. Y la verdad, quién soy yo frente a un montón de gente ingeniera que estaba ofreciendo soluciones globales a problemas concretos. Puede ser que en este momento estés pensando, vaya, Joan lo que hacía es copiar (o como un compañero diseñador decía: "creatividad asociativa") el código de los frameworks. No, deja que me explique.

He hecho varios cursos en formaciones online, y me di cuenta que siempre repetía la misma frase "Me gusta tener el control". Y hablo de un control de saber qué y porqué está renderizando eso el navegador. Tener referencias para aprender es básico, aprendemos así cualquier cosa que estudiemos.

Así que mi opinión es que debemos tener el conocimiento suficiente como para poder crear nuestro propio framework. Esto nos permitirá valorar si uno de los frameworks disponible nos puede ayudar (siempre hay que ser pragmático), si con algunas variaciones de uno de ellos (que hoy en día muchos ofrecen) nos vale o si tenemos que crear nuestro propio framework para poder tener el control total del producto que estamos creando.

## CSS Knowledges

Tener conocimientos de CSS es básico. CSS forma parte de la web [#cssIsPartOfTheWeb](https://twitter.com/hashtag/cssIsPartOfTheWeb).

No quiero ganarme enemigas/os con lo que voy a decir, aunque no me importa si con ello consigo dar visibilidad de lo importante que es tener conocimiento CSS: **"Si CSS es tan fácil, ¿por qué hay tanta gente que no lo conoce?**.

Existe un comité, el [CSS Working Group](https://wiki.csswg.org/) con un [grupo de gente](https://www.w3.org/Style/CSS/members.en.html) muy top que forman parte de muchas compañías punteras en el desarrollo de software. Una de las personas más influyentes en las especificaciones de CSS, [fantasai](https://twitter.com/fantasai), escribió el artículo [about:csswg](http://fantasai.inkedblade.net/weblog/2011/inside-csswg/) explicando cómo funciona el **CSSWG**.

IMHO, el primer sitio donde tenemos que mirar para aprender CSS es en [MDN](https://www.w3.org/Style/CSS/), ya que mantiene una estructura de la información mucho más fácil de seguir. El siguiente nivel es leer la documentación, drafts y discusiones que mantienen en [CSSWG](https://www.w3.org/Style/CSS/) sobre los bugs, revisiones y futuras funcionalidades sobre CSS.

Hay algunos recursos que nos pueden ayudar a estar al día en las nuevas funcionalidades soportadas, las nuevas por venir o las que ya están ¨deprecadas¨. La mayoría las podemos encontrar en esta magnífica recopilación [What’s happening in CSS?](https://rachelandrew.co.uk/archives/2017/05/01/whats-happening-in-css/) de [Rachel Andrew](https://twitter.com/rachelandrew).

Me parecen geniales los enlaces a los "\\[Browser\\] Platform Status", y otra fuente interesante de información son [las noticias de Can I Use](https://caniuse.com/#info_news) donde podemos ver las novedades que se añaden en los diferentes navegadores.

Un recurso que no me canso de recomendar, y yo mismo leer de vez en cuando, es [Cómo funcionan los navegadores: lo que hay detrás de los navegadores web actuales](https://www.html5rocks.com/es/tutorials/internals/howbrowserswork/) donde podremos aprender cómo funciona de forma interna el navegador. Está escrito en 2011, pero en su mayoría es totalmente válido para los navegadores actuales. Si quieres profundizar más en cómo funciona internamente el renderizador del navegador, también puedes leer [Inside a super fast CSS engine: Quantum CSS](https://hacks.mozilla.org/2017/08/inside-a-super-fast-css-engine-quantum-css-aka-stylo/) de [Lin Clark](https://twitter.com/linclark), donde nos explica de forma muy detallada el funcionamiento del motor de estilos con unas impresionantes ilustraciones.

## CSS for Engineers

Los preprocesadores han sido una gran herramienta para acercar a la gente que necesita trabajar con un lenguaje de programación. Lenguajes como [Sass](https://sass-lang.com/) nos da una sintaxis, un compilador, una gestión de errores, la opción de añadir tests unitarios (como hemos visto más arriba).

Otro gran preprocesador es [PostCSS](https://postcss.org/) el cual nos permite utilizar JavaScript para extender las posibilidades de CSS. Sobre PostCSS encontraréis un post que escribí hace un tiempo en este mismo blog [PostCSS Preset Env, el Babel de CSS](https://softwarecrafters.io/css/postcss-preset-env-babel-css).

## CSS Tools

Existen muchas herramientas para facilitarnos trabajar con CSS, si no me equivoco, la primera herramienta para CSS fue el [validador de CSS](https://jigsaw.w3.org/css-validator/) de la propia W3C.

### Styleguide Generators

- [kss-node](https://github.com/kss-node/kss-node) este lo hemos usado en el framework CSS [rubik](https://github.com/InfoJobs/rubik) en InfoJobs.
- [postcss-style-guide](https://github.com/morishitter/postcss-style-guide) este también lo he utilizado en un proyecto, para generar la guía de estilos de una web.
- [CSS Parsing](https://github.com/davidhund/styleguide-generators#css-parsing-css-source) aquí encontrarás una lista de varios de ellos, probé StyleDocco, pero me gustó más kss-node.

### Linters

- [CSS Lint](http://csslint.net/) el primer linter de CSS que recuerdo, muy útil en su momento, pero al tratarse de un servicio online donde tienes que "pastear" el CSS que quieres analizar en un TextArea, es inviable integrarlo en cualquier entorno de desarrollo.
- [stylelint](https://stylelint.io/) es una gran herramienta para localizar errores en nuestro código, es lo más cercano a un gestor de errores cuando compilamos en un lenguaje. Lo podemos integrar en muchos editores y entornos de desarrollo, permitiendo cambiar a la sintaxis que tengamos acordada en el fichero de configuración en el momento de guardar nuestros cambios.

### Critical-path

Estas herramientas están relacionadas con la web performance, por lo que afectan directamente a la experiencia de usuaria/o.

- [Penthouse](https://github.com/pocketjoso/penthouse) de Jonas Ohlsson
- [Critical](https://github.com/addyosmani/critical) de Addy Osmani
- [CriticalCSS](https://github.com/filamentgroup/criticalcss) de FilamentGroup

### Developer Tools

Las developer tools de los navegadores están repletas de funcionalidades para facilitarnos el desarrollo y depuración del CSS de nuestros proyectos.

Enumerar todas ellas darían para un artículo dedicado (uno de Chrome y otro de Firefox), así que os dejo los enlaces a la fuente y si tenéis alguna duda me podéis consultar.

- [Chrome DevTools](https://developers.google.com/web/tools/chrome-devtools?hl=es)
- [Firefox Developer Tools](https://developer.mozilla.org/es/docs/Tools)

## CSS Audits

Las herramientas que voy a comentar aquí podrían estar perfectamente en la sección de CSS Tools, pero les he querido dar una mayor importancia debido a lo realmente útiles que nos pueden llegar a ser en muchas ocasiones y para mantener las buenas prácticas en nuestro CSS.

### CSS Stats

[CSS Stats](https://cssstats.com/) es un servicio online gratuito y Open Source que analiza el CSS de una web o url específica y genera un informe muy detallado. Peso, número de reglas, de selectores, pseudo elementos, colores, fuentes, etc...

[![SoftwareCrafters.io CSS Stats Report](https://user-images.githubusercontent.com/1307927/95793471-f3aa4b00-0ce5-11eb-9f86-84163044b32f.png)](https://cssstats.com/stats/?url=https%3A%2F%2Fsoftwarecrafters.io)

> Aquí podemos ver un ejemplo del CSS de este blog. A primera vista podemos ver que el tamaño del CSS es bastante superior al de Bootstrap 🙈.

Uno de los informes que nos facilita es el de la [especificidad](https://developer.mozilla.org/es/docs/Web/CSS/Especificidad), un tema que puede traernos de cabeza si no lo tenemos interiorizado.

![SoftwareCrafters.io CSS Specificity Report](https://user-images.githubusercontent.com/1307927/95793484-f9079580-0ce5-11eb-8614-770c46a03bad.png)

### Project Wallance

[Project Wallance](https://www.projectwallace.com) es otro proyecto para auditar nuestro código CSS. Es un servicio de pago, que permite tener un historial de los informes para poder compararlos.

![joanleon.dev Project Wallace Dashboard](https://user-images.githubusercontent.com/1307927/95793476-f60ca500-0ce5-11eb-84e3-e114519a1c64.png)

La versión gratuita permite auditar un proyecto, pero sin poder integrarlo con sistemas de integración continua.

## CSS Refactor

En cualquier lenguaje de programación en el momento que guardamos un archivo estamos generando deuda técnica. En el desarrollo CSS no es distinto. Conforme avanza el proyecto tendremos que refactorizar, así como aplicar buenas prácticas en el desarrollo nos ayudará en ese proceso de refactorizar el código, de mejorarlo.

Tenemos herramientas como [autoprefixer](https://autoprefixer.github.io/) que basándose en [Browserslist](https://github.com/browserslist/browserslist) añade los prefijos necesarios a las propiedades CSS para mantener la retrocompatibilidad de los navegadores que estemos soportando en nuestro proyecto.

\`\`\`css
/* Input ------- */
.example {
    display: grid;
    transition: all .5s;
    user-select: none;
    background: linear-gradient(to bottom, white, black);
}

/* Output -------- */
/*
* Prefixed by https://autoprefixer.github.io
* PostCSS: v7.0.29,
* Autoprefixer: v9.7.6
* Browsers: last 4 version
*/

.example {
    display: -ms-grid;
    display: grid;
    -webkit-transition: all .5s;
    -o-transition: all .5s;
    transition: all .5s;
    -webkit-user-select: none;
       -moz-user-select: none;
        -ms-user-select: none;
            user-select: none;
    background: -webkit-gradient(linear, left top, left bottom, from(white), to(black));
    background: -o-linear-gradient(top, white, black);
    background: linear-gradient(to bottom, white, black);
}
\`\`\`

Aquí estamos definiendo que queremos compilar un código compatible con las últimas 4 versiones de todos los navegadores. En un producto, el cual suponemos que tendrá un vida larga, en 4 años es muy probable que esos prefijos no tengan sentido, hay que eliminarlos, hay que refactorizar.

Si tenemos un flujo de trabajo donde ese proceso esté automatizado, solo tendremos que cambiar la configuración del fichero \`.browserslistrc\` o actualizar un \`@mixin\` de Sass, será una tarea fácil, pero sino, nos tocará hacer un refactor considerable.

Existe un libro titulado **CSS Refactoring**, pero es más un libro de buenas prácticas para no generar legacy o facilitar el refactor que casos de uso de refactor como tal, hablo de ello en la sección de los libros.

Tal y como yo tengo entendido el refactor hay dos posibles escenarios:

- Refactor de un código CSS por un cambio de diseño. Esto puede llevar mucho tiempo y muchos test para validar que no estamos rompiendo nada.
- Refactorizar el código conforme vemos mejoras. Cada día aprendemos algo, un nuevo truco, una nueva propiedad CSS que ya es compatible, corregir valores como \`margin: 0px\`. Como crafters queremos hacer bien las cosas, que nuestro yo del futuro esté orgulloso de nuestro trabajo, pues mejoremos todo lo que podamos o sepamos en ese momento, eso sí, sin presión...no lo sabemos todo, refactorizamos porque hemos aprendido a hacer mejor las cosas.

## CSS Books

Hay bastantes libros sobre CSS, muchos de ellos son genéricos de desarrollo web y dedican unos capítulos a CSS.

Como es un tema que me interesa mantener actualizado, os dejo un enlace a un artículo de mi blog donde tengo, e iré añadiendo, reseñas de los que he leido 👉🏼 [Libros CSS](https://joanleon.dev/libros-css).

## Conclusiones

Aprender CSS es básico para poder desarrollar buenos productos web. CSS no es solo poner colores y montar el grid para que todo encaje. Hay muchas cosas a tener en cuenta como habrás podido ver, y eso que no hemos entrado en temas de accesibilidad o performance. Hay gente muy profesional desarrollando las funcionalidades en lenguajes como C++ para que el motor del navegador acabe convirtiendo en pixeles, en contenido para la usuaria/o.

Hay muchas cosas por aprender, como en cualquier lenguaje, como en cualquier disciplina, hay que aprender, entender, interiorizar y entrenar (aka katas) para mejorar.

Soy Frontend y trabajo con los 3 lenguajes disponibles HTML, CSS y JS para aportar valor en mis soluciones, para aportar valor al producto, para aportar valor a las usuarias/os.

CSS forma parte de la web [#cssIsPartOfTheWeb](https://twitter.com/hashtag/cssIsPartOfTheWeb).",
    "slug": "css-craftsmanship",
    "tags": [
      "css",
    ],
    "title": "CSS para Crafters",
    "userPicture": "",
    "username": "Joan León",
  },
  {
    "category": "javascript",
    "cover": "https://swcrafters.fra1.cdn.digitaloceanspaces.com/Categories/RxJS_category.png",
    "date": "",
    "description": "RxJS es una librería que nos permite programar con un estilo funcional reactivo. La programación reactiva es un concepto relativamente nuevo ",
    "id": "introduccion-programacion-reactiva-rxjs",
    "markdownBody": "> **Esto trata sobre manejar con buen gusto los efectos secundarios de las operaciones asíncronas -- Erik Meijer sobre Rx**

La programación reactiva es un concepto relativamente nuevo que está revolucionando el mundo del _software_. Hoy en día, cualquier sistema serio involucra muchos subsistemas asíncronos que necesitan ser coordinados eficientemente, algo tremendamente complicado con las técnicas de programación clásicas.

En este artículo trataré de introducir la filosofía de programación reactiva y las posibilidades que nos brinda JavaScript, junto a RxJS, en este aspecto. Repasaremos algunos conceptos clave para entender la programación reactiva y veremos algunos ejemplos pragmáticos sobre cómo usar RxJS.

## Manejando la asincronía con JavaScript 

En los últimos años, JavaScript se ha convertido en uno de los lenguajes más utilizados del mundo, se encuentra en infraestructuras críticas de las empresas más importantes, en las cuales un correcto manejo de la asincronía se vuelve esencial. 

Antes de profundizar en conceptos relacionados con la reactividad, veamos un pequeño resumen sobre los **_callbacks_** y los **_promises_**, dos de los mecanismos clásicos para manejar la asincronía en JavaScript.

### _Callbacks_

Los _callbacks_ son la forma más antigua de gestionar la asincronía. Como ya sabréis, un _callback_ no es más que una función que recibe como argumento otra función y la ejecuta. En otras palabras, una función "a" se usa como argumento de otra función "b". Cuando se llama a "b", esta ejecuta "a". 

\`\`\`
function b(callback){
    //do something
    callback()
}

function a(){
     console.log('hello');
}

\`\`\`

Los _callbacks_ son muy sencillos de entender y es por ello que son la forma más extendida de manejar la asincronía en JavaScript. No obstante, los _callbacks_ tienen varios inconvenientes, como pueden ser la gestión de errores o el aumento de la complejidad a la hora de manejar la concurrencia; por no hablar del temido _callback hell._

![callback-hell](https://res.cloudinary.com/software-crafters/image/upload/v1546943598/posts/introduccion-programacion-reactiva-rxjs/callback-hell.png) 

### _Promises_

Las _promises_ o promesas son un patrón que nos ayuda a realizar operaciones asíncronas sin muchos de los inconvenientes de los _callbacks_. Una promesa representa un valor que puede estar disponible ahora, en el futuro o nunca. Vinieron a salvarnos del tan temido _callback hell_. Generalmente hacen que los programas sean más claros al mantener un estilo de código síncrono, reduciendo la necesidad de anidar bloques y simplificando el manejo del estado.

Las promesas pueden encontrarse en 3 estados diferentes: 

* **_Pending_**: Estado inicial
* **_Fulfilled_**: Representa una operación satisfactoria
* **_Rejected_**: Representa una operación fallida

Veamos un ejemplo de cómo se crean y cómo se consumen:

\`\`\`
//Creando la promesa
const requestPosts = (url) =>
	new Promise((resolve, reject) => {
		const req = new XMLHttpRequest();
		req.open('GET', url);

		req.onload = () =>
			(req.status == 200)
				? resolve((req.response)
				: reject(req.status);

		req.send();
	})

//Consumiendo la promesa
const url = 'https://jsonplaceholder.typicode.com/posts'

requestPosts(url)
	.then(r =>
    	console.log(JSON.parse(r))
  	)
  	.catch((e) =>
    	console.log(\`Error: \${e}\`)
  	);

\`\`\`

Desafortunadamente, las promesas no son la panacea. Representan una mejora con respecto a los _callbacks_, pero tienen una deficiencia importante: solo producen un valor único. Esto es un factor limitante a la hora de manejar eventos recurrentes, como clics del _mouse_ o flujos de datos provenientes del servidor, ya que tendríamos que preocuparnos de cada evento por separado en lugar de controlar el flujo de eventos tal como viene dado. 

### _Async / Await_

Desde la versión ES8 de JavaScript, ya tenemos disponible el patrón **_async/await_** **.** Esta característica heredada de otros lenguajes como c# nos permite resolver promesas escribiendo código con un estilo síncrono, es decir, añade azúcar sintáctico a las promesas.

Para usar **_async/await_** debemos declarar una función con el modificador _async_. Esto nos **permite añadir el modificador** **_await_** **delante de la expresión asíncrona en dicha función, deteniendo la ejecución hasta que se resuelva la expresión.**

La promesa del ejemplo anterior la podríamos consumir así:

\`\`\`
async function main(){
    const url = 'https://jsonplaceholder.typicode.com/posts'
    const response = await requestPosts(url)

    console.log(response)
}

\`\`\`

_A priori_, queda un código mucho más elegante, además de resolver el problema de la anidación de promesas. El problema viene con el tratamiento de los errores, y es que debemos “envolver” nuestro código en bloques _try catch_, con lo cual el manejo de errores se vuelve muy tedioso:

\`\`\`
async function main(){
	const url = 'https://jsonplaceholder.typicode.com/posts'
	try{
        const response = await requestPosts(url)
        console.log(response)
    }
    catch(error){
        console.log(error)
    }
}

\`\`\`

En los siguientes párrafos veremos cómo RxJS nos puede ayudar a solucionar estas limitaciones, pero antes veamos qué es la programación reactiva.

## ¿Qué es la programación reactiva?

Según el **_Reactive Manifesto_**, la programación reactiva es un paradigma enfocado en el trabajo con _stream_ de datos de manera asíncrona. En este se establece las bases de los sistemas reactivos, los cuales deben ser:

* **Responsivos**: aseguran la calidad del servicio cumpliendo unos tiempos de respuesta establecidos.
* **Resilientes**: se mantienen responsivos incluso cuando se enfrentan a situaciones de error.
* **Elásticos**: se mantienen responsivos incluso ante aumentos en la carga de trabajo.
* **Orientados a mensajes**: minimizan el acoplamiento entre componentes al establecer interacciones basadas en el intercambio de mensajes de manera asíncrona.

### ¿Qué son los **_streams_**?

Para entender la programación reactiva, debemos entender lo que son los _streams_. Podríamos decir que un _stream_ es un tipo de colección, al igual que un _array_ o un _string_, en este caso, de eventos o elementos futuros. La diferencia radica en que los _stream_ no están disponibles de forma síncrona y que, además, desconocemos su tamaño.

Un _stream_ puede provenir de múltiples fuentes, como por ejemplo:

* Eventos del DOM - (eventos del ratón, eventos del teclado, eventos de formularios, etc.)
* Animaciones
* Peticiones HTTP
* _WebSockets_
* Lectura o escritura de ficheros.
* Llamadas a base de datos

## ¿Qué es RxJS?

RxJS es una implementación para JavaScript de las _Reactive Extensions_. Estas fueron desarrolladas por Erik Meijer en Microsoft en el 2009\\. Básicamente son una librería para trabajar con _streams_ mediante el uso de observables.

> Las Rx están implementadas en más de 18 lenguajes de programación. En el mundo de Javascript también son conocidas como el “Lodash” de los eventos.

Esta librería nos proporciona un marco de trabajo en el que todo gira alrededor del tipo básico, el “observable”, el cual simplemente representa un _stream_ de datos. Además, disponemos de otros tipos complementarios como “_observer, schedulers, subjects_” y operadores inspirados en _Arrays_ “_map, filter, reduce_”, etc; los cuales nos permiten el manejo de eventos asíncronos como colecciones. En párrafos posteriores, veremos los operadores más importantes.

![observable](https://res.cloudinary.com/software-crafters/image/upload/v1546943598/posts/introduccion-programacion-reactiva-rxjs/observables.png) 

### _Observer_ e _Iterator_

Para entender qué son y de dónde provienen los observables, debemos entender sus bases, el patrón observer y el patrón iterator.

**Patrón** **_observer_**

La filosofía del patrón observador es sencilla: un objeto, denominado sujeto (_subject_), posee un estado. Si dicho estado cambia, es capaz de “notificar” a sus suscriptores (_ob_ _servers_) de este cambio. Gracias a ello, los objetos suscritos al objeto _subject_ no tienen por qué preocuparse de cuándo se produce un cambio de estado, ya que este se encargará de informar de forma activa a todos aquellos objetos que hayan decidido suscribirse. 

Veamos una implementación básica de dicho patrón:

\`\`\`
class Subject {
    constructor(){
        this.observers = []
    }

    add(obs){
	  this.observers = this.observers.concat(obs)
    }

    delete(obs){
	  this.observers = this.observers.filter(l => l !== obs)
    }

    notify(msg){
	  this.observers.map(obs => obs.update(msg))
    }
}

\`\`\`

Como podemos comprobar, la implementación es muy sencilla. Si creamos una instancia de esta clase, el objeto _subject_ contiene una lista de _observers_. Estos _observers_ se pueden añadir a través de _add,_ o eliminar a través del método _delete_. Además, por medio del método _notify_, podemos notificar a dichos _observers_. 

Veamos un ejemplo de cómo funciona:

\`\`\`
const observer1 = {
	update: msg => console.log(\`observer 1: \${msg}\`)
}

const observer2 = {
	update: msg => console.log(\`observer 2: \${msg}\`)
}

const subject = new Subject()
subject.add(observer1)
subject.add(observer2)
subject.notify("Hello");
//observer 1: Hello
//observer 2: Hello

\`\`\`

Como podemos observar en el código anterior, _observer1_ y _observer2_ son notificados cada vez que el objeto _subject_ actualiza su estado interno. Esta implementación es muy sencilla, pero nos sirve para ilustrar cómo el patrón observador nos permite desacoplar los eventos y la reacción de los objetos que están a la escucha. 

**Patrón** **_Iterator_**

La otra pieza fundamental del puzle es el patrón _iterator_. El objetivo de este patrón es proporcionarnos una manera de acceder a los elementos de un objeto agregado, de forma secuencial, sin exponer sus detalles. Es decir, proporciona a una colección un medio para navegar por sus datos sin exponer su estructura interna.

La implementación del iterador es muy simple, tan solo necesita la especificación de dos métodos: next (), para obtener el siguiente elemento en la colección, y hasNext (), para verificar si quedan elementos en dicha colección. 

\`\`\`
class CustomIterator {
    constructor(collection) {
        this.index = 0;
        this.collection = collection;
    }

    next = () =>
        this.hasNext()
            ? this.collection[this.index++]
            : null

    hasNext = () =>
        this.index + 1 < this.collection.length;
}

const customIterator = new CustomIterator([1,2,3,4])
console.log(customIterator.next(), consumer.hasNext()) //1, true

\`\`\`

Como vemos, es un patrón extremadamente simple, pero nos proporciona una excelente forma de encapsular la lógica mediante la cual recorremos cualquier tipo de estructura de datos. La combinación de este patrón junto con el patrón _observer_ nos es tremendamente efectiva y es la base de los observables de las _Reactive Extensions._

## Qué es un observable

Tras analizar sus fundamentos, veamos qué entendemos por **observable.** Como podemos imaginar, el tipo observable es el eje central de Rx. Simplemente representa la idea de una colección de valores o eventos futuros. 

Los valores o eventos se emiten en orden, igual que en el patrón _iterator_. En lugar de que sean los objetos que lo consumen los que solicitan el siguiente elemento, es el propio observable el que “empuja” los siguientes elementos a los objetos suscritos, a medida que estos están disponibles, tal como sucedía en el _subject_ del patrón _observer_.

### Características: 

* Proporcionan soporte para enviar mensajes entre _publishers_ y _subscribers_.
* Ofrecen beneficios significativos sobre otras técnicas a la hora de trabajar con eventos y manejar la asincronía.
* Los observables son _lazy_ (perezosos). No comienzan a emitir datos hasta que te suscribes a ellos.
* Al igual que los iteradores, un observable puede indicar cuándo se completa la secuencia.
* Nos permiten declarar cómo reaccionar a una secuencia de elementos, en lugar de tener que reaccionar a los elementos de forma individual.

**Ejemplo de observable**

Antes de continuar, veamos una implementación sencilla de cómo consumir un observable:

\`\`\`
import { fromEvent } from 'rxjs';
const link = document.getElementById("customLink");

const obs = {
    next: function(value) {
        console.log(value);
    },
    error: function(err) {
        console.error(err);
    },
    complete: function() {
        console.log("Completed");
    }
};

// Create an Observable from event
const observable = fromEvent(link, "click");
// Subscribe to begin listening for async result
observable.subscribe(obs);

\`\`\`

Lo primero que hacemos es crear un observable a partir de un evento, en concreto del evento clic de un enlace con la id “customLink”. A continuación, nos suscribimos a dicho observable por medio de la función **subscribe**, pasándole el objeto “obs”, que cumple con la interfaz **observer.** 

### _Subscription_ y _observer_

En el ejemplo anterior aparecen dos conceptos básicos de Rx: **_subscription_** y **_observer_**. 

**_Subscription_** representa la ejecución de un observable. Como hemos comentado, los observables son _lazy_, por lo tanto, hasta que no nos suscribimos a ellos, no comienzan a emitir valores. Los suscriptores tienen que implementar la interfaz de observador.

![observable-observers](https://res.cloudinary.com/software-crafters/image/upload/v1546943598/posts/introduccion-programacion-reactiva-rxjs/observables-subscribers.png) 

**_Observer_** es un objeto que sabe reaccionar a los valores entregados por el observable. Para ello implementa la interfaz de observador. Dicha interfaz contiene los métodos **next()**, **error()** y **complete()**. 

![observable process](https://res.cloudinary.com/software-crafters/image/upload/v1546943598/posts/introduccion-programacion-reactiva-rxjs/observable-process.png) 

**_Next_** **()** es el equivalente al método _update_ en el patrón _observer_. Se llama cuando el observable emite un nuevo valor. **_Complete_** **()** se ejecuta cuando no hay más datos disponibles. 

El método **_error_** **()** se ejecuta cuando se produce un error en el observable, al igual que **_complete_** **().** Una vez ejecutado, las siguientes llamadas no tendrán efecto.

## Visualización de observables

Para entender el comportamiento de los observables nos apoyaremos en los **diagramas de** **_marbles_** **o canicas.** Estos diagramas son muy clarificadores, ya que nos ayudan a simplificar el comportamiento de los observables y de los operadores que aplicamos sobre ellos, los cuales nos ayudarán a visualizar de forma más clara el comportamiento de los operadores. 

En este tipo de diagramas el tiempo viene representado por la línea horizontal y los valores emitidos por el observable se encuentran representados por canicas. 

![observable marble](https://res.cloudinary.com/software-crafters/image/upload/v1546943598/posts/introduccion-programacion-reactiva-rxjs/marble.png) 

En el ejemplo tenemos un observable que emite los valores de un evento. Cada una de las canicas representa un elemento emitido, la “x” representa un error y la línea vertical indica que el observable ha dejado de emitir valores.

## Operadores

Un operador es, en esencia, una función pura que toma un observable como entrada y genera otro observable como salida. Existen docenas de operadores divididos en ocho categorías: creacionales, de transformación, de filtrado, condicionales, de combinación, multidifusión, manejo de errores y de utilidad. 

A continuación, veremos los más importante desde un punto de vista pragmático, mediante los cuales podremos realizar el 90% de las operaciones en cualquier proyecto real. 

### Operadores de creación

RxJS nos ofrece una serie de operadores destinados a la creación de observables. Estas funciones simplifican el proceso de creación de observables a partir de elementos como _arrays_, eventos, _callbacks_ o promesas.

**_Create_**

Es el operador de creación más básico. Crea un observable a partir de una función recibida y esta define cómo el observable va a emitir los valores:

\`\`\`
// RxJS v6+
import { Observable } from 'rxjs';
/*
  Create an observable that emits 'Hello' and 'World' on
  subscription.
*/
const hello = Observable.create((observer) => {
  observer.next('Hello');
  observer.next('World');
});

//output: 'Hello'...'World'
const subscribe = hello.subscribe(val => console.log(val));

\`\`\`

**_From_**

Este operador de creación convierte una colección o una promesa en un observable:

\`\`\`
// RxJS v6+
import { from } from 'rxjs';

//emit array as a sequence of values
const arraySource = from([1, 2, 3, 4, 5]);
//output: 1,2,3,4,5
arraySource.subscribe(val => console.log(val));

//emit result of promise
const promiseSource = from(new Promise(resolve => resolve('Hello World!')));
//output: 'Hello World'
const subscribe = promiseSource.subscribe(val => console.log(val));

//emit string as a sequence
const source = from('Hello World');
//output: 'H','e','l','l','o',' ','W','o','r','l','d'
const subscribe = source.subscribe(val => console.log(val));

\`\`\`

**_fromEvent_**

Como su propio nombre indica, este operador convierte cualquier tipo de evento en un observable:

\`\`\`
// RxJS v6+
import { fromEvent } from 'rxjs';
//convert the mousemove event stream of the DOM into an observable sequence.
const source = fromEvent(document, 'mousemove');
source.subscribe(e => console.log(e.clientX + ', ' + e.clientY));

\`\`\`

### Operadores de filtrado

Como su propio nombre indica, son operadores destinados al filtrado de los valores emitidos por el observable. Estos operadores son los más sencillos y fáciles de utilizar, ya que simplemente aceptan o rechazan ciertos valores según los criterios de filtrado aplicados. Sin duda, en este apartado el más importante es **_filter_**.

**_Filter_**

_Filter_ se comporta igual que el operador estándar de JavaScript. Solo emitirá valores si cumple la condición dada por el predicado.

![filter](https://res.cloudinary.com/software-crafters/image/upload/v1546943597/posts/introduccion-programacion-reactiva-rxjs/filter.png) 

\`\`\`
// RxJS v6+
import { from } from 'rxjs';
import { filter } from 'rxjs/operators';

const numbers = from([2, 30, 22, 5, 60, 1])


numbers
    .pipe(filter(n => n > 10))
    .subscribe(n => console.log(n))

\`\`\`

En este caso, el predicado devuelve solo los elementos de entrada mayor que 10\\. Por lo tanto, solo se emiten los valores 30, 22 y 60\\. 

### Operadores de transformación

Existen multitud de operadores que nos permiten aplicar transformaciones elegantes a los observables, aunque en la práctica los más utilizados son los clásicos **_map_** y **_reduce_**, además de algún otro que deriva de estos como **_mergeMap (flatmap)_** y **_concatMap_**. Siendo pragmáticos, con estos operadores tenemos lo necesario para la mayoría de los casos. Los demás los estudiaría bajo demanda, es decir, mientras los fuera necesitando.

**_Map_**

Transforma los elementos emitidos por un observable aplicando una función a cada uno de los mismos. 

![map](https://res.cloudinary.com/software-crafters/image/upload/v1546943597/posts/introduccion-programacion-reactiva-rxjs/map.png) 

\`\`\`
// RxJS v6+
import { from } from 'rxjs';
import { map } from 'rxjs/operators';

const numbers = from([1, 2, 3])

numbers
   .pipe(map(x => 10 * x))
   .subscribe(n => console.log(n))


\`\`\`

En el ejemplo, el observable de origen contiene tres elementos numéricos (1, 2 y 3). _Map_ toma el valor de cada uno de ellos y le aplica la función recibida. En este caso multiplica por 10 cada uno de los elementos.

**_Reduce_**

Funciona igual que en los _Arrays_ de JavaScript. Aplica una función a un acumulador y a cada valor (de izquierda a derecha) para reducirlo a uno solo.

![reduce](https://res.cloudinary.com/software-crafters/image/upload/v1546943598/posts/introduccion-programacion-reactiva-rxjs/reduce.png) 

\`\`\`
// RxJS v6+
import { from } from 'rxjs';
import { reduce } from 'rxjs/operators';


const numbers = from([1, 2, 3, 4, 5])
numbers
	.pipe(reduce((x, y) => x + y))
	.subscribe(n => console.log(n))

\`\`\`

**_mergeMap_**

También como **_flatMap_**. Es un operador tremendamente potente. En muchas ocasiones se da la casuística en la que tenemos un observable cuyos elementos emitidos son también observables, con la complejidad que ello conlleva. Lo que va a hacer **_mergeMap_** es transformar un observable en otros observables y unificar la salida de los mismos bajo un solo _stream_.

![flatmap](https://res.cloudinary.com/software-crafters/image/upload/v1546943598/posts/introduccion-programacion-reactiva-rxjs/flatmap.png) 

\`\`\`
// RxJS v6+
import { from, of } from 'rxjs';
import { mergeMap } from 'rxjs/operators';

const values = from([
    of(1,2,3),
    of(4,5,6),
    of(7,8,9)
])

values
	.pipe(mergeMap(v =>v))
	.subscribe(v => console.log(v))

\`\`\`

En este ejemplo, _value_ es un observable que emite a su vez otros tres observables. _Flatmap_ lo que hace es un _unwrap_ de cada uno de estos observables emitiendo en la secuencia principal uno solo.

Es importante tener en cuenta que _flatMap_ no garantiza el orden en el _stream_ resultante. 

**_ConcatMap_**

Es similar a _flatMap_, aunque en este caso transforma un solo observable de origen a la vez. Por lo tanto, garantiza que los elementos emitidos en el _stream_ resultante mantengan el mismo orden.

![concatmap](https://res.cloudinary.com/software-crafters/image/upload/v1546943598/posts/introduccion-programacion-reactiva-rxjs/concatmap.png) 

\`\`\`
​// RxJS v6+
import { from, of } from 'rxjs';
import { concatMap } from 'rxjs/operators';

const values = from([
    of(1,2,3),
    of(4,5,6),
    of(7,8,9)
])

values
	.pipe(concatMap(v =>v))
	.subscribe(v => console.log(v))

\`\`\`

Al igual que sucedía con _flatMap_, _concatMap_ hace un _unwrap_ de cada uno de estos observables, emitiendo en la secuencia principal un solo _stream_ con la diferencia de que en este caso asegura el orden. 

### Operadores de combinación

En multitud de ocasiones nos veremos en la casuística de tener que combinar más de un _stream_ a la vez y es aquí donde entra este tipo de operadores. Mi operador de combinación preferido es **zip.**

**Zip**

Combina las emisiones de múltiples observables aplicando la operación de la función opcional especificada en el último parámetro. 

![zip](https://res.cloudinary.com/software-crafters/image/upload/v1546943598/posts/introduccion-programacion-reactiva-rxjs/zip.png) 

\`\`\`
​// RxJS v6+
import { from, of } from 'rxjs';
import { zip } from 'rxjs/operators';


const numbers = of(1,2,3,4,5)
const strings = of('a', 'b', 'c', 'd')

zip(numbers, strings, (n,s)=>(n+s))
	.subscribe(v => console.log(v))

\`\`\`

El operador zip emitirá un observable resultante cuando cada observable de origen emita un nuevo elemento (previamente descomprimido). En la práctica, muchas veces se suele utilizar para resolver varios observables a la vez, obteniendo los valores en la función opcional.

## Resumen

Este es el artículo más largo que he escrito hasta el momento, pero creo que este es el post que me hubiera gustado encontrar hace unos años cuando empecé a estudiar la programación reactiva. Creo que es un buen resumen de cómo manejar la complejidad de la asincronía en general y, en particular, haciendo uso del paradigma reactivo junto con RxJS. Quizás se echa en falta algún ejemplo en un escenario real, pero eso lo dejaré para futuras entradas.

Si te ha gustado la entrada, valora y comparte en tus redes sociales. No dudes en comentar dudas, aportes o sugerencias. ¡Estaré encantado de responder! 

Este artículo se distribuye bajo una [Licencia Creative Commons Reconocimiento-CompartirIgual 4.0 Internacional (CC BY-SA 4.0)](https://creativecommons.org/licenses/by-sa/4.0/deed.es%5FES)

[![licencia-cc](https://res.cloudinary.com/software-crafters/image/upload/v1544181784/licencia-cc.png)](https://creativecommons.org/licenses/by-sa/4.0/deed.es%5FES)",
    "slug": "introduccion-programacion-reactiva-rxjs",
    "tags": [
      "javascript",
    ],
    "title": "Introducción a la programación reactiva con RxJS",
    "userPicture": "",
    "username": "Miguel A. Gómez",
  },
  {
    "category": "typescript",
    "cover": "https://swcrafters.fra1.cdn.digitaloceanspaces.com/Categories/TS_category.png",
    "date": "",
    "description": "Pattern Matching o búsqueda de patrones es típicamente usado por lenguajes de programación funcionales, veremos como aplicarlo en TypeScript. ",
    "id": "union-types-pattern-matching-typescript",
    "markdownBody": "Muchos ya sabréis que el tipado estático del lenguaje de programación TypeScript permite declarar un tipo de dato como numérico, texto, booleano o de instancia de clase, por poner algunos ejemplos típicos. Lo que quizás no es tan conocido, seguramente porque no existe en los lenguajes más populares, es que TypeScript también soporta union types (o tipos unión traducido al español).

## Conociendo los union types

Conceptualmente se parecen a los enum types (o tipos enumerados) pero con una importante vuelta de tuerca: permiten definir un tipo como una lista cerrada de valores y, a su vez, cada valor puede ser de un tipo diferente. Suena interesante, ¿no?

Veamos cómo definirlo:

\`\`\`
let a: number | string;

\`\`\`

 Vemos que poniendo el símbolo “|” entre dos tipos le estamos indicando que la variable “a” puede ser de tipo numérica o de tipo texto. Podemos poner tantas opciones como queramos (más adelante veremos otros ejemplos).

 Una vez declarado el tipo, vamos a ver qué podemos hacer con él:

\`\`\`
let a: number | string;
a = 1; // a es un número. Es válido
a = "hello world"; // a ahora es texto. También es válido
a = true; // ¡Error! El compilador dice que a no puede ser true

\`\`\`

 No hay sorpresa. Al haber declarado el tipo de la variable a como numérica o de texto, podemos definirla con el valor 1 o el \`“hello world”\`. Pero al intentar usar valores de otro tipo, en este caso booleano, el compilador nos advierte de que hay un error de tipo y el código no compila.

 Vale, y ahora que conocemos la sintaxis, nos preguntaremos, ¿y para qué sirve el tipo unión? Si buscamos en los objetivos de diseño del [lenguaje TypeScript, encontraremos razones de peso](/typescript/typescript-javascript-introduccion): “Es un superconjunto de JavaScript que trata de evitar errores mediante los tipos y, al mismo tiempo, preservar el comportamiento original de JavaScript” . Por lo tanto, los union type son un mecanismo que permite especificar diferentes tipos para una misma variable, parámetro de una función o como resultado devuelto.

 Veamos algunos ejemplos de uso de union type dentro del propio núcleo del lenguaje:

\`\`\`
const someDate = new Date(1553444243368); // 2019/03/24 17:17 en formato epoch
const anotherDate = new Date(“Mar 24, 2019”); // 2019/03/24 00:00 en formato inglés

const result: RegExpExecArray | null =  /\\d+/.exec(“123456”);

\`\`\`

 Podemos observar que el constructor del tipo Date puede recibir un número, que sería el tiempo en formato epoch o un texto donde la fecha esté definida en inglés con un determinado formato. También vemos que la función exec (muy usada para validar texto con expresiones regulares) puede devolver un objeto especial con el resultado o null.

 Cuando usamos TypeScript, el compilador también usa union types en las propias definiciones de la API del lenguaje para saber qué se puede hacer con los tipos base de JavaScript. Esta es parte de la definición de los tipos que vimos en el ejemplo anterior:

\`\`\`
// extracto de typescript/lib/lib.es5.d.ts

interface Date {
new(value: number | string): Date;
}

interface RegExp {
exec(string: string): RegExpExecArray | null;
}


\`\`\`

 No hace falta entenderla en profundidad. Es solo una curiosidad y la prueba de que hasta el propio TypeScript define muchos tipos base de JavaScript con union types. De hecho, las librerías más conocidas hechas en TypeScript, como pueden ser react o angular, usan union types.

## Caso práctico

 Imaginemos que queremos hacer una librería con una función que dobla el valor que se le pasa. Y vamos a permitir que el parámetro pueda ser de tipo numérico, texto o lista (array). Con lo que hemos contado hasta ahora tendríamos algo así:

\`\`\`
function double(value: number | string | any[]): number | string | any[] {
   if (typeof value === "number")
       return value * 2;
   if (typeof value === "string")
       return value.concat(valor)
   return [...value, ...value];
}

double(1); // 2
double("hello"); // "hello"
double([1,2,3]); // [1,2,3,1,2,3]
double(false); // Error. El argumento no se puede asignar
double({id: 1, name: "Pepe"}); // Error. El argumento no se puede asignar


\`\`\`

 Bien. Ya tenemos nuestra función polimórfica “double” operativa. Aunque funciona es un poco verbosa y personalmente prefiero que el código sea lo más conciso posible. Así que lo primero que vamos a hacer es mejorar la forma de declarar los tipos que acepta y devuelve. Para eso necesitamos introducir el type alias (o alias de tipo en español). TypeScript permite ponerle otro nombre a un tipo de datos. Así:

\`\`\`
type <alias> = <tipo>;

\`\`\`

 Podemos definir el alias con un tipo cualquiera, incluso definido por el usuario como pueden ser interfaces, clases, union types u otros type alias.

 Para nuestra función definiríamos el siguiente alias:

\`\`\`
type DoubleType = number | string | any[];

\`\`\`

 Y ahora podemos sustituir el tipo de entrada y salida por el alias, quedando la definición más simple:

\`\`\`
function double(value: DoubleType ): DoubleType {
   if (typeof value === "number")
       return value * 2;
   if (typeof value === "string")
       return value.concat(value)
   return [...value, ...value];
}

\`\`\`

 Podríamos quedarnos aquí. Pero ¿y si pudiéramos sustituir el código por algo más expresivo?

##  Pattern matching al rescate

 Al igual que union type, el pattern matching es algo típicamente usado por lenguajes de programación funcionales y estáticamente tipados como Haskell, Scala o F#. Por lo que encontraremos muchas referencias a éstos y a su sintaxis. Pero no te asustes; el concepto es muy simple y en realidad ya lo conoces, más o menos:

\`\`\`
let result: DoubleType;

switch (value) {
   case typeof value === "number":
result = value * 2;
break;
   case typeof value === "string":
result = value.concat(valor);
break;
   default:
result = [...value, ...value];
}


\`\`\`

## ¿Qué es el pattern matching?

 Es una estructura del lenguaje que nos permite comprobar un valor contra una serie de casos. Cuando un caso se cumple, se ejecuta la expresión asociada y se termina. Idealmente, los casos permiten especificar no solo valores constantes, si no también tipos, tipos con propiedades concretas o condiciones complejas. Conceptualmente, se parece a un switch mejorado, como en el ejemplo de arriba, que tiene una sintaxis no válida en TypeScript.

 A pesar de que TypeScript no soporta pattern matching en su sintaxis, podemos recurrir a bibliotecas (libraries) para suplir su carencia. En nuestro caso vamos a usar el paquete de npm llamado [x-match-expression](https://www.npmjs.com/package/x-match-expression).

\`\`\`
import {match} from "x-match-expression";

function double(value: DoubleType): DoubleType {
   return match(value)
       .caseNumber(function (n) { return n * 2})
       .caseString(function (s) { return s.concat(s)})
       .default(function (array) { return [...array, ...array]});
}

\`\`\`

 Todavía lo podemos simplificar un poco más usando expresiones lambda en vez de funciones:

\`\`\`
import {match} from "x-match-expression";

function double(value: DoubleType): DoubleType {
   return match(value)
       .caseNumber(n => n * 2)
       .caseString(s => s.concat(s))
       .default(array => [...array, ...array]);
}


\`\`\`

 El código ahora se ve más conciso, pero vamos a explicarlo detalladamente. Primero, importamos la función match, que nos va a permitir hacer el pattern matching en sí. A continuación, la invocamos pasándole el valor que queremos comprobar. Luego, definimos los casos caseNumber y CaseString. Cada caso comprueba si el valor es de un tipo concreto y, si lo és se ejecuta la expresión asociada al caso. Si nos fijamos, la expresión tiene para cada caso un parámetro del tipo que se está probando (esto se aprecia con un editor de código). Es decir, en el caseNumber tendríamos la certeza de que n es numérico. Este principio se aplica a los demás casos que tiene la librería. Finalmente, añadimos un caso por defecto (default), necesario para completar la expresión.

 Aquí hay un editor online para hacer pruebas con todo lo anterior: <https://stackblitz.com/edit/typescript-crd5ep> 

##  Lista de casos de uso de x-match-expression

 Antes de ver la lista de casos, algunos conceptos generales:

* Hay un caso por cada tipo primitivo de dato en JavaScript
* Por cada case<<Type>>, hay un case<<Type>>If adicional que tiene un parámetro más llamado predicado, que sirve para hacer una comprobación extra.
* Todos los casos reciben un parámetro llamado mapper, que es la función que se ejecuta o valor que se devuelve. Si se usa como función, recibe como parámetro el elemento con el tipo acorde al caso.
* Para terminar el patrón y ejecutarlo, hay que finalizar con el caso default.

 Esta es la lista de los casos de uso más comunes que tiene la librería:

* **case:** es el comodín. Se le pasa un predicado cualquiera que nosotros definamos
* **caseIntance:**comprueba si un elemento es instancia de clase o tiene una función como prototype (función constructora)
* **caseTrue:** comprueba si un elemento es true
* **caseFalse:** comprueba si un elemento es false
* **caseBolean:** comprueba si un elemento es de tipo booleano
* **caseEqual:** comprueba si un elemento es igual a otro (no hace comparación profunda)
* **caseNotEqual:** comprueba si un elemento es distinto a otro (no hace comparación profunda)
* **caseNumber:** comprueba si un elemento es de tipo numérico
* **caseAlmostEqual:** comprueba si un elemento es un número aproximado a otro (útil para operaciones decimales)
* **caseNull:** comprueba si un elemento es nulo
* **caseObject:** comprueba si un elemento es de tipo Object
* **caseObjectLike:** comprueba si un elemento tiene partes iguales a otro (mismos keys con los mismos valores)
* **caseObjectWithKeys:** comprueba si un elemento es un objeto con ciertas claves
* **caseString:** comprueba si un elemento es de tipo string
* **caseStringLike:** comprueba si un elemento es de tipo string y cumple con una expresión regular
* **caseEmptyString:** comprueba si un elemento es un string vacío
* **caseDate:** comprueba si un elemento es de tipo Date
* **caseArray:** comprueba si un elemento es de tipo Array
* **caseEmptyArray:** comprueba si un elemento es de tipo Array vacío

 Para mí los más utilizados son **caseInstance y caseInstanceIf**, que permiten usar union types con clases. Hay más casos. Te animo a jugar con la librería y descubrirlos.

##  Uniones discriminadas

 Hay otro concepto en TypeScript relacionado con los union types llamado discriminated unions (o uniones discriminadas en español). Básicamente son tipos que tienen alguna propiedad común, pero con un valor conocido diferente para cada posible tipo y se unen en un tipo unión. Como puede sonar a chino, vamos a poner un poco de código para aclararlo:

\`\`\`
interface Person {
type: “person”;
	name: string;
}

interface Insect {
	type: “insecto”;
	legs: number;
}

type Animal = Person | Insect;

\`\`\`

 Vemos que hay un tipo unión llamado Animal que está formado por dos tipos, los cuales comparten la propiedad type y tienen un valor conocido (técnicamente se llama tipo singleton, que puede ser un texto, un número o un valor concreto booleano).

 La particularidad de una variable con tipo unión discriminada es que el compilador es capaz de darse cuenta de qué tipo concreto es en realidad si le preguntamos por la propiedad que diferencia a uno de sus posibles tipos del otro. Aquí lo vemos:

\`\`\`
const value: Animal = getValue() // no sabemos qué será

// a partir de aquí el compilador sabe que es del tipo Person
if (value.type === “person”)
console.log(\`He is called \${value.name}\`);


\`\`\`

 Este tipo discriminado es interesante, pero no deja de ser un pattern matching limitado y un sistema de tipos “poco elegante”. Personalmente prefiero usar tipos de verdad (instancias de clases) y pattern matching con la librería mencionada pero puede tener sus casos de uso. Sobre todo para código legado (legacy code en inglés).

##  Un ejemplo avanzado de pattern matching

 Ahora que sabemos cómo definir y usar tanto los union types como el pattern matching, hemos visto que son una buena pareja de herramientas para nuestro cinturón de programador: Con los union types podemos definir exactamente qué opciones son válidas para un dato, impidiendo estados inválidos y la posibilidad de que futuros tipos se usen sin que lo especifiquemos explícitamente. Y con el pattern matching podemos expresar de forma concisa cómo tratar cada caso.

 La primera afirmación suena anti principios SOLID, porque salvo lo de impedir estados inválidos, que suena bien, ¿por qué no íbamos a querer que se extienda una parte de la aplicación con nuevos tipos? ¿verdad? Al contrario: es justo lo que no queremos. Al poner la responsabilidad sobre un conjunto de tipos cerrados, y no sobre una interfaz extensible (imaginemos un tipo genérico de error, por ejemplo) estamos forzando que nuestro código sea más confiable y esté mejor documentado.

 Si es la primera vez que lees esta idea, seguramente te chocará y probablemente no estés de acuerdo. Pero piensa lo siguiente: ¿Por qué no usar el sistema de tipos de TypeScript en todo su potencial, para que los tipos sean los que “prueben” la validez del sistema? Personalmente, encuentro en los tipos unión una mejor forma de documentar y dar consistencia al código frente a otras opciones como las interfaces o la herencia en muchos casos.

 Voy a poner un ejemplo: Tenemos que desarrollar una funcionalidad que permita almacenar un correo electrónico en una base de datos. Nuestra primera aproximación podría ser así:

\`\`\`
function saveInDatabase(text: string): boolean {
   //...
}

function saveEmail(email: string) {
   return saveInDatabase(email);
}

const result = saveEmail("pepe@mail.com");
console.log(result ? "saved" : "an error happened");

\`\`\`

 saveEmail devuelve true si tiene éxito y false en caso contrario. Ahora nos damos cuenta de que saveInDatabase tiene que diferenciar entre: Errores generales de la base de datos (como que no se puede conectar, que está llena, que no hay permisos. Es decir cosas irrelevantes desde el punto de vista del dominio o negocio) Si el correo ya estaba almacenado previamente Modificamos nuestro programa con los nuevos requisitos:

\`\`\`

class DatabaseError {
code: number;
message: string;
}

class DuplicatedEmailError {}

class Ok {}


function saveInDatabase(email: string): DatabaseError | DuplicatedEmailError | Ok {
//...
}

function saveEmail(email: string) {
return saveInDatabase(email);
}


const result = saveEmail("pepe@mail.com");

const message = match(result)
.caseInstance(DatabaseError, error => "Your email could not be saved. Please try again in few minutes")
.caseInstance(DuplicatedEmailError, _ => "Your email is already registered. Please check your spam folder")
.default("Your email was successfully registered");

console.log(message);

\`\`\`

 Modificamos saveInDatabase para que devuelva los tipos de error que esperamos. El tipo DatabaseError contiene un código de error y un mensaje que nos pueden servir para logear el problema y que un administrador lo resuelva (No vamos implementar eso ahora). El tipo DuplicatedEmailError nos dice algo importante desde el punto de vista de negocio y lo vamos a discriminar del otro error.

 Si miramos el tipo de datos que devuelve la función, sabremos exactamente las posibilidades a tratar. Con pattern matching sobre esas posibilidades construimos el mensaje que recibirá el usuario. Ya tenemos nuestra versión actualizada con los nuevos requisitos. El lector avispado podría pensar que si en todos los casos al final estamos creando un mensaje de texto, ¿por qué no usar un tipo Message como resultado de saveEmail?

**Problemas con esa aproximación:**

* Para discernir si la operación tuvo éxito o no, para hacer otra cosa, habría que mirar el mensaje en sí. Se podría arreglar parcialmente añadiendo un código al mensaje, pero eso no deja de ser un tipo mal hecho.
* El mensaje no se debe devolver en la capa de base de datos, ¿y si hay que traducirlo o formatearlo de alguna manera?
* Si la función devuelve Message, ¿cómo sabríamos todos los mensajes diferentes que podría devolver la función? Tendríamos que ir a la implementación y ver cuidadosamente todo el código. Puede haber muchas capas por debajo que devuelven diferentes mensajes. En resumen, tendríamos una falta de control sobre las opciones existentes. Los tipos cerrados nos dan esa gran ventaja.
* ¿Cómo enfocaríamos los test sobre esta implementación? Estarían basados y comprobar el texto devuelto en los mensajes y ésto no es muy robusto ni mantenible a la larga.

**Nos llega un nuevo requisito**, que es validar el email, de modo que:

* Tenga un formato estandard
* No contenga ciertas palabras
* Tenga un largo máximo

 Entonces modificamos el programa y nos quedaría:

\`\`\`
import {match} from "x-match-expression";

class DatabaseError {
   code: number;
   message: string;
}

class DuplicatedEmailError {}

class TooLongEmailError {
   maxLenght: number;
}

class WrongEmailFormatError {}

class EmailWithInvalidWordsError {
   words: string[]
}

class Ok {}


function validateEmail(email: string): WrongEmailFormatError | TooLongEmailError | EmailWithInvalidWordsError | Ok {
   //...
}

function saveInDatabase(text: string): DatabaseError | DuplicatedEmailError | Ok {
   //...
}

function saveEmail(email: string) {
   const validationResult = validateEmail(email);
   if (validationResult  instanceof Ok)
       return saveInDatabase(email);
   return validationResult;
}


const result = saveEmail("pepe@mail.com");

const message = match(result)
   .caseInstance(WrongEmailFormatError, _ => "Please use the format abcde@dominio.com")
   .caseInstance(TooLongEmailError, _ => \`Email can not be larger than \${_.maxLenght} characters\`)
   .caseInstance(EmailWithInvalidWordsError, _ => \`Email address cannot contain \${_.words.join(", ")}.\`)
   .caseInstance(DatabaseError, error => "Your email could not be saved. Please try again in a few minutes")
   .caseInstance(DuplicatedEmailError, _ => "Your email address is already registered. Please, check your spam folder")
   .default("Your email was successfully registered");

console.log(message);


\`\`\`

 Hemos añadido los tipos de error requeridos. Algunos de ellos contienen propiedades que podemos usar para dar información al usuario. Al tener los errores como tipos específicos, tenemos la interfaz del método saveEmail ‘cerrada’ y podemos gestionarlos en la capa de abstracción adecuada sin miedo a sorpresas futuras.

 A pesar de todas las mejoras introducidas en el ejemplo, éste aún se podría perfeccionar más con el uso de mónadas (los famosos monads). Concretamente con un tipo Either o Error que permita componer dentro de la función todos los pasos de forma elegante y concisa. Pero esto queda para otro artículo.

 Con lo que debemos quedarnos aquí es que los union types, los type alias y el pattern matching nos permiten disponer de nuevas formas de codificar nuestros programas convirtiéndose en una alternativa sencilla y concisa a la herencia de clases, haciendo nuestro código más funcional y facilitando su mantenibilidad por medio de contratos cerrados autodocumentados. Si no conocías estos conceptos, te invito a que experimentes con ellos y des tu opinión.",
    "slug": "union-types-pattern-matching-typescript",
    "tags": [
      "typescript",
    ],
    "title": "Union types y pattern matching con TypeScript.",
    "userPicture": "",
    "username": "Daniel García",
  },
  {
    "category": "typescript",
    "cover": "https://swcrafters.fra1.cdn.digitaloceanspaces.com/Categories/TS_category.png",
    "date": "",
    "description": "TypeScript es un superconjunto de Javascript, es decir, amplía Javascript con una nueva sintaxis que permite llevar JavaScript a otro nivel.",
    "id": "typescript-tutorial-javascript-introduccion",
    "markdownBody": "Este es el primer artículo de una serie sobre el lenguaje de programación **Typescript** en la que abordaremos los fundamentos de este magnifico lenguaje open source. **Typescript** fue desarrollado en 2012 por Anders Hejlsberg, creador de Pascal, Delphi y C#, y su equipo en **Microsoft.**

## Qué es Typescript

Esencialmente se trata de un **superconjunto de Javascript**, es decir, amplía Javascript con una nueva sintaxis que añade, entre otras cosas, el **tipado estático** opcional, **genéricos**, **decoradores** y elementos de **POO** como interfaces o property accessors.

TypeScript compila código JavaScript que se ejecuta en cualquier navegador, host, sistema operativo o motor de JavaScript que admita ECMAScript 3 (o más reciente).

![typescript superset](https://res.cloudinary.com/software-crafters/image/upload/v1544181785/posts/typescript-javascript-introduccion/superset-typescript.png) 

## Por qué Typescript

A lo largo de los últimos años Javascript ha crecido mucho y se ha convertido en el camino a seguir para escribir aplicaciones multiplataforma (aunque no el único, sigo siendo fan de Xamarin y C#). Las aplicaciones Javascript pueden ejecutarse en todas las plataformas, ya sea en móviles, web o escritorio. Sin embargo, cuando Javascript fue creado por primera vez su proposito no fue este, sino que fue diseñado para un uso simple en aplicaciones muy pequeñas.

TypeScript trata de resolver la mayoría de los problemas con JavaScript centrándose en mejorar la experiencia y la productividad de nosotros, los desarrolladores. Nos permite utilizar técnicas como el tipado estático opcional y/o la encapsulación para generar un código mucho más mantenible y escalable que con JavaScript tradicional, sin perder el carácter dinámico del mismo.

demás estos dos últimos años la popularidad de TypeScript se ha disparado y se perfila como uno de los lenguajes de programación con **más futuro**.

![typescript-trend](https://res.cloudinary.com/software-crafters/image/upload/v1544181933/posts/typescript-javascript-introduccion/grafica-typescript.png) 

## Instalación de Typescript

Para poder instalar typescript el único **requisito** necesario es tener instalado en nuestro equipo **nodejs** y su administrador de paquetes (**npm**).

Cuando nos referimos a la "instalación de typescript" en realidad hacemos referencia a la instalación de su **compilador**, llamado **tsc.**  Este se encarga de convertir el código TypeScript a Javascript con la versión ECMAScript compatible que deseemos.

Para instalarlo tan solo tenemos que ejecutar en la terminal lo siguiente:

\`\`\`
npm install -g typescript
\`\`\`

Para comprobar que la instalación se ha realizado correctamente ejecuta:

\`\`\`
tsc -v
\`\`\`

Esto nos mostrará la versión, en mi caso la 2.6

## Uso de Typescript CLI

Para probar la instalación, creemos un archivo TypeScript simple llamado **helloworld.ts** con el siguiente código:

\`\`\`
console.log("Hello world!")
\`\`\`

El siguiente comando compilará un archivo \`.ts\` a un archivo \`.js\`:

\`\`\`
tsc helloworld.ts
\`\`\`

Esto creará un fichero \`helloworld.js\`. Este fichero lo podemos ejecutar en el navegador o como haremos en este caso, con Node:

\`\`\`
node helloworld.js
//"Hello world"
\`\`\`

El comando tsc se puede utilizar de formas muy variadas, veamos unos cuantos usos interesantes:

### Compilar varios archivos

Para compilar varios archivos:

\`\`\`
tsc hello1.ts hello2.ts hello3.ts
\`\`\`

También podríamos utilizar asteriscos:

\`\`\`
tsc *.ts
\`\`\`

Esto compilará todos los ficheros typescript que se encuentren en el directorio. Cada fichero typescript se compilará en su archivo javascript correspondiente.

### Unir archivos

También podemos compilar todos los archivos TypeScript en un solo archivo JavaScript. Esto nos ayudaría a reducir el número de solicitudes HTTP que un navegador debe realizar y de esta manera mejorar el rendimiento de nuestro sitio web. Para ello utilizaremos la opción --out del compilador:

\`\`\`
tsc *.ts --out helloworld.js
\`\`\`

### Watcher

Si queremos evitar tener que compilar el archivo typescript cada vez que hagamos una modificación del mismo, podemos utilizar la opción \`--watch\`:

\`\`\`
tsc *.ts --out helloworld.js --watch
\`\`\`

Con esto conseguiremos que cada vez que guardemos las modificaciones el fichero se compilará automáticamente.

## Creando un proyecto Typescript

Para crear un proyecto de TypeScript, lo único que necesitamos es crear un directorio y dentro del mismo crear un archivo de configuración de Typescript tsconfig.json. Este fichero, entre otras cosas, indica al compilador qué archivos compilar, qué archivos ignorar y qué a que version de javascript transpilar (por ejemplo, ECMAScript 3).

Para crear nuestro primer proyecto de TypeScript, creemos el nuevo directorio y agreguemos el archivo de configuración de TypeScript:

\`\`\`
mkdir myProject
cd myProject
touch tsconfig.json
\`\`\`

### Configuración de Typescript

En este articulo ejecutaré todos los ejemplos en la terminal usando Node.js. Node corre sobre Chrome V8, uno de los motores de JavaScript más actualizados disponibles. La versión 6 de Node.js se envía con una versión de Chrome V8 capaz de soportar el 95% de la especificación ECMAScript 2015, como se muestra en [Node Green](http://node.green/), mientras que la versión 8 es compatible con el 99%.

Con respecto a ECMAScript 2017, ambas versiones admiten el 23% y el 73% de las especificaciones, respectivamente. Por lo tanto, la mejor opción es configurar nuestro proyecto para que se compile en ECMAScript 2015, lo que permitirá a los usuarios con Node.js 6 y 8 ejecutar los ejemplos sin problemas.

Además de indicar la versión de javascript, también configuraremos estas otras opciones del compilador:

* \`module\`, indica a Typescript que use el formato [CommonJS](http://requirejs.org/docs/commonjs.html) para los modulos.
* \`removeComments\`, elimina los comentarios del código generado.
* \`sourceMap\`, permite usar mapas de origen para asignar el código transpilado al código fuente.
* \`outDir\`, indica el directorio en el cual se almacenará el código generado (build).
* \`include\`, indica el directorio de los ficheros a compilar (src).

Nuestro fichero de configuración quedaría tal que así:


    \`{
  "compilerOptions": {
    "module": "commonjs",
    "target": "es2015",
    "removeComments": true,
    "outDir": "./build"
  },
  "include": ["src/**/*"]
}\`

Las opciones utilizadas en el archivo de configuración anterior son solo un pequeño subconjunto de lo que TypeScript admite. Por ejemplo, podríamos indicar al compilador que soporte decoradores, archivos tsx, etc. En la documentación oficial tenemos una lista con todas las [opciones que admite el compilador.](https://www.typescriptlang.org/docs/handbook/compiler-options.html)

Ahora que entendemos cómo iniciar un proyecto y cómo configurar el compilador, estamos listos para ir profundizando en las diferentes características del lenguaje.

## Sistema de tipos

Sin lugar a dudas la principal característica de Typescript es su sistema de tipos, el cual realiza una formalización de los tipos de Javascript, mediante una representación estática de su sistema de tipado dinámico. Esto permite a los desarrolladores definir variables y funciones fuertemente tipadas sin perder la esencia de Javascript (su naturaleza debilmente tipada y su extremada flexibilidad). Poder definir los tipos durante el tiempo de diseño nos ayuda a evitar errores en tiempo de ejecución, como podría ser pasar el tipo de variable incorrecto a una función.

Veamos con un ejemplo de las ventajas que nos ofrece:

\`let myName: string = "Miguel";
let printName = (name: string) ={
    console.log(name);
}\`

Si intentamos ejecutar la función \`printName()\` pasándole un parámetro vacío o del tipo incorrecto el compilador nos advierte en tiempo de desarrollo, en lugar de generar excepciones en tiempo de ejecución. Además, el intellisense nos ayuda con el autocompletado sugiriendonos la variable más apropiada para pasar como parámetro a la función. Por otro lado, Typescript es lo suficientemente inteligente para inferir el tipo sin indicarselo explícitamente.

  
![typescript-fundamentos](https://res.cloudinary.com/software-crafters/image/upload/v1544181787/posts/typescript-javascript-introduccion/typescript-fundamentos-1.gif) 

## 

Además de los tipos **String** y **Number**, TypeScript también admite los siguientes tipos básicos:

* **Boolean**: tipo de dato logico que representa verdadero o falso.
* **Array**: tipo de dato estructurado que permite almacenar una colección de elementos.
* **Tuple**: similar al array, pero con un número fijo de elementos escritos.
* **Enum**: representa al tipo enumeración. Una enumeración es una forma de dar nombres descriptivos a los conjuntos de valores numéricos
* **Any**: indica que la variable puede ser de cualquier tipo. Es muy útil a la hora de trabajar con librerías externas.
* **Void**: indica que una función no devolverá ningún valor.
* **Never**: este tipo representa el tipo de valores que nunca se producen. Por ejemplo para indicar que una función siempre arroja una excepción o que nunca termina su ejecución.

Echemos un vistazo al siguiente codigo para obtener una vision general de lo que Typescript nos permite hacer con los tipos básicos:

\`\`\`
// 1 - declaracion del tipo
type Ranking = [number, string, boolean];

// 2 - definición de variables
let position: number;
let playerName: string;
let finishedGame: boolean;
let ranking: Ranking;
let hallOfFame: Array<Ranking> = [];

// 3 - crea un ranking
position = 1;
playerName = "Bruno Krebs";
finishedGame = true;
ranking = [position, playerName, finishedGame];
hallOfFame.push(ranking);

// 4 - crea otro ranking
position = 2;
playerName = "Maria Helena";
finishedGame = true;
ranking = [position, playerName, finishedGame];
hallOfFame.push(ranking);

// 5 - define una funcion que recorre todos los rankings
function printRankings(rankings: Array<RankingTuple>): void {
  for (let ranking of rankings) {
    console.log(ranking);
  }
}

// 6 - llama a la función
printRankings(hallOfFame);
\`\`\`

Si quieres continuar profundizando en el sistema de tipos de typescript te recomiendo que eches un vistazo a la [documentación oficial](https://www.typescriptlang.org/docs/handbook/basic-types.html).

## Estructuras iterativas

En typescript tenemos podemos hacer uso de dos tipos de bucles diferentes **for ... in** y **for .. of**. For... in es una proviene de versiones antiguas de javascript el cual nos permite recorrer objetos iterables obteniendo sus indices. En cambio, For...of es una caracteristica introducida en ES6, la cual nos permite recorrer colecciones obteniendo su valor, veamos las diferencias con un ejemplo:

\`\`\`
let list = [4, 5, 6];

for (let i in list) {
   console.log(i); // "0", "1", "2",
}

for (let i of list) {
   console.log(i); // "4", "5", "6"
}
\`\`\`

## Modulos en typescript

Otra de las características de Typescript es heredada de ECMAScript 2015 la posibilidad de crear módulos, loc cuales no son más que una forma de encapsular código en su propio ámbito. Nos permiten agrupar nuestro código en diferentes ficheros, permitiéndonos exportarlos y utilizarlos donde los necesitemos. Esto nos facilita la tarea de crear software más ordenado y por ende más escalable y mantenible.

Continuando con el ejemplo de la sección anterior, si quisieramos exportar el tipo Ranking y la función printRankings(), tan solo tendríamos que añadirle la palabra reservada **export** antes de la definición de los mismos:

\`\`\`
export type RankingTuple = [number, string, boolean];

export function printRankings(rankings: Array<RankingTuple>): void {
  for (let ranking of rankings) {
    console.log(ranking);
  }
}

\`\`\`

Para importarlos en otro fichero tan solo nos bastaría con lo siguiente:

import {RankingTuple, printRankings} from './myRankingModule.ts';

## Clases y objetos en Typescript

Un objeto es una entidad que agrupa un estado y una funcionalidad relacionada,una clase, no es más que una plantilla genérica a partir de la cuál instanciamos los objetos. Dicho de otra manera, una clase es una abstracción en la que se define el comportamiento que va a tener el objeto.

Las clases en Typescript son muy similares a lo que nos ofrecen otros lenguajes de orientación a objetos tradicionales, esto nos ayudará a modularizar nuestro código y a simplificar el desarrollo. Veamos con un ejemplo como definir una clase:

\`\`\`
class Employee {
    //atributo accesible desde fuera de la clase
    public name : string;
    //atributos accesible desde clases que hereden de Employee
    protected age: number;
    //access only inside the Employee class
    private mobile : string;

    constructor(name:string ,age:number, mobile:string){
        this.name = name;
        this.age = age;
        this.mobile = mobile;
    }
    getName(){
       return this.name;
    }

    setName(name:string){
       this.name = name;
    }
    getAge(){
       return this.age;
    }

    setAge(age:number){
       this.age = age;
    }

    getMobile(mobile:string){
       this.mobile = mobile;
    }
}
\`\`\`

### Métodos accesores (Getters y Setters)

Como sabemos, los métodos **get** y **set**, también conocidos como métodos accesores, son simples funciones que usamos en las clases para mostrar (get) o modificar (set) el valor de un atributo. Normalmente los escribimos como "get" o "set" seguido del nombre de la propiedad a la que queremos acceder, por ejemplo: getName(). En Typescript se puede hacer de esta forma o haciendo uso de las palabras reservadas get o set delante del nombre de la función:

\`\`\`
class Actor {
    private _name : string;
    constructor(_name:string){
        this._name = _name;
    }
    set name (value: string){
        this._name = value;
    }
    get name (){
        return this._name;
    }
}

let actor = new Actor('Haider Malik');
console.log(actor.name);
//set
actor.name = 'Jane Doe';
console.log(actor.name);
\`\`\`

### Herencia en typescript

Otro elemento fundamental en la OO es la herencia, la cual nos permite extender la funcionalidad nuestra clase herendando de una clase padre. La clase hija hereda todos los miembros de su clase base y puede sobreescribir todos aquellos métodos y/o propiedades públicos o protegidos.

\`\`\`
class Manager extends Employee {
   constructor(name : string, age: number , mobile : string){
       super(name,age,mobile);
       this.age = 24;
   }
}

let manager = new Manager(‘Jane’,23, ‘0343–23332233’);
console.log(manager.getName());
console.log(manager.getAge());
\`\`\`

### Clases abstractas

Este tipo de clases no pueden ser instanciadas ya que se usan para definir comportamientos independientemente de su concreción. Su implementación en typescript es similar a la de una clase normal con la diferencia que hay que anteponer el termino **abstract** antes de declararlas.

\`\`\`
abstract class Product {
    productName : string = "Default";
    price :number = 1000;
    abstract changeName(name: string): void;

    calcPrice(){
        return this.price;
    }
}

class Mobile extends  Product {
    changeName(name : string) : void {
        this.productName = name;
    }
}

let mobProduct = new Mobile();
console.log(mobProduct);
mobProduct.changeName("Super It Product");
console.log(mobProduct);
\`\`\`

## Interfaces en Typescript

Las interfaces son abstracciones que definen el comportamiento de las clases que la implementan. Son muy prácticas ya que nos permiten decirle al compilador cual es el comportamiento que debe esperar del objeto que definamos. Como ocurre en otros lenguajes de programación, TypeScript no requiere que un objeto tenga exactamente la misma estructura definida por la interfaz. Para que se los considere válidos, los objetos pueden tener cualquier forma siempre que definan las funciones y propiedades requeridas por la interfaz que implementan. Veamos un pequeño ejemplo de como declararla e implementarla:

\`\`\`
interface ICar{
    engine: string;
    color: string;

    brake: () => void;
}

class Car implements ICar {
    constructor (public engine: string, public color: string) {
    }

    function brake(){
        console.log("Frenando...")
    }
}
\`\`\`

## Decoradores en typescript

Los decoradores son un estándar propuesto en ECMAScript2016\\. En Typescript podemos habilitarlos añadiendo a nuestro tsconfig.json la directiva "experimentalDecorators: true".

\`\`\`
{
    "compilerOptions": {
    "module": "commonjs",
    "target": "es2015",
    "removeComments": true,
    "experimentalDecorators": true,
    "outDir": "./build"
  },
  "include": ["src/**/*"]
}
\`\`\`

Por si no lo sabías, los decoradores son un mecanismo para modificar clases, métodos, propiedades e incluso parámetros de forma declarativa. Obviaré los decoradores de propiedades y de parámetros ya que en la practica no resultan demasiado interesantes.

### Decorador de clase

Un decorador de clase es una función que recibe y devuelve el método constructor de la clase que "decora". Veamos un ejemplo de implementación:

\`\`\`
const log = (originalConstructor: new(...args: any[]) => T) => {
    function newConstructor(... args) {
        console.log("Argumentos: ", args.join(", "));
        new originalConstructor(args);
    }

    newConstructor.prototype = originalConstructor.prototype;
    return newConstructor;
}

@log
class Person {
    constructor(name: string, age: number) {}
}

new Person("Miguel", 33);
//Argumentos: Miguel, 33
\`\`\`

Como podemos observar el decorador log reemplaza el constructor de la clase por una función que, en primer lugar, registra a través de la consola los argumentos y luego devuelve el constructor original.

### Decorador de métodos

El decorador de métodos es una función que acepta 3 argumentos: el objeto sobre el que se define el método, la clave de la propiedad y un descriptor de propiedad:

\`\`\`
const log = (target: Object, key: string | symbol, descriptor: TypedPropertyDescriptor<Function>) => {
    return {
        value: function( ... args: any[]) {
            console.log("Arguments: ", args.join(", "));
            const result = descriptor.value.apply(target, args);
            console.log("Result: ", result);
            return result;
        }
    }
}

class Calculator {
    @log
    add(x: number, y: number) {
        return x + y;
    }
}

new Calculator().add(1, 3);
//Arguments: 1, 3
//Result: 4
\`\`\`

En este ejemplo, el decorador log reemplaza la función original por una nueva que registra los argumentos recibidos, ejecuta el método original, almacena el resultado en una variable local lo registra en la consola y finalmente lo devuelve.

### Resumen

En este articulo he tratado de mostrar la mayoría de características básicas de Typescript. Aunque he condensado bastante información en este artículo, me he dejado muchísimos elementos en el tintero. La idea es que esta entrada sirva como base a futuras publicaciones relacionadas con este magnifica lenguaje.

Espero haber facilitado tu transición a Typescript, si ya lo conocías espero que el artículo te sirva como referencia. Si te ha gustado la entrada valora y comparte en tus redes sociales. No dudes en comentar dudas, aportes o sugerencias, estaré encantado de responder.

Este artículo se distribuye bajo una [Licencia Creative Commons Reconocimiento-CompartirIgual 4.0 Internacional (CC BY-SA 4.0)](https://creativecommons.org/licenses/by-sa/4.0/deed.es%5FES)

[![licencia-cc](https://res.cloudinary.com/software-crafters/image/upload/v1544181784/licencia-cc.png)](https://creativecommons.org/licenses/by-sa/4.0/deed.es%5FES)",
    "slug": "typescript-tutorial-javascript-introduccion",
    "tags": [
      "typescript",
    ],
    "title": "Tutorial de Typescript, el javascript que escala. Introducción.",
    "userPicture": "",
    "username": "Miguel A. Gómez",
  },
  {
    "category": "react",
    "cover": "https://swcrafters.fra1.cdn.digitaloceanspaces.com/Categories/ReactJS_category.png",
    "date": "",
    "description": "¿Qué es React? ReactJS es una librería Javascript desarrollada por Facebook y diseñada para ayudarnos a crear SPA's (Single Page Application).",
    "id": "tutorial-react-js-introduccion",
    "markdownBody": " Hoy me toca escribir sobre otra de las tecnologías que uso en varios de los proyectos en los que trabajo, **ReactJS**. Se que existe muchísima información en la red sobre esta librería, aunque en muchos casos inconexa.

 El objetivo de este artículo es tratar de organizar y condensar los conceptos fundamentales para comenzar a utilizar esta tecnología desarrollando un ejemplo práctico ([demo](https://softwarecrafters.io/demos/intro-reactjs)).

## ¿Qué es React.js?

 Como muchos ya sabréis, **ReactJS** es una **librería Javascript** desarrollada por **Facebook** y diseñada para ayudarnos a crear **SPA's** (Single Page Application), su objetivo concretamente es tratar de facilitar la tarea de **desarrollar interfaces** de usuario. Podríamos decir que React es la **V** en un contexto en el que se use el patrón MVC o MVVM.

 Hace uso del paradigma denominado [programación orientada a componentes](https://es.wikipedia.org/wiki/Programaci%C3%B3n%5Forientada%5Fa%5Fcomponentes). Dichos componentes se representan como clases que heredan de la clase \`Component\` cuyo único requerimiento especial es especificar el método render que define cuál será el contenido del mismo:

\`class MyComponent extends React.Component {
  render() {
    return (
      <h1>Hello World</h1>
    );
  }
}\`

 La definición de dichos componentes se realiza usando una sintaxis especial llamada **JSX** que permite escribir etiquetas HTML dentro de JavaScript para mejorar la expresividad del código. Usar JSX no es obligatorio, pero si es muy recomendable. Para más información sobre JSX puedes consultar la [documentación oficial](https://facebook.github.io/react/docs/jsx-in-depth.html).

## Configuración del entorno mediante "Create React App"

 Normalmente cuando vamos a construir una aplicación Web con Javascript tendremos que lidiar con una cantidad de ingente de herramientas como gestores de paquetes, transpiladores, linkers, builders, etc. El equipo de desarrollo de Facebook ha sabido ver esta problemática y se ha sacado de la manga el proyecto [Create React App](https://github.com/facebookincubator/create-react-app), el cual realizará por nosotros toda la configuración inicial necesaria para poder empezar a desarrollar con React.

**Create React App** se puede utilizar con el nuevo gestor de dependencias [Yarn](https://yarnpkg.com/en/), creado también por la gente de Facebook, o con el clásico **NPM**. En el artículo haré uso de NPM, aunque te aconsejo que le des una oportunidad a Yarn, tiene muy buena pinta.

 El único requisito imprescindible para poder hacer uso de Create React App con NPM es tener instalado en el sistema una versión de [NodeJs](https://nodejs.org/es/) \\>= 4\\. Si ya dispones de npm puedes instalar \`create react app\` como cualquier otro paquete:

\`\`\`
npm install -g create-react-app
\`\`\`

 Una vez instalado puedes inicializar el proyecto:

\`\`\`
create-react-app MyWebApp
\`\`\`

 Con este simple gesto tendrás configurado[ JavaScript ES6](http://www.ecma-international.org/ecma-262/6.0/) con [React](https://facebook.github.io/react/), [Webpack](https://webpack.github.io/), [Babel](https://babeljs.io/) y [Eslint](http://eslint.org/), nada de instalar dependencias, ni de crear tareas. Está todo listo para ejecutar el servidor de desarrollo, y probar la aplicación:

\`\`\`
cd MyWebApp
npm start
\`\`\`

Con el servidor corriendo, dirígete a la url 127.0.0.1:3000 para ver la aplicación en funcionamiento:

![create-react-app](https://res.cloudinary.com/software-crafters/image/upload/v1544294255/posts/tutorial-react-js-introduccion/create-react-app.png) 

 El proyecto generado tendrá una estructura tal que así:

\`\`\`
\`\`\`
MyWebApp/
  README.md
  node_modules/
  package.json
  public/
    index.html
    favicon.ico
  src/
    App.css
    App.js
    App.test.js
    index.css
    index.js
    logo.svg
\`\`\`
\`\`\`

* **node\\_modules**: contiene las dependencias npm del proyecto
* **public**: esta es la raíz de nuestro servidor donde se podrá encontrar el index.html, el archivo principal y el favicon.
* **src**: es el directorio principal donde vamos a colocar los archivos de nuestros componentes.

 Además encontrarás varios archivos sueltos, un readme, el .gitignore y el **package.json**, este último contiene las dependencias de npm además de la información del proyecto.

 Es importante tener en cuenta que para que Create React App funcione correctamente tenemos que tener obligatoriamente el fichero principal de html en "public/index.html" y punto de entrada de javascript en "scr/index.js".

## La app de ejemplo

 La app que se va a desarrollar constará de un formulario en el que el usuario podrá introducir un nombre y un email, y estos se añadirán a un listado (demo).

 La web app estará formada por tres componentes que iremos construyendo a lo largo del artículo, \`User\`, \`UserList\`, \`UserForm \`; además del componente principal (\`App\`) y el punto de entrada (\`index.js\`. Puedes descargar el ejemplo completo desde mi cuenta de [Github](https://github.com/miguelghz/Intro-ReactJS).

### El componente principal y el punto de entrada javascript

 Como he comentado el punto de entrada a la aplicación es el fichero scr/index.js, en este se inicializa el componente principal App.js, a través del método \`ReactDOM.Render\`. Dicho método recibe como primer parámetro el componente a renderizar y como segundo el elemento del DOM donde el componente va ser renderizado:

\`\`\`
import React from 'react';
import ReactDOM from 'react-dom';
import App from './App';

ReactDOM.render(
  <App />,
  document.getElementById('root')
);


\`\`\`

A continuación vemos el código auto-generado que corresponde al componente principal:

\`\`\`
import React, { Component } from 'react';
import logo from './logo.svg';
import './App.css';

class App extends Component {
  render() {
    return (
      <div className="App">
        <div className="App-header">
          <img src={logo} className="App-logo" alt="logo" />
          <h2>Bienvenido a React</h2>
        </div>
          <p className="App-intro">
            Lista de usuarios
          </p>
      </div>
    );
  }
}

export default App;


\`\`\`

 Antes de continuar desarrollando el ejemplo voy eliminar unas cuantas líneas de este componente para dejarlo, por ahora, lo más simple posible:

\`\`\`
import React, { Component } from 'react';

class App extends Component {
  render() {
    return (
      <h1>Hello World!</h1>
    );
  }
}

export default App;


\`\`\`

 En la primera línea \`import React… \` se está importando la librería React y la clase Component de la cual van a heredar todos los componentes que se creen mediante clases. Éstas requieren del método \`render()\` para poder funcionar.

 En la versión previa de Javascript se utilizaba la función \`React.createClass\` para inicializar componentes, gracias a ES6 y a su azúcar sintáctico, esto se ha simplificado.

## Propiedades (props) de react

 Las propiedades de un componente (props) pueden definirse como los atributos de configuración para dicho componente. Éstas son recibidas desde un nivel superior, normalmente al realizar la instanciación del componente y por definición son inmutables.

 Siguiendo con el ejemplo, voy a implementar el componente \`User\`, el cual contiene dos props \`name\` y \`user\`, las cuales redenrizará en un elemento de lista \`li\`.

\`\`\`
import React, { Component } from 'react';

class User extends Component {
  render () {
    return (
      <li>
        {this.props.name} - {this.props.email}
      </li>
    );
  }
}

export default User;

\`\`\`

 Las props, basicamente, son el mecanismo principal de React para pasar datos de un componente padre a un componente hijo.

### Anidación de componentes

 Una vez creado el componente User, definiremos el componente \`UserList\`, cuyo objetivo será renderizar una lista de componentes \`User\`:

\`\`\`
class UserList extends Component {
  render () {
    return (
        <ul>
          {this.props.users.map(u => {
            return (
              <User
                key={u.id}
                name={u.name}
                email={u.email}
              />
            );
          })}
        </ul>
    );
  }
}

\`\`\`

 En el código del componente anterior renderizará una lista de usuarios, para ello hace uso del método \`map\`, con el cual itera sobre cada uno de los elementos del array de usuarios que contiene la propiedad \`this.props.users\`, esta prop será recibida desde el componente \`App\`.

 Map devuelve por cada elemento un componente \`User\`, el cual recibe vía props el nombre, el email y una key. La propiedad key es un identificador que usa React en las listas, para renderizar los componentes de forma más eficiente.

## Estado en los componentes

 Podría definirse el estado de un componente como una representación del mismo en un momento concreto, algo así como una instantánea del componente. Dicho estado se iniciará con un valor por defecto.

 Existen dos tipos de componentes con y sin estado, también denominados statefull y stateless, respectivamente.

### Componentes stateless

 Todos los componentes implementados hasta el momento han sido stateless, sin estado. Este tipo de componentes podrían representarse como una función pura:

\`\`\`

    function User(props) {
    return (
        <li>{props.name} - {props.email}</li>
    );
}

\`\`\`

 Las funciones puras por definición no tienen efectos colaterales, con lo cual este tipo de componentes no admite ciclos de vida. Para no complicar las cosas, continuaremos creando nuestros componentes como clases.

### Componentes statefull

 Los componentes con estado permiten mantener datos propios a lo largo del tiempo e implementar comportamientos en sus diferentes métodos del ciclo de vida.

### El ciclo de vida de un componente en React

 El ciclo de vida no es más que una serie de estados por los cuales pasa todo componente a lo largo de su existencia, basicamente se pueden clasificar en tres etapas de montaje o inicialización, actualización y destrucción. Dichas etapas tienen correspondencia en diversos métodos, que nosotros podemos implementar para realizar acciones concretas cuando estos van sucendiendo. Aunque en el ejemplo que estamos desarrollando no voy a hacer uso del ciclo de vida, haré un pequeño inciso para describir sus métodos sin profundizar excesivamente:

![Ciclo de vida de los componentes en React](https://res.cloudinary.com/software-crafters/image/upload/v1544294255/posts/tutorial-react-js-introduccion/Cheatsheet-life-cicle.jpg) 

**Métodos de inicialización:**

* \`componentWillMount()\`: se ejecuta antes de que se renderice el componente por primera vez, es muy util para manejar ciertos datos necesarios para la representación del componente o declarar ciertos eventos. Las referencias a los elementos del componente aun no están disponibles.
* \`componentDidMount()\`: se dispara justo después del primer renderizado, es decir el DOM ya está disponible. Este es el sitio adecuado para realizar peticiones AJAX, setIntervals o integrar librerías de terceros.

**Métodos de actualización:**

* \`componentWillReceiveProps(nextProps)\`: es ejecutado cuando las propiedades se van a actualizar, recibe el próximo valor que va a tener el objeto de propiedades.
* \`shouldComponentUpdate(nextProps, nextState)\`: se lanza antes del render y decide si nuestro componente se re-renderiza o no. Recibe dos parametros, las nuevas propiedades y el nuevo estado.
* \`componentWillUpdate(nextProps, nextState)\`: se ejecutará justo después de que shouldComponentUpdate devuelva true, está pensado para preparar al componente para su actualización por lo que se debe evitar modificar estados en este punto.
* \`componentDidUpdate(prevProps, prevState)\`: se invoca justo después de haberse producido la actualización del componente, los cambios ya están trasladados al DOM.

**Métodos de desmontaje:** 

* \`componentWillUnmount()\`: es el único método que interviene en el desmontaje de un componente, es invocado justo antes de que el componente se desmonte, es ideal para realizar operaciones de limpieza como listeners de eventos o temporizadores.

 Continuando con el ejemplo, voy a modificar el componente App para asignarle un estado inicial que almacene un array con varios objetos "user". Para ello sobreescribiremos el método constructor del componente asignando al estado inicial (\`this.state\`) el array de usuarios.

 Finalmente, en el método render renderizará un componente del tipo \`UserList\`, al cual se le pasa el estado a través de la prop \`users\`. Quedando el componente tal que así:

\`\`\`

class App extends Component {
  constructor() {
    super();
    this.state = {
      users: [
        {id: 1, name: "miguel", email: "test@miguelgomez.io"},
        {id: 2, name: "test", email: "test@test.es"}
      ]
    };
  }

  render() {
    return (
        <UserList users={this.state.users} />
    );
  }
}

\`\`\`

 Gracias al estado se pueden añadir nuevos usuarios al array los cuales se renderizarán automáticamente. Esto es posible ya que, como hemos visto en los ciclos de vida, el estado tiene la particularidad de que cuando cambia el método render vuelve a ejecutarse.

## Propagación de eventos

Los eventos, al contrario que las propiedades, se propagan de hijos a padres. Es decir, son lanzados por los componentes hijos y el padre es el encargado de gestionarlos.

 Veamos esto en nuestro ejemplo, para ello vamos añadir al componente UserForm un formulario con dos campos, uno para el email y otro para el nombre.

\`\`\`

import React, { Component } from 'react'

export default class UserForm extends Component{
  render(){
    return (
      <form onSubmit={this.props.onAddUser}>
          <input type="text" placeholder="Nombre" name="name" />
          <input type="email" placeholder="Email" name="email" />
          <input type="submit" value="Guardar" />
      </form>
    );
  }
}

\`\`\`

 Cada vez que se pulse el botón guardar el formulario disparará el evento \`onSubmit()\`, el cual llama a una función que recibirá del componente padre a través de la propiedad \`props.OnAddUser\` (a esto se le conoce como **Callback**).

 La función callback se define en el componente App, \`handleOnAddUser(event)\` y será la encargado de manejar el evento.

\`\`\`

    class App extends Component {
  constructor() {
    super();
    this.state = {
      users: [
        {id: 1, name: "miguel", email: "miguelghz@miguelgomez.io"},
        {id: 2, name: "test", email: "test@test.es"}
      ]
    };
  }

  handleOnAddUser (event) {
    event.preventDefault();
    let user = {
      name: event.target.name.value,
      email: event.target.email.value
    };
    this.setState({
      users: this.state.users.concat([user])
    });
  }

  render() {
    return (
        <div>
          <UserList users={this.state.users}  />
          <UserForm onAddUser={this.handleOnAddUser.bind(this)} />
        </div>
    );
  }
}

\`\`\`

 El método \`handleOnAddUser\` recibe como parámetro un objecto event, el cual contiene toda la información del evento, tanto su comportamiento como los valores de los inputs del formulario. Para evitar que el evento dispare su comportamiento por defecto (en este caso recargar la página), ejecutaremos el método \`preventDefault()\` antes de capturar los valores de los campos "name" y "user".

 Por último, actualizaremos el array, para ello en lugar de modificarlo añadiendo el nuevo elemento con el método \`push\`, usamos el método \`concat\`. De esta manera se creará un nuevo array en lugar de modificar el existente, manteniendo así cierta inmutabilidad en el estado del componente.

 Puedes descargar el ejemplo completo desde [aquí](https://github.com/miguelghz/Intro-ReactJS).

## Resumen

 En este tutorial he tratado de mostrar el funcionamiento básico de ReactJS mientras he ido exponiendo los elementos fundamentales. Aunque he condensado bastante información en este artículo, me he dejado muchísimos elementos en el tintero. La idea es que esta entrada sirva como base a futuras publicaciones relacionadas con esta magnifica librería.

 Espero haber facilitado tu transición a ReactJS, si ya lo conocías espero que el artículo te sirva como referencia.

 Si te ha gustado la entrada valora y comparte en tus redes sociales. No dudes en comentar dudas, aportes o sugerencias, estaré encantado de responder.

 Este artículo se distribuye bajo una [Licencia Creative Commons Reconocimiento-CompartirIgual 4.0 Internacional (CC BY-SA 4.0)](https://creativecommons.org/licenses/by-sa/4.0/deed.es%5FES) 

[![licencia-cc](https://res.cloudinary.com/software-crafters/image/upload/v1544181784/licencia-cc.png)](https://creativecommons.org/licenses/by-sa/4.0/deed.es%5FES)",
    "slug": "tutorial-react-js-introduccion",
    "tags": [
      "react",
    ],
    "title": "Tutorial de React JS. Introducción",
    "userPicture": "",
    "username": "Miguel A. Gómez",
  },
  {
    "category": "python",
    "cover": "https://swcrafters.fra1.cdn.digitaloceanspaces.com/Categories/Python_category.png",
    "date": "",
    "description": "SOLID es un acrónimo creado por Michael Feathers para los principios publicados por Robert C. Martin. Son 5 principios que nos ayudarán a escribir mejor código.",
    "id": "principios-solid-python",
    "markdownBody": "El objetivo de este artículo es que el lector aprenda aplicar los principios SOLID con el lenguaje Python. SOLID es un acrónimo creado por [Michael Feathers](https://michaelfeathers.silvrback.com/ "Michael Feathers (page does not exist)") para los principios publicados por [Robert C. Martin](https://sites.google.com/site/unclebobconsultingllc/), en su libro [Agile Software Development: Principles, Patterns, and Practices](http://www.goodreads.com/book/show/84985.Agile%5FSoftware%5FDevelopment%5FPrinciples%5FPatterns%5Fand%5FPractices).

Se trata de cinco principios de diseño orientado a objetos que nos ayudarán a crear mejor código, más estructurado, con clases de responsabilidad más definida y más desacopladas entre sí:

* **S**ingle Responsibility: Responsabilidad única.
* **O**pen/Closed: Abierto/Cerrado.
* **L**iskov substitution: Sustitución de Liskov.
* **I**nterface segregation: Segregación de interfaz.
* **D**ependency Inversion: Inversión de dependencia.

Es importante resaltar que se trata de principios, no de reglas. Una regla es de obligatorio cumplimiento, en cambio, los principios son recomendaciones que pueden ayudar a hacer las cosas mejor. Además, siempre puedes encontrar algún contexto en el que te los puedas saltar, lo importante es hacerlo de forma consciente.

## Single Responsibility Principle (SRP)

> \\[bctt tweet="Nunca debería haber más de un motivo por el cual cambiar una clase"\\]

 El primero de los cinco principios, single responsibility principle o en castellano, principio de responsabilidad única, viene a decir que una clase debe tener tan solo una única responsabilidad. A finales de los 80, [Kent Beck](https://es.wikipedia.org/wiki/Kent%5FBeck) y [Ward Cunningham](https://es.wikipedia.org/wiki/Ward%5FCunningham), ya aplicaban este principio mediante tarjetas CRC (Class, Responsibility, Collaboration) con las que detectaban responsabilidades y colaboraciones entre clases.

 El principio responsabilidad única no se basa en diseñar clases con un sólo método, sino éstas tan sólo deberían tener una fuente de cambio. En otras palabras, aquellas clases que se vieran obligadas a cambiar ante una modificación en la base de datos y a la vez ante un cambio en la lógica de negocio, tendría más de un motivo para cambiar, es decir, más de una responsabilidad.

 Este principio se suele incumplir cuando en una misma clase están involucradas varias capas de la arquitectura. Veamos un ejemplo:

\`\`\`
class Vehicle(object):
    def __init__(self, name):
        self._name = name
	self._persistence = MySQLdb.connect()
        self._engine = Engine()

    def getName():
        return self._name()

    def getEngineRPM():
        return self._engine.getRPM()

    def getMaxSpeed():
        return self._speed

    def print():
    return print ‘Vehicle: {}, Max Speed: {}, RMP: {}’.format(self._name, self._speed, self._engine.getRPM())
\`\`\`

 A primera vista se puede detectar que estamos mezclando tres capas muy diferenciadas: la lógica de negocio, la lógica de presentación y la lógica de persistencia. Además estamos instanciando la clase \`engine\` dentro de \`vehicle\`, así que también nos estamos saltando el principio de inversión de dependencias.

 Una solución para el problema de las múltiples responsabilidades de la clase anterior, podría pasar por abstraer dos clases, como por ejemplo \`VehicleRepository\` para manejar la persistencia y \`VehiclePrinter\` para gestionar la capa de presentación.

\`\`\`
class Vehicle(object):
    def __init__(self, name, engine):
        self._name = name
        self._engine = engine

    def getName(self):
        return self._name()

    def getEngineRPM(self):
        return self._engine.getRPM()

    def getMaxSpeed(self):
        return self._speed


class VehicleRepository(object):
    def __init__(self, vehicle, db)
        self._persistence = db
        self._vehicle = vehicle


class VehiclePrinter(object):
    def __init__(self, vehicle, db)
        self._persistence = db
        self._vehicle = vehicle

    def print(self):
    return print ‘Vehicle: {}, Max Speed: {}, RMP: {}’.format(self._vehicle.getName(), self._vehicle.getMaxSpeed(), self._vehicle.getRPM())
\`\`\`

 En este caso se veía muy claro lo que teníamos que hacer para aplicar correctamente el SRP, pero muchas veces los detalles serán más sutiles y probablemente no los detectarás a la primera. No te obseciones simplemente aplica el sentido común.

## Open-Closed Principle (OCP)

> "Todas las entidades software deberían estar abiertas a extensión, pero cerradas a modificación"

El segundo de los principios, Open-Closed (Abierto/Cerrado), cuyo nombre se lo debemos a [Bertrand Meyer](https://bertrandmeyer.com/bio/). Básicamente nos recomienda que cuando se pretende introducir un nuevo comportamiento en un sistema existente, en lugar de modificar las clases antiguas, se deben crear nuevas mediante herencia y redefinición de los métodos de la clase padre (polimorfismo), o inyectando dependencias que implementen el mismo contrato.

Este principio promete mejoras en la estabilidad de tu aplicación al evitar que los objetos existentes cambien con frecuencia, lo que también hace que las cadenas de dependencia sean un poco menos frágiles ya que habría menos partes móviles de las que preocuparse. Este principio aplica bien a la hora trabajar con un framework o con código legacy, evidentemente si el código lo has hecho tu o tu equipo, refactoriza.

 Un buen ejemplo en el que se aplica este principio es el que veíamos en [ este artículo ](https://miguelgomez.io/django/extender-user-django/#AbstractUser) a la hora de [ extender el user de django ](https://miguelgomez.io/django/extender-user-django/#AbstractUser) desde la clase \`AbstractUser\` 

\`\`\`
from django.db import models

from django.db import models
from django.contrib.auth.models import AbstractUser

class User(AbstractUser):
    bio = models.TextField(max_length=500, blank=True)
    location = models.CharField(max_length=30, blank=True)
    birth_date = models.DateField(null=True, blank=True)

\`\`\`

## Liskov Substitution Principle (LSP)

> "Las funciones que utilicen punteros o referencias a clases base deben ser capaces de usar objetos de clases derivadas sin saberlo." username="unclebobmartin"

 El principio de Sustitución de Liskov, obtiene su nombre de [Barbara Liskov](https://es.wikipedia.org/wiki/Barbara%5FLiskov). Este principio está relacionado con el anterior en lo que a la extensibilidad de las clases se refiere, y viene a decir que dada una instancia de una clase B, siendo esta un subtipo de una clase A, debemos poder sustituirla por una instancia de la clase A sin mayor problema.

 En los lenguajes orientados a objetos de tipado estático, este principio describe principalmente una regla sobre una relación entre una subclase y una superclase. Cuando hablamos de lenguajes de tipado dinámico como Python, nos interesa qué mensajes responde ese objeto en lugar de a qué clase pertenece.

 Un ejemplo que ilustra bastante bien la importancia de este principio es el de tratar de modelar un cuadrado como la concreción de un rectángulo:

\`\`\`
class Rectangle(object):

    def getWidth(self)
        return _width

    def setWidth(self, width)
        self._width = width

    def getHeight(self)
        return _height

    def setHeight(self, height)
        self._height = height

    def calculateArea(self)
        return self._width * self._height;

class Square(Rectangle):
    def setWidth(self, width)
        self._width = width
        self._height = height

    def setWidth(self, height)
        self._height = height
        self._width = width

class TestRectangle(unittest.TestCase):

    def setUp(self):
        pass

    def test_calculateArea(self):
        r = Rectangle()
        r.setWidth(5);
        r.setHeight(4);
        self.assertEqual(r.calculateArea(), 20)

\`\`\`

 Si tratamos de sustituir en el test el rectángulo por un cuadrado, el test no se cumple, ya que el resultado sería 16 en lugar de 20\\. Estaríamos por tanto violando el principio de sustitución de Liskov.

 La regla principal para no violar este principio es básicamente tratar de heredar lo menos posible o no usar los mixins a menos que se esté bastante seguro de que el comportamiento que está implementando no interferirá con las operaciones internas de sus ancestros.

## Interface Segregation Principle (ISP)

> "Los clientes no deberían estar obligados a depender de interfaces que no utilicen."

 El principio de segregación de la interfaz nos indica que ninguna clase debería depender de métodos que no usa. Cuando creemos interfaces (clases en lenguajes interpretados como Python) que definan comportamientos, es importante estar seguros de que todas los objetos que implementen esas interfaces/clases se vayan a necesitar, de lo contrario, es mejor tener varias interfaces/clases pequeñas.

 Una forma de no violar este principio en Python es aplicando [**duck typing**](https://en.wikipedia.org/wiki/Duck%5Ftyping#In%5FPython). Este concepto viene decir que los métodos y propiedades de un objeto determinan su validez semántica, en vez de su jerarquía de clases o la implementación de una interfaz específica.

## Dependency Inversión Principle (DIP)

> "Los módulos de alto nivel no deben depender de módulos de bajo nivel. Ambos deben depender de abstracciones. "

> "Las abstracciones no deben depender de concreciones. Los detalles deben depender de abstracciones."

 Quinto y último de los principios, la inversión de dependencia, cuyo objetivo principal es desacoplar nuestro código de sus dependencias directas. Este principio viene a decir que las clases de las capas superiores no deberían depender de las clases de las capas inferiores, sino que ambas deberían depender de abstracciones. A su vez, dichas abstracciones no deberían depender de los detalles, sino que son los detalles los que deberían depender de las mismas.

 La inversión de dependencias da origen a la inyección de dependencias. Este concepto se basa en hacer que una clase A inyecte objetos en una clase B en lugar de dejar que sea la propia clase B la que se encargue de instanciar el objeto. Veamoslo con el ejemplo del vehiculo:

\`\`\`
class Engine(object):
    def __init__(self):
        pass

    def accelerate(self):
        pass

    def getRPM(self):
        currentRPM = 0
        #...
        return currentRPM

class Vehicle(object):
    def __init__(self):
        self._engine = Engine()

    def getEngineRPM(self)
        return self._engine.getRPM();

\`\`\`

 El código anterior ilustra la manera “habitual” de definir la colaboración entre clases. Como podemos observar, existe una clase \`Vehicle\` que contiene un objeto de la clase \`Engine\`. La clase \`Vehicle\` obtiene las revoluciones del motor invocando el método \`getEngineRPM\` del objeto Motor y devolviendo su resultado. Este caso se corresponde con una dependencia, el módulo superior \`Vehicle\` depende del módulo inferior \`Engine\`, lo cual genera un código tremendamente acoplado y dificil de testear.

 Para desacoplar la dependencia \`Engine\` de \`Vehicle\` debemos hacer que la clase \`Vehicle\` deje de responsabilizarse de instanciar el objeto \`Engine\`, inyectándolo como parámetro al constructor, evitando así que la responsabilidad recaiga sobre la propia clase. De este modo desacoplamos ambos objetos, quedando la clase tal que así:

\`\`\`
class Vehicle(object):
    def __init__(self, engine):
        self._engine = engine

    def getEngineRPM(self)
    return self._engine.getRPM();
\`\`\`

 Ahora la responsabilidad de instanciar la clase \`engine\` ya no corresponde a la clase \`vehicule\`. Además, en Python, el parámetro \`engine\` no tiene porqué ser una instancia de la clase \`engine\`, podría ser cualquier objeto siempre y cuando tuviera un método \`getRPM()\`. Esta es una ventaja inherente a los lenguajes dinámicos, ya que nos permiten aprovechar el duck typing y evitar así tener que definir el tipo de la dependencia.

 Hasta ahora no he comentado nada de sobre los contenedores de inversión de control, aunque no es necesario para hacer inyección de dependencias, puede ser interesante su uso, sobre todo en los lenguajes de tipado estático. En los lenguajes dinámicos los contenedores de inversión de control pierden su interés ya que en los constructores de las clases no está especificado el tipo de las dependencias y si quieren usar estarás obligado a definir de forma un tanto forzada las dependencias entre los objetos para que el contenedor pueda componer unos con otros.

 Como hemos podido ver, la inyección de dependencias por si misma nos ayuda a crear clases con responsabilidad más definida, más estructuradas y desacopladas entre sí.

### Resumen

 Los prinpicios SOLID, pese al abuso que se hace últimamente de ellos, son una herramienta que nos ayudan a comprender mejor el diseño de software orientado a objetos. Si los aplicas con sentido común, sin dogmatizarlos, estarás en mejores condiciones para encontrar optimas soluciones a los problemas software.

 Si te ha gustado el artículo, valora y comparte en tus redes sociales. No dudes en comentar dudas, aportes o sugerencias, estaré encantado de responder.

 Este artículo se distribuye bajo una [Licencia Creative Commons Reconocimiento-CompartirIgual 4.0 Internacional (CC BY-SA 4.0)](https://creativecommons.org/licenses/by-sa/4.0/deed.es%5FES) 

[![licencia-cc](https://res.cloudinary.com/software-crafters/image/upload/v1544181784/licencia-cc.png)](https://creativecommons.org/licenses/by-sa/4.0/deed.es%5FES)",
    "slug": "principios-solid-python",
    "tags": [
      "python",
    ],
    "title": "Principios SOLID en Python",
    "userPicture": "",
    "username": "Miguel A. Gómez",
  },
  {
    "category": "xamarin",
    "cover": "https://swcrafters.fra1.cdn.digitaloceanspaces.com/Categories/Xamarin_category.png",
    "date": "",
    "description": "El patrón MVVM (Modelo Vista Vista-Modelo) nos ayuda a desacoplar lo máximo posible la interfaz de usuario de la lógica de la aplicación.",
    "id": "patron-mvvm-xamarin-forms",
    "markdownBody": "[En el anterior artículo](http://miguelgomez.io/xamarin/xamarin-forms-apps-nativas-introduccion/) vimos una breve introducción al **patrón de diseño MVVM**. Tal como decía en ese post, está considerado una buena práctica el uso de dicho patrón a la hora de desarrollar un proyecto, tanto con Xamarin tradicional, como con Xamarin Forms. El objetivo de esta entrada es continuar profundizando en el desarrollo con Xamarin Forms aplicando MVVM.

## Los orígenes de MVVM

En el año 2004, un grupo de desarrollo de Microsoft trabajaba en un proyecto denominado "Avalon", más conocido por su nombre definitivo WPF (Windows Presentation Foundation). El propósito de dicho proyecto era permitir el desarrollo de aplicaciones de escritorio más completas y con un aspecto visual mucho más logrado y complejo de lo que era posible con Windows Forms.

 Al año siguiente [John Gossman](https://www.linkedin.com/in/john-gossman-5664952) (miembro del equipo de desarrollo de "Avalon"), en un [artículo de la MSDN](https://blogs.msdn.microsoft.com/johngossman/2005/10/08/introduction-to-modelviewviewmodel-pattern-for-building-wpf-apps/), mostraba al público el patrón MVVM. En el artículo, MVVM se presenta como una variación del patrón MVC ajustado a "WPF" y a su sistema de enlace a datos, aunque realmente es una adaptación del patrón "presentation model" creado por el mítico [Martin Fowler](http://martinfowler.com/eaaDev/PresentationModel.html).

## Elementos del patrón MVVM

 La finalidad principal del patrón **MVVM** (Modelo Vista Vista-Modelo) es tratar de **desacoplar** lo máximo posible **la interfaz de usuario** de la lógica de la aplicación. Veamos a grandes rasgos sus partes principales:

### El modelo

 Representa la capa de datos y/o la lógica de negocio, también denominado como el objeto del dominio. El modelo contiene la información, pero nunca las acciones o servicios que la manipulan. En ningún caso tiene dependencia alguna con la vista.

### La vista

 La misión de la vista es representar la información a través de los elementos visuales que la componen. Las vistas en MVVM son activas, contienen comportamientos, eventos y enlaces a datos que, en cierta manera, necesitan tener conocimiento del modelo subyacente. En Xamarin Forms podemos crear nuestras interfaces a través de código C# o XAML.

### Modelo de vista (ViewModel)

 El **ViewModel** (modelo de vista) es un actor **intermediario** entre el modelo y la vista, contiene toda la **lógica de presentación** y se comporta como una abstracción de la interfaz. La comunicación entre la vista y el viewmodel se realiza por medio los enlaces de datos (**binders**).

![mvvm](https://res.cloudinary.com/software-crafters/image/upload/v1544443712/posts/patron-mvvm-xamarin-forms/mvvm.png) 

## MVVM en Xamarin Forms, interacción con el usuario

 Vamos a tomar como punto de partida el [ejemplo visto en la entrada anterior](http://miguelgomez.io/xamarin/xamarin-forms-apps-nativas-introduccion/), la idea es añadir a dicho ejemplo un elemento entry en el cual el usuario pueda introducir un texto y a su vez este se vaya reflejando en un elemento de tipo label.

 Contábamos con una estructura MVVM lo más sencilla posible, teníamos un ViewModel denominado MainViewModel con una propiedad llamada “MyMessage":

\`\`\`
public class MainViewModel
{
     private string _myMessage;

     public MainViewModel()
     {
          Message = "Hello MVVM!";
     }


     public string MyMessage
     {
          get { return _myMessage; }
          set { _myMessage = value; }
     }
}

\`\`\`

 Además, contabamos con una vista que utilizaba como contexto "MainViewModel" enlazando desde el atributo "text" de un label a la propiedad "MyMessage":

\`\`\`
//XAML
<?xml version="1.0" encoding="utf-8" ?>
<ContentPage xmlns="http://xamarin.com/schemas/2014/forms"
             xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
             x:Class="simpleMVVM.Views.MainView">
 <Label Text="{Binding MyMessage}"
        VerticalOptions="Center"
        HorizontalOptions="Center" />
</ContentPage>

//Code behind
namespace simpleMVVM.Views
{
    public partial class MainView : ContentPage
    {
        public MainView()
        {
            InitializeComponent();
            BindingContext = new MainViewModel();
        }
    }
}

\`\`\`

### Modos de enlace a datos

 Antes de continuar con el ejemplo veamos como funcionan los modos de enlace a datos. En Xamarin Forms el modo de enlace a datos se define con la palabra reservada "mode", la cual nos indica como se comporta el mismo. Contamos con los siguientes

* **OneWay:** es el valor por defecto, indica que el enlace se produce en un solo destino, el de lectura. Si el valor del elemento de la vista cambia, no enlazará con el ViewModel asociado.
* **OneWayToSource:** este valor enlaza en un único sentido la _View_ al _ViewModel_.
* **TwoWay:** en este caso indica que el enlace es bidireccional. En un primer momento, la vista toma el valor de la propiedad del ViewModel y si este cambia en la vista es enviado de vuelta hacia el ViewModel.

 Continuando con el ejemplo, vamos a añadir un elemento de tipo entry, que esté enlazado a la propiedad "myMessage" de forma bidireccional, un elemento label que está enlazado con el modo por defecto (oneWay) y un stacklayout que haces las veces de contenedor, debido a que las páginas no pueden contener más de un elemento.

\`\`\`
<?xml version="1.0" encoding="utf-8" ?>
<ContentPage
    xmlns="http://xamarin.com/schemas/2014/forms"
    xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
    x:Class="simpleMVVM.Views.MainView">
    <StackLayout>

        <Entry Text="{Binding MyMessage, Mode=TwoWay}"
              VerticalOptions="Center"
              HorizontalOptions="Center" />

        <Label Text="{Binding MyMessage}"
              VerticalOptions="Center"
              HorizontalOptions="Center" />

    </StackLayout>
</ContentPage>


\`\`\`

 Al hacer debug sobre el código anterior, observarás que aparentemente todo está funcionando correctamente. Si examinas el contenido de la propiedad My\`Message\` verás que el valor se ha actualizado correctamente, pero el texto del elemento label no se actualiza, esto es debido a que no se ha notificado a la vista que el valor de la propiedad ha cambiado. Es aquí donde entra en juego la interfaz **INotifyPropertyChanged**.

### Notificación de cambios (**INotifyPropertyChanged)**

 La interfaz **INotifyPropertyChanged** define un método llamado **RaisePropertyChanged** y un evento llamado **PropertyChanged,** que debemos implementar**.** Dicho evento será lanzado cuando se actualice el valor de la propiedad deseada del _ViewModel y notificará a_ la View que evaluará de nuevo el valor de dicha propiedad. Para que esto funcione correctamente es necesario ejecutar el método **RaisePropertyChanged** en el setter de la propiedad.

\`\`\`
public class MainViewModel
{
     private string _myMessage;

     public MainViewModel()
     {
          Message = "Hello MVVM!";
     }

     public string MyMessage
     {
          get { return _myMessage; }
          set
          {
               _myMessage = value;
               RaisePropertyChanged("MyMessage");
          }
     }

     private void RaisePropertyChanged(string propertyName)
     {
          var handle = PropertyChanged;
          if (handle != null)
               handle(this, new PropertyChangedEventArgs(propertyName));
     }

     public event PropertyChangedEventHandler PropertyChanged;
}

\`\`\`

 Dado que todos los ViewModels o la mayoría, van a hacer uso de la interfaz INotifyPropertyChanged, sería interesante crear un **ViewModel base**, del cual hereden demás. Por otro lado, vamos a hacer uso del atributo \`CallerMemberName\` con el cual aseguras que el nombre de la propiedad que llama al método RaisePropertyChanged es el correcto sin tener que indicarlo explícitamente.

\`\`\`
public class ViewModelBase
{
     private void RaisePropertyChanged([CallerMemberName] string propertyName = null)
     {
          var handle = PropertyChanged;
          if (handle != null)
               handle(this, new PropertyChangedEventArgs(propertyName));
     }

     public event PropertyChangedEventHandler PropertyChanged;
}


\`\`\`

Tras refactorizar el \`MainViewModel\` quedaría tal que así:

\`\`\`
public class MainViewModel : ViewModelBase
{
     private string _myMessage;

     public MainViewModel()
     {
     }

     public string MyMessage
     {
          get { return _myMessage; }
          set
          {
               _myMessage = value;
               RaisePropertyChanged();
          }
     }
}

\`\`\`

 Este sería el resultado, tras ejecutar el proyecto:

![binding2way](https://res.cloudinary.com/software-crafters/image/upload/v1544443711/posts/patron-mvvm-xamarin-forms/binding-2way.gif) 

### Comandos

 Nos faltaría por ver la interacción a priori más básica que puede realizar un usuario sobre una app, pulsar un botón y que ocurra algo. Para llevar a cabo esta funcionalidad se aplica el patrón **Command** (comando) cuyo objetivo no es otro que encapsular la invocación de un método de otro objeto.

> "Debes depender de abstracciones, no de concreciones"

 Para aplicar este mecanismo en Xamarin.Forms junto con MVVM el ViewModel asociado a la vista debe exponer una propiedad que implemente la interfaz \`ICommand\`. El valor de dicha propiedad puede ser asignado a elementos visuales como botones, a través de la propiedad **comando** vía enlace a datos. Esto a su vez ejecutará el método **Execute** de dicha interfaz, la cual además define un método **CanExecute** que permite verificar si el comando puede ser ejecutado o no.

 Al igual que ocurría con la implementación de la interfaz INotifyPropertyChanged, cuando utilizamos comandos se tiende a repetir más código del necesario, por esta razón se utilizan implementaciones reutilizables como **DelegateCommand**. Esta implementación es una clase que implementa la intefaz **ICommnad** que recibe dos parámetros en su constructor del tipo Action y Func, el método a ejecutar (**Execute**) y el método que indica si se puede ejecutar o no(**CanExecute**), respectivamente.

\`\`\`
public class DelegateCommand : ICommand
{
     private Action _execute;
     private Func<bool> _canExecute;

     public DelegateCommand(Action execute, Func<bool> canExecute = null)
     {
          _execute = execute;
          _canExecute = canExecute;
     }

     public bool CanExecute(object parameter)
     {
          if (_canExecute == null)
               return true;

          return _canExecute();
     }

     public event EventHandler CanExecuteChanged;

     public void Execute(object parameter)
     {
          if (_execute != null)
               _execute();
     }

     public void RaiseCanExecuteChanged()
     {
          var handle = CanExecuteChanged;
          if (handle != null)
               handle(this, new EventArgs());
     }
}

\`\`\`

 Si no estás muy familiarizado con C#, los tipos \`Action\` y \`Func<bool>\`, son delegados genéricos. \`Action\` simplemente es un delegado que no devuelve nada y en este caso tampoco recibe ningún parametro; y \`Func<bool>\`, tampoco tiene parámetros y en este caso devuelve un booleano. Por sino lo sabes, un delegado no es más que un tipo de dato que representa un puntero a un método.

 Continuando con el ejemplo, vamos a añadir a la view del ejemplo anterior un botón, el cual al ser pulsado incrementará un contador que se mostrará en el elemento label de la misma. Para ello se le asigna el commando MyCommand a la propiedad command del botón, el cual se implimentará en el correspondiente ViewModel.

\`\`\`
<?xml version="1.0" encoding="utf-8" ?>
<ContentPage
    xmlns="http://xamarin.com/schemas/2014/forms"
    xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
    x:Class="simpleMVVM.Views.MainView">
    <StackLayout>

        <Button Text="Sent"
              Command="{Binding MyCommand}"
              VerticalOptions="Center"
              HorizontalOptions="Center" />

        <Label Text="{Binding MyMessage}"
              VerticalOptions="Center"
              HorizontalOptions="Center" />

    </StackLayout>
</ContentPage>


\`\`\`

 En el \`MainViewModel\` se crea una propiedad del tipo \`ICommand\` denominada MyCommand, cuya variable privada será del tipo \`DelegateCommand\` que hemos implementado con anterioridad. En el getter de esta propiedad, se instanciará DelegateCommand recibiendo como parámetro el método que contiene la lógica para incrementar el contador, quedando el \`MainViewModel\` tal que así:

\`\`\`
public class MainViewModel : ViewModelBase
{
 	 private int _counter;
     private DelegateCommand _myCommand;

     void counterCommandExecute()
     {
     	  _counter++;
          RaisePropertyChanged("MyMessage");
     }

     public MainViewModel()
     {
     	_counter = 0;
     }

     public string MyMessage
     {
          get { return string.Format("{0} times", _counter); }
     }

     public ICommand MyCommand
     {
          get { return _myCommand = _myCommand ?? new DelegateCommand(counterCommandExecute); }
     }
}


\`\`\`

 Tras ejecutar la app se puede observar que al pulsar el botón el contador se va incrementando correctamente:

![comandos](https://res.cloudinary.com/software-crafters/image/upload/v1544443711/posts/patron-mvvm-xamarin-forms/commands.gif) 

## Resumen

 En este artículo se han expuesto los conceptos básicos para aplicar el patrón MVVM a la hora de realizar las interacciones básicas de los usuarios con Xamarin Forms, donde destacan las notificaciones y los comandos.

 Continuaré profundizando en próximas entradas en el desarrollo con Xamarin, seguiré exponiendo conceptos fundamentales como la navegación entre páginas, contenedores de dependencias, persistencia de datos en el dispositivo, consumo de APIS, etc.

 Si te ha gustado la entrada valora y comparte en tus redes sociales. No dudes en comentar dudas, aportes o sugerencias, estaré encantado de responder.

 Este artículo se distribuye bajo una [Licencia Creative Commons Reconocimiento-CompartirIgual 4.0 Internacional (CC BY-SA 4.0)](https://creativecommons.org/licenses/by-sa/4.0/deed.es%5FES) 

[![licencia-cc](https://res.cloudinary.com/software-crafters/image/upload/v1544181784/licencia-cc.png)](https://creativecommons.org/licenses/by-sa/4.0/deed.es%5FES)",
    "slug": "patron-mvvm-xamarin-forms",
    "tags": [
      "xamarin",
    ],
    "title": "El patrón MVVM en Xamarin Forms",
    "userPicture": "",
    "username": "Miguel A. Gómez",
  },
  {
    "category": "xamarin",
    "cover": "https://swcrafters.fra1.cdn.digitaloceanspaces.com/Categories/Xamarin_category.png",
    "date": "",
    "description": "Xamarin nos ofrece un enfoque multiplataforma diferente, ya que nos facilita la tarea de desarrollar cualquier tipo de aplicación de forma nativa.",
    "id": "xamarin-forms-apps-nativas-introduccion",
    "markdownBody": " Hoy en día, **crear aplicaciones** móviles para múltiples plataformas **supone** **todo un reto** para los desarrolladores. Tratar de abordar un desarrollo usando los toolkits nativos de cada sistema requiere de una cantidad enorme de conocimientos específicos para cada uno de ellos. Nos encontraremos con un **panorama** enormemente **complejo**, con **múltiples lenguajes**, **varios entornos de desarrollo** y **APIs** de todos los colores. **Xamarin** **trata de poner solución** a esta problemática ofreciéndonos un conjunto de herramientas que nos permitirá desarrollar **aplicaciones nativas, compartiendo** la mayor cantidad de **código**, entre las plataformas más importantes: **Android**, **iOS** y **Windows Phone**.

 Este **artículo** va dirigido a **desarrolladores** que estén **interesados** en comenzar a crear **aplicaciones cross-platform** **nativas** con Xamarin, sería recomendable que estuviesen familiarizados con el lenguaje **C#** y/o con el SDK de **iOS** o **Android**, aunque **no es imprescindible.** En la **primera parte** de la entrada trataré algunas **generalidades** como la problemática del desarrollo multiplataforma, las características claves de Xamarin, la instalación y puesta en marcha y la cuando elegir entre Xamarin Tradicional o Xamarin Forms. En la **segunda parte**me centraré en **Xamarin.Forms** y en sus elementos clave; por último, veremos una pequeña introducción a la implementación del **patrón MVVM en Xamarin Forms**.

## La problemática del desarrollo multiplataforma

 Como podemos observar en la siguiente tabla, cada plataforma cuenta con su **propio** entorno de desarrollo integrado (**IDE**), con uno o **varios lenguajes** de programación, con un lenguaje especifico para las **vistas,** y por si fuera poco los**patrones de diseño** a aplicar **difieren** **entre** las diferentes **plataformas**.

| iOS                  | Android            | Windows        |               |
| -------------------- | ------------------ | -------------- | ------------- |
| **IDE**              | XCode              | Android Studio | Visual Studio |
| **Lenguaje**         | ObjectiveC o Swift | Java           | C#            |
| **Vistas**           | Storyboard o XIBS  | AXML           | XAML          |
| **Patrón de diseño** | MVC                | MVC            | MVVM          |

 Abordar todos estos aspectos requiere de una cantidad de enorme de conocimientos por parte del desarrollador y, por otro lado, no parece ser eficiente tener que reescribir la lógica de negocio para cada uno de los sistemas.

### ¿Que opciones tenemos? Apps híbridas o nativas

Tradicionalmente, cuando hablamos de **tecnologías multiplataforma**, pensamos en un **enfoque minimalista**: reducir nuestra implementación/desarrollo a un mínimo denominador en todas las plataformas. Esto es lo que se propone en las **aplicaciones híbridas** desarrolladas con tecnologías del tipo PhoneGap/Cordova, en las cuales escribimos códigohtml y javascript que tiene que ser interpretado por un navegador web. Este tipo de soluciones **no consigue igualar** la respuesta y **la experiencia de usuario** de una app **nativa.** Por poner un ejemplo, Mark Zuckerberg (CEO de Facebook), reconoció que el mayor error que habían cometido en la trayectoria de Facebook fue crear en un primer momento una app híbrida en lugar de una nativa.

> Mark Zuckerberg: nuestro mayor error ha sido crear en un principio una app híbrida en lugar de nativa

**Xamarin** nos ofrece un enfoque multiplataforma diferente, ya que nos facilita la tarea de desarrollar cualquier tipo de **aplicación/juego** de forma **nativa** para las plataformas más usadas: **iOS, Android y Windows**. Para ello nos brinda acceso al **100% de las APIS nativas + las APIs comunes de .NET**, con un mismo lenguaje de programación**C#**.

 Existen **alternativas** interesantes a Xamarin que también proponen un enfoque nativo, como puede ser **[React Native](https://facebook.github.io/react-native/)** de Facebook (aún en beta) , que permite escribir apps para android e iOS Nativas en **Javascript** con el estilo de **React**. O, **[Ruby Motion](http://www.rubymotion.com/),** una tecnología que nos permite realizar apps para Android e iOS con **Ruby**, si RoR forma parte de tu stack esta plataforma es más que interesante. Aunque sin duda, por **aceptación**, **cuota, comunidad** y **evolución** brilla con luz propia **Xamarin**.

![reactnavive vs rubymotion](https://res.cloudinary.com/software-crafters/image/upload/v1544533330/posts/xamarin-forms-app-nativas-introduccion/React-Native-rubymotion-300x120.png) 

## Características

* **Compartir código:**Además de compartir un mismo lenguaje y entorno de desarrollo, podemos utilizar un mismo patrón de desarrollo.
* **Completa cobertura de las APIs de iOS y Android:** Tenemos todas las APIs disponibles con C#, cualquier cosa que se pueda hacer con Objective-C/Swift o Java, se puede hacer con C# y Xamarin.
![api-xamarin](http://miguelgomez.io/wp-content/uploads/2016/11/api-xamarin.png) 
* **Aplicaciones nativas:**Las aplicaciones desarrolladas con Xamarin son 100% nativas.
* **Siempre actualizado**: Xamarin suele añadir soporte el mismo día del lanzamiento oficial de una actualización.
* **Open source y gratis**: Tras la compra de Xamarin por parte de Microsoft, pasó a ser Open Source y gratuito.

## Instalación de Xamarin

**En Mac OS**

 Para instalar Xamarin en Mac OS, tan solo tenemos que [descargar el instalador ](https://www.xamarin.com/download)y a continuación un asistente nos guiará en la instalación de Xamarin Studio y los SDKs de las diferentes plataformas.

**En windows:**

 Para comenzar a trabajar con Xamarin en Windows se debe realizar la descarga de [Visual Studio Community](https://go.microsoft.com/fwlink/?LinkId=691978&clcid=0x409). Tras ejecutar el instalador tenemos la posibilidad de elegir entre una instalación típica o personalizada. Escogemos personalizada y seleccionamos el checkbox de Xamarin dentro del apartado de desarrollo móvil multiplataforma.

 Para compilar y acceder a opciones como el editor visual de iOS necesitamos de forma inevitable tener conexión con un Mac. Todo el proceso de conexión se realiza de forma prácticamente transparente desde Visual Studio a través de la herramienta Xamarin Mac Agent por medio de una conexión ssh.

## Xamarin Tradicional vs Xamarin Forms

 Antes de empezar a desarrollar con Xamarin debemos **elegir** si utilizar **Xamarin Tradicional**(Xamarin.iOS y Xamarin.Android) o **Xamarin Forms** para crear nuestro proyecto, aunque algunos expertos de la comunidad como [@\\_jmgomez\\_](https://twitter.com/%5Fjmgomez%5F) ya plantean algunas soluciones “fuera de la caja” ([artículo](http://jmgomez.me/with-xamarinforms-or-without-it/)).

 En **Xamarin tradicional**, se puede **compartir toda la lógica** de la aplicación entre las diferentes plataformas, **a excepción de la interfaz de usuario**, la cual será independiente para cada una de las mismas. En cambio, **Xamarin Forms** añade una capa de abstracción sobre la UI que **permite compartir**, además de la lógica de negocio, **la interfaz de usuario**, aumentando consigo la reutilización de código.

**¿Cuando escoger uno u otro?** 

**Xamarin tradicional** es idóneo cuando se requiere un nivel muy elevado de personalización de la interfaz de usuario para cada una de las plataformas, siendo **más importante el nivel personalización de la UI que la cantidad de código compartido**; mientras que **Xamarin.Forms** es la mejor opción cuando las aplicaciones requieren **menos especificidad en la UI** y hacen más **énfasis en compartir la mayor cantidad posible de código**.

![xamarin-1](https://res.cloudinary.com/software-crafters/image/upload/v1544533330/posts/xamarin-forms-app-nativas-introduccion/xamarin-1.png) 

## Xamarin Forms

 La capa de abstracción que añade Xamarin Forms a la UI nos facilita la tarea de crear interfaces de usuarios nativas compartidas, ya que cada uno de los elementos de dicha abstracción son mapeados a elementos propios de cada una de las plataformas.

### XAML

 Las interfaces en **Xamarin Forms** se pueden definir tanto con código **C#** desde **Code Behind,**como con **[XAML](https://msdn.microsoft.com/es-es/library/cc295302.aspx)**, mi recomendación es utilizar este último para aprovechar su enfoque de separación de responsabilidades entre diseño y codificación.

**XAML** (e**X**tensible **A**pplication **M**arkup **L**anguage) es un lenguaje declarativo basado en **XML** y pensado para escribir la interfaz gráfica de una aplicación de forma textual y ordenada, aparece por primera vez en la versión 3.0 del Framework de .NET.

 Una de las características más importantes de **XAML** es que **todos los elementos que definamos en este son instanciados por el CLR** y **quedan accesibles** como objetos **desde código**, sin necesidad de realizar de nuevo la declaración de los mismos en Code Behind, gracias al mecanismo de las clases parciales.

**XAML** permite construir la jerarquía de objetos de componen la interfaz. Con el uso de **etiquetas**podemos **definir cada uno de los elementos visuales**, y con el uso de **atributos definimos la apariencia y el comportamiento** de cada uno de los elementos.

 Veamos un ejemplo de una misma interfaz definida en XAML y C#:

\`\`\`
//XAML
    <TabbedPage xmlns="http://xamarin.com/schemas/2014/forms" xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml" x:Class="MyApp.MainPage">
    <TabbedPage.Children>
        <ContentPage Title="Profile" Icon="Profile.png">
            <StackLayout Spacing="20" Padding="20" VerticalOptions="Center">
                <Entry Placeholder="Username" Text="{Binding Username}"/>
                <Entry Placeholder="Password" Text="{Binding Password}" IsPassword="true"/>
                <Button Text="Login" TextColor="White" BackgroundColor="#77D065" Command="{Binding LoginCommand}"/>
            </StackLayout>
        </ContentPage>
        <ContentPage Title="Settings" Icon="Settings.png">
            
        </ContentPage>
    </TabbedPage.Children>
</TabbedPage>

//Code behind
using Xamarin.Forms;

var profilePage = new ContentPage {
    Title = "Profile",
    Icon = "Profile.png",
    Content = new StackLayout {
        Spacing = 20, Padding = 50,
        VerticalOptions = LayoutOptions.Center,
        Children = {
            new Entry { Placeholder = "Username" },
            new Entry { Placeholder = "Password", IsPassword = true },
            new Button {
                Text = "Login",
                TextColor = Color.White,
                BackgroundColor = Color.FromHex("77D065") }}}
};

var settingsPage = new ContentPage {
    Title = "Settings",
    Icon = "Settings.png",
    (...)
};

var mainPage = new TabbedPage { Children = { profilePage, settingsPage } };

\`\`\`

### Pages

 Las páginas son elementos contenedores que representan una pantalla de la aplicación. Xamarin.Forms.Page representa un ViewController en iOS, una Page en UWP, en Android cada página se comporta como un Activity, pero no lo son.

![xamarin forms pages](https://res.cloudinary.com/software-crafters/image/upload/v1544533330/posts/xamarin-forms-app-nativas-introduccion/Xamarin.Forms-Pages.png) 

**ContentPage:** es la página más simple, cuenta con una única vista donde añadir contenido.   
**MasterDetailPage:** gestiona dos paneles de información.  
**NavigationPage:** gestiona la navegación entre paginas.  
**TabbedPage:** facilita el acceso a las subpáginas mediante tabs.  
**TemplatedPage:** muestra el contenido a pantalla completa, permite utilizar plantillas para definir el contenido.  
**CarouselPage:** permite el acceso a las subpáginas haciendo un gesto de scroll lateral.

### **Layouts**

 Los layouts son elementos contenedores de otros layouts o vistas, son especialmente necesarios ya que las páginas sólo contener un elemento hijo. Lo utilizaremos para establecer la posición y alineación de los elementos que contienen.

![xamarin forms layouts](https://res.cloudinary.com/software-crafters/image/upload/v1544533330/posts/xamarin-forms-app-nativas-introduccion/Xamarin.Forms-Layouts.png) 

 Los más destacados son:  
**ContentView:** permitir crear elementos más complejos a partir del mismo.  
**ScrollView:** si el contenido lo requiere permite hacer scroll.  
**StackLayout:** organiza y posiciona otros controles, es uno de los layouts más utilizados, por defecto los apila verticalmente.  
**AbsoluteLayout:** hace uso posiciones absolutas para posicionar los elementos.  
**GridLayout:** Permite la organización de elementos por medio de filas y columnas.  
**RelativeLayout:** facilita el posicionamiento de los elementos mediante constraints.  

### Views (controles)

 Las Views, también denominados controles o widgets, hacen referencia a los elementos visuales como pueden ser botones, labels, o textboxs. Xamarin Forms nos provee de multiples views:

![xamarin forms views](https://res.cloudinary.com/software-crafters/image/upload/v1544533330/posts/xamarin-forms-app-nativas-introduccion/controls-xamarin-1024x367.png) 

 Puedes ver la descripción de cada uno de los controles y como se visualizan en las diferentes plataformas desde [aquí](https://developer.xamarin.com/guides/xamarin-forms/controls/views/).

## Creando nuestra primera app Xamarin.Forms

 Para crear nuestra app abrimos Visual Studio o Xamarin Studio, dependiendo si estáis en Windows o Mac, respectivamente, en mi caso voy a usar Xamarin Studio. A continuación, nos dirigimos a nueva solución para crear un nuevo proyecto partiendo de la plantilla de aplicación multiplataforma “Forms App”:

![xamarin forms 1](https://res.cloudinary.com/software-crafters/image/upload/v1544533330/posts/xamarin-forms-app-nativas-introduccion/app-xamarin-forms-1.png) 

 En la siguiente pantalla del asistente rellenamos los campos del nombre de la app y del identificador de la organización, seleccionamos las plataformas Android e iOS, en el caso de estar en Visual Studio también podriamos incluir en nuestro proyecto UWP.

### Shared Project (SP) vs Portable Class Library (PCL)

 Seguidamente nos encontramos con que debemos escoger entre un SP (**Shared Projec**t) y una PCL (**Portable Class Library**). Aunque ambos persiguen el **mismo objetivo**, **compartir la mayor cantidad posible de código** entre plataformas, difieren en varios aspectos.

**Las PCL** a diferencia de los SP, **generan un asembly reutilizable (dll) que puede ser consumido fuera de la solución**. Es importante tener en cuenta que en las PCL no se tiene acceso completo al framework de .NET.

**Los SP no se compilan como un ensamblado a parte**,**sino como parte de cada proyecto al que están referenciado**, como si fuese código del propio proyecto. Los SP permiten hacer uso de directivas que permiten generar código especifico para cada una de las plataformas.  
 En nuestro caso usaremos la PCL:

![xamarin forms 2](https://res.cloudinary.com/software-crafters/image/upload/v1544533330/posts/xamarin-forms-app-nativas-introduccion/app-xamarin-forms-2.png) 

### Estructura de una solución Xamarin.Forms

 Una vez finalizado el asistente, se generará una solución estructurada en tres proyectos:

![xamarin forms 3](https://res.cloudinary.com/software-crafters/image/upload/v1544533330/posts/xamarin-forms-app-nativas-introduccion/app-xamarin-forms-3.png) 

 El primero de los proyectos corresponde a la PCL, el cual contendrá el código compartido de la aplicación para todas las plataformas. A continuación tenemos los proyectos específicos de iOS y Android.

 En el proyecto compartido, a modo de ejemplo se ha generado una página llamada helloFormsPage que cuenta con un elemento de tipo ContentPage que a su vez contiene un control Label en el que se muestra un texto de bienvenida.

 HelloFormsPage está formado por dos ficheros por un lado tenemos el XAML y por otro el code behing en C# los cuales corresponden a una misma clase distribuida en dos ficheros, a este concepto se le denomina **clases parciales.** Por lo tanto el **XAML** no **es** más que **una clase parcial de nuestro Code Behind**, que se completa con el fichero que lleva el mismo nombre que el XAML pero con la extensión .cs.

\`\`\`
<?xml version="1.0" encoding="utf-8"?>
<ContentPage xmlns="http://xamarin.com/schemas/2014/forms"
        xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
        xmlns:local="clr-namespace:helloForms"
        x:Class="helloForms.helloFormsPage">
    <Label Text="Welcome to Xamarin Forms!" VerticalOptions="Center" HorizontalOptions="Center" />
</ContentPage>


\`\`\`

 En el proyecto compartido, además de contar con la clase de ejemplo helloFormsPage, tenemos una clase llamada App, en la cual se indica cual será la primera página a mostrar en todas las plataformas, esto se realiza en el constructor de la misma. Además cuenta con otros métodos que nos permiten ejecutar acciones según el estado de la aplicación.

\`\`\`
namespace helloForms
{
    public partial class App : Application
    {
        public App()
        {
            InitializeComponent();
            MainPage = new helloFormsPage();
        }
        protected override void OnStart()
        {
            // Handle when your app starts
        }
        protected override void OnSleep()
        {
            // Handle when your app sleeps
        }
        protected override void OnResume()
        {
            // Handle when your app resumes
        }
    }
}

\`\`\`

 En el proyecto de Android tenemos una clase denominada MainActivity que cuenta con un método OnCreate() en el cual inicializamos la app del proyecto compartido:

\`\`\`
namespace helloForms.Droid
{
    [Activity(Label = "helloForms.Droid", Icon = "@drawable/icon", Theme = "@style/MyTheme", MainLauncher = true, ConfigurationChanges = ConfigChanges.ScreenSize | ConfigChanges.Orientation)]
    public class MainActivity : global::Xamarin.Forms.Platform.Android.FormsAppCompatActivity
    {
        protected override void OnCreate(Bundle bundle)
        {
            TabLayoutResource = Resource.Layout.Tabbar;
            ToolbarResource = Resource.Layout.Toolbar;
            base.OnCreate(bundle);
            global::Xamarin.Forms.Forms.Init(this, bundle);
            LoadApplication(new App());
        }
    }
}

\`\`\`

 Por último, en iOS, disponemos de la clase AppDelegate en la cual cargaremos la app del proyecto compartido:

\`\`\`
namespace helloForms.iOS
{
    [Register("AppDelegate")]
    public partial class AppDelegate : global::Xamarin.Forms.Platform.iOS.FormsApplicationDelegate
    {
        public override bool FinishedLaunching(UIApplication app, NSDictionary options)
        {
            global::Xamarin.Forms.Forms.Init();
            LoadApplication(new App());
            return base.FinishedLaunching(app, options);
        }
    }
}

\`\`\`

 Si, ejecutamos el proyecto en los emuladores de iOS y Android obtendríamos el siguiente resultado:

![xamarin forms 4](https://res.cloudinary.com/software-crafters/image/upload/v1544533330/posts/xamarin-forms-app-nativas-introduccion/app-xamarin-forms-4.png) 

## El patrón MVVM en Xamarin Forms

 Aunque no es obligatorio utilizar el patrón MVVM para desarrollar una aplicación con Xamarin Forms, está considerado una buena práctica hacer uso del mismo. A continuación veremos algunos conceptos claves para entender el por qué.

**MVVM** (Modelo Vista Vista-Modelo) **es un patrón de diseño** derivado de MVC, cuyo **objetivo** es tratar de **desacoplar** al máximo **la interfaz de usuario** de la lógica de la aplicación, para ello hace uso de un lenguaje de marcado en las vistas, XAML en el caso de Xamarin Forms. El **modelo** realiza la misma función que en MVC, representa la**capa de datos** y/o la lógica de negocio de nuestro proyecto, en ningún caso tiene dependencia alguna de la vista.

 El **ViewModel** (modelo de vista) es un actor **intermediario** entre el modelo y la vista, contiene toda la **lógica de presentación** y se comporta como una abstracción de la interfaz. La comunicación entre la vista y el viewmodel se realiza por medio los enlaces de datos (**binders**).

![mvvm 1](https://res.cloudinary.com/software-crafters/image/upload/v1544533331/posts/xamarin-forms-app-nativas-introduccion/mvvm-1-1500x482_1.png) 

 A continuación vamos a crear un ejemplo sencillo para mostrar como implementar en una solución Xamarin forms el patrón MVVM.

 Vamos a partir de un nuevo proyecto Xamarin.Forms utilizando una librería portable. En la PCL creamos las carpetas Views, ViewModels, y dentro de ViewModels la carpeta Base. Quedando la estructura de la solución tal que así:

![mvvm 2](https://res.cloudinary.com/software-crafters/image/upload/v1544533330/posts/xamarin-forms-app-nativas-introduccion/mvvm-2.png) 

 Una vez creadas las carpetas, añadimos la página principal, para ello hacemos clic derecho sobre la carpeta Views, le damos a la opción agregar nuevo archivo, seleccionamos “Forms ContentPage”, lo llamamos MainView y añadimos el siguiente código:

\`\`\`
<?xml version="1.0" encoding="utf-8" ?>
<ContentPage xmlns="http://xamarin.com/schemas/2014/forms"
xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
x:Class="simpleMVVM.Views.MainView">
     <Label Text="{Binding MyMessage}"
          VerticalOptions="Center"
          HorizontalOptions="Center" />
</ContentPage>

\`\`\`

 En el XAML anterior podemos observar que en el atributo text del elemento Label hemos utilizado lo que se denomina una expresión de enlace a datos, en próximos posts veremos con más detalle su funcionamiento por ahora nos basta con saber que cuando el compilador se encuentra con una expresión entre llaves la interpreta,y, en este caso, al encontrarse con la palabra reservada **Binding**, lo que hace es enlazar el valor de la propiedad MyMessage la cual definiremos en el ViewModel.

 Lo siguiente que vamos a hacer es crear nuestro primer ViewModel. Un **ViewModel** no es más que una **clase** en la que se expone la información **con propiedades públicas**. Por lo tanto, agregamos dentro de la carpeta ViewModels una clase a la que vamos a denominar MainViewModel con una propiedad llamada “MyMessage”:

\`\`\`

    public class MainViewModel
{
     private string _myMessage;

     public MainViewModel()
     {
          Message = "Hello MVVM!";
     }


     public string MyMessage
     {
          get { return _myMessage; }
          set { _myMessage = value; }
     }
}

\`\`\`

 A continuación, tenemos que enlazar nuestro ViewModel con el contexto de datos de la página. Para ello asignamos en la propiedad BindingContext de la nuestra vista una instancia de nuestro ViewModel. El **Code Behind** de la vista quedaría así:

\`\`\`
namespace simpleMVVM.Views
{
    public partial class MainView : ContentPage
    {
        public MainView()
        {
            InitializeComponent();
            BindingContext = new MainViewModel();
        }
    }
}

\`\`\`

 Por último, tan solo nos queda indicar cual es la página principal en la propiedad MainPage de la clase App:

\`\`\`
public App()
{
    InitializeComponent();
    MainPage = new MainView();
}

\`\`\`

 Esta sería la estructura MVVM más sencilla posible, en principio nos sirve para ilustrar los fundamentos básicos. No obstante, **no hemos cubierto** conceptos como **los modos de enlace a datos**, **las notificaciones** y **los comandos**, imprescindibles para conseguir una de interacción completa del usuario, quedarán pendientes para próximas entradas.

## Resumen

 En este artículo he tratado de sentar las bases, en la medida de lo posible, de Xamarin y en particular de Xamarin Forms, me he dejado muchos temas en el tintero, y en otros he sido muy superficial, cómo por ejemplo en la introducción del patrón MVVM, pero el post estaba creciendo exponencialmente.

 La idea es continuar profundizando en próximas entradas en el desarrollo con Xamarin, tanto tradicional como con forms. Espero haber facilitado tu transición a Xamarin, o por lo menos haber sabido trasladarte alguna de sus virtudes.

 Si te ha gustado la entrada valora y comparte en tus redes sociales. No dudes en comentar dudas, aportes o sugerencias, estaré encantado de responder.

 Este artículo se distribuye bajo una [Licencia Creative Commons Reconocimiento-CompartirIgual 4.0 Internacional (CC BY-SA 4.0)](https://creativecommons.org/licenses/by-sa/4.0/deed.es%5FES) 

[![licencia-cc](https://res.cloudinary.com/software-crafters/image/upload/v1544181784/licencia-cc.png)](https://creativecommons.org/licenses/by-sa/4.0/deed.es%5FES)",
    "slug": "xamarin-forms-apps-nativas-introduccion",
    "tags": [
      "xamarin",
    ],
    "title": "Xamarin Forms, apps nativas multiplataforma. Introducción",
    "userPicture": "",
    "username": "Miguel A. Gómez",
  },
  {
    "category": "python",
    "cover": "https://swcrafters.fra1.cdn.digitaloceanspaces.com/Categories/Python_category.png",
    "date": "",
    "description": "Python un lenguaje multiparadigma, que soporta orientación a objetos, programación imperativa y, en menor medida, programación funcional.",
    "id": "tutorial-de-python-introduccion",
    "markdownBody": " Antes de empezar tengo que advertirte que **ningún lenguaje** de programación, por simple que sea, **puede aprenderse** en profundidad **en tan poco tiempo**, a no ser que se requiera de experiencia previa en otros lenguajes. Dominar **la programación precisa de experiencia**, lo cual a su vez requiere de un tiempo mínimo que permita **afianzar las estructuras mentales** necesarias para entender la secuencia lógica a seguir para **desarrollar** un programa o proyecto de software.

 El objetivo de este artículo no es enseñar a programar, sino tratar de exponer en 10 minutos los elementos más importantes del lenguaje **Python**, sería algo así como una mezcla entre un **tutorial** y una **cheatsheet**. Haré uso de una **REPL** para exponer los **ejemplos**, con lo que **podrás modificar** y jugar con ellos sin tener que salir de la entrada. Es totalmente recomendable seguir el artículo en un ordenador o tablet, ya que la REPL por limitaciones de espacio no es tan cómoda de utilizar en un móvil.

### Características de Python

**Python** un lenguaje **multiparadigma**, que soporta **orientación a objetos**, **programación imperativa** y, en menor medida, **programación funcional**. Es **interpretado**, de tipado **dinámico** y **multiplataforma**.

### Lo básico de Python

 La **sintaxis** de Python es extremadamente "**limpia**", no se requiere de ningún caracter que indique el final de una secuencia y los bloques se definen a través de la **indentación** **del** **código**. Los **comentarios** de una sola línea se definen con el carácter almohadilla **(#)** y las cadenas de multiples líneas **(""")** se suelen emplear para escribir comentarios multilínea.

 Los **operadores aritméticos** **+**, **\\-** y **/** significan en Python lo mismo que en matemáticas. El asterisco **(\\*)** es el símbolo para la multiplicación, el **%** se usa para obtener el **módulo**, **//** para **división entera** y **\\*\\*** es el símbolo para las **potencias**. También disponemos de los operadores **incrementar** **(+=)** y **decrementar** **(-=)**.

 Existen tres **operadores lógicos**: **and**, **or**, y **not**. La semántica (significado) de estos operadores es similar a sus significados en inglés (en español “y”, “o” y “no”).

 La **asignación** de valores, como en la mayoría de lenguajes, se realiza con el símbolo "igual" **(=)**. La doble igualdad **(==)** se usa para comprobar que **dos valores son iguales**, además disponemos de estos **operadores de comparación**: distinto que **(!=)**, mayor que **(>)**, menor que **(<)**, mayor o igual **(>=)** y menor o igual **(<=)**.

### Tipos de datos

 Los tipos de datos básicos en Python son los **numéricos** formados por **enteros**, los **reales** y los **complejos**; las **cadenas de texto** y los **booleanos**. La función **type** nos devuelve el tipo:

### Estructuras de control de flujo

 Las **sentencias de control de flujo**, son bloques de código en los que se agrupan instrucciones de manera controlada. Por un lado tenemos las **estruturas condicionales** (**if, if .. else, if ..elif ..else**) y por otro las **estructuras iterativas** (**for, while**).

### Funciones

 Una **función** no es más que un bloque de código reutilizable encargado de realizar una determinada tarea. Para definir una función en Python debemos utilizar la palabra reservada "**def**" seguido del nombre de la función y los parámetros los indicamos entre parentesis. Veamos varios ejemplos:

### Funciones, parametros \\*args y \\*\\*kwargs

 En el ejemplo anterior hemos visto varias formas de definir y ejecutar a las funciones en Python, ya sea con parámetros por con valores por defecto o keywords como argumentos. Nos faltaría ver como llamarlas con **colecciones como argumentos**, una forma muy común de pasar valores a las funciones en Python, y que en muchas ocasiones cuesta entender. Para ello debemos tener claro que las **tupla** como colección de argumentos se define con **\\*args** y el **diccionario** con **\\*\\*kwargs. Veamos un ejemplo en la REPL:** 

### Manipulación de cadenas

 Las cadenas en Python pueden definirse entre comillas simples o dobles. En la REPL se muestra un ejemplo de la mayoría de las operaciones que podemos realizar ellas:

### Estructuras de datos (colecciones)

 Las **colecciones** son un tipo de datos diseñados específicamente para **agrupar objetos** y llevar a cabo tareas con ellos. Las estructuras de datos más utilizadas en Python son las **listas**, **tuplas** (listas inmutables) y los **diccionarios**, aunque personalmente también suelo usar mucho los **conjuntos** (sets).

 No todas las estructuras de datos exponen exactamente las mismas operaciones, por ejemplo una lista no deja buscar por clave (si bien sí por índice) y un conjunto no deja buscar ni por una cosa ni por otra.

 El siguiente playground está dividido en tres ficheros, main.py desde el que se importa listas.py y diccionarios.py, para ver los resultados de uno u otro, elimina o comenta su respectivo import.

### Clases y objetos

 En programación orientada a objetos (POO), **un objeto** es una entidad que **agrupa un estado y una funcionalidad** relacionada. El estado se define a través de las variables denominadas atributos y la funcionalidad a través de funciones denominadas en POO cómo métodos. Por otro lado, **una clase,** no es más que una plantilla genérica a partir de la cuál instanciamos los objetos. Dicho de otra manera, una clase **es una abstracción en la que se define el comportamiento** que va a tener el objeto.

 En Python, las **clases** se declaran mediante la palabra reservada **class** seguida del nombre de la clase, la clase base de la cual hereda, si no extiende de ninguna debe hacerlo de **object**; a continuación dos puntos (:), luego el indentado y el cuerpo de la clase.

 El método **constructor** de la clase se define con la palabra clave **\\_\\_init\\_\\_** y al igual que el resto de métodos definidos en la clase recibe como primer parámetro **self**, el interprete de python requiere de este argumento para referenciarlos como métodos de instancia.

### Excepciones

 No soy muy fan de usar excepciones, pero es cierto que con Python hay momentos en los que su uso no se puede obviar. Las **excepciones** en Python se manejan esencialmente con **try-except**:

### Depurando con PDB

 El **depurador por defecto** de python es **[pdb](https://docs.python.org/3/library/pdb.html)** , nos permite inspeccionar nuestro código de forma interactiva. La forma más simple de utilizarlo es ejecutando \`pdb.set_trace()\`:

\`\`\`
import pdb
a = "aaa"
pdb.set_trace()
b = "bbb"
c = "ccc"
final = a + b + c
print final

\`\`\`

 Los comandos básicos del depurador son: "**n**"(next) para ejecutar la **siguiente sentencia,** para **mostrar el valor** de las variables "**p**"(print), si queremos ir **paso a paso** dentro de las subrutinas utilizariamos "**s**"(step), y por último **"q"**(quit) para **salir**.

### Guia de estilo - PEP8

 En Python existen las denominadas PEP's (Python Enhancement Proposals), en concreto la PEP 8 hace referencia a las convenciones de estilo de programación en Python.

 Entre las convenciones principales, destacan:

* Usar 4 espacios para indentar.
* Tamaños de línea con un máximo de 79 caracteres.
* Las funciones y las clases se deben separar con dos lineas en blanco, mientras que los métodos de clase solo con uno.
* Los import deben de estar separados uno en cada línea. Se permite: \`from urllib2 import urlopen, Request\`
* Las sentencias import deben de estar siempre en la parte superior del archivo agrupadas de la siguiente manera:  
   * Librería estándar  
   * Librerías de terceros  
   * import's de la aplicación local
* Usar espacios alrededor de los operadores aritméticos, a excepción de cuando forman parte de los argumentos de una función.
* No se deben de realizar comentarios obvios
* No se deben comparar booleanos mediante \` ==\`

### Resumen

 Este tutorial no pretende ser una guía exhaustiva sobre Python, aunque he condensado bastante información en poco más de 1000 palabras, me he dejado muchísimos elementos en el tintero, cómo expresiones regulares, ficheros, testing, POO, elementos de programación funcional.

 Espero haber facilitado tu transición a Python, y si ya lo conocías espero que el artículo te sirva como referencia. Si te ha gustado la entrada valora y comparte en tus redes sociales. No dudes en comentar dudas, aportes o sugerencias, estaré encantado de responder.

 Este artículo se distribuye bajo una [Licencia Creative Commons Reconocimiento-CompartirIgual 4.0 Internacional (CC BY-SA 4.0)](https://creativecommons.org/licenses/by-sa/4.0/deed.es%5FES) 

[![licencia-cc](https://res.cloudinary.com/software-crafters/image/upload/v1544181784/licencia-cc.png)](https://creativecommons.org/licenses/by-sa/4.0/deed.es%5FES)",
    "slug": "tutorial-de-python-introduccion",
    "tags": [
      "python",
    ],
    "title": "Tutorial de Python. Los fundamentos en 10 minutos",
    "userPicture": "",
    "username": "Miguel A. Gómez",
  },
  {
    "category": "devops",
    "cover": "https://res.cloudinary.com/software-crafters/image/upload/v1544894788/posts/servidor-desarrollo-vagrant-ansible/django-vagrant.png",
    "date": "",
    "description": "",
    "id": "servidor-desarrollo-vagrant-ansible",
    "markdownBody": "**Vagrant** es una de esas herramientas que a priori parece que no tiene cabida en tu stack, pero una vez que comienzas a utilizarla se vuelve indispensable. [En una entrada anterior](http://miguelgomez.io/devops/instancias-de-digitalocean-con-vagrant/) vimos como hacer uso de la misma con el driver de Digital Ocean**,** en ese caso para desplegar Droplets, aunque el objetivo principal de esta herramienta es crear **entornos** de **desarrollo** **aislados**.

 Vagrant permite que el **abastecimiento** de las máquinas a través de un script Bash o por medio de cualquier herramienta de orquestación tipo **Puppet**, **Salt**, **Cheff** o **Ansible**. En esta ocasión utilizaremos Ansible para el aprovisionar nuestro entorno.

 En esta serie de artículos veremos como crear un **servidor** de **desarrollo** aislado para **Django**. Te preguntarás, ¿pero si con **Python** ya tenemos **virtualenv**? Si, pero ya sabemos que virtualenv no es perfecto y en muchas ocasiones no aísla todo lo bien que debería. Además Vagrant nos permite replicar el entorno de producción en local, con todas las ventajas que conlleva desarrollar en el entorno que nos vamos a encontrar en producción. En este ejemplo utilizaremos **Ubuntu 16.04** cómo sistema operativo, **Nginx** de proxy inverso, **Postgree** como sistema gestor de base de datos y **Gunicorn** de servidor web.

### Por qué Ansible

La diferencia principal entre Ansible y otras herramientas de orquestación, es que **Ansible** **se comunica** con el/los servidor/es **vía SSH**, no como Puppet o Chef que necesitan tener instaladas dependencias en el/los servidor/es para poder ser utilizados.

**La principal ventaja de Ansible es su simplicidad**, las tareas se definen en formato **YAML**, tiene una **comunidad inmensa** (cuenta más seguidores en Github que Salt, Puppet y Cheff juntos). Por si fuera poco está **escrito en Python** y permite el uso de plantillas **Jinja 2** para generar ficheros de configuración.

Gracias a **Ansible** podremos replicar la máquina orquestada para desarrollo **en producción** sin demasiado coste adicional, dedicaré un artículo en el futuro para tratar esta problemática.

### Requisitos

Antes que nada tenemos que tener instalado en nuestro equipo Vagrant y Ansible. Vagrant lo puedes descargar desde [aquí](https://www.vagrantup.com/downloads.html), **Ansible** lo puedes instalar con **Brew** o con **PIP**, tal como indican en la [documentación oficial](http://docs.ansible.com/ansible/intro%5Finstallation.html).

### **Vagrantfile**

Comenzaremos creando un nuevo directorio para nuestro proyecto:

\`\`\`
mkdir -p ~/Projects/ansible-vagrant-django
cd ~/Projects/ansible-vagrant-django

\`\`\`

A continuación, ejecutaremos el comando \`Vagrant init\` para crear un nuevo \`Vagrantfile\` basado en **Ubuntu 16.04**:

\`\`\`
vagrant init geerlingguy/ubuntu1604

\`\`\`

Debe haberse generado un fichero llamado **Vagrantfile** en la raíz del directorio. Este contiene **información básica** sobre la máquina que queremos aprovisionar, y multiples comentarios, los eliminamos y dejamos el fichero así:

\`\`\`
API_VERSION = "2"

Vagrant.configure(API_VERSION) do |config|
  config.vm.box = "geerlingguy/ubuntu1604"
end

\`\`\`

Vamos a necesitar una manera de acceder a nuestro servidor web una vez que la máquina esté lista, así que le indicaremos a Vagrant que mapee el puerto 8000 de nuestro equipo al puerto 8000 de la maquina virtual. Para ello, agrega el siguiente código:

\`\`\`
config.vm.network "forwarded_port", guest: 80, host: 8080
config.vm.network "public_network"

\`\`\`

Para poder acceder vía SSH a nuestra máquina y que sincronice nuestro directorio de trabajo dentro de la máquina, necesitaremos añadir estás dos directivas:

\`\`\`
config.ssh.forward_agent = true
config.vm.synced_folder "./", "/var/www/djangoproject"

\`\`\`

Por último, indicaremos que queremos aprovisionar la máquina con Ansible, y dónde va a encontrar el fichero con los comandos de ansible:

\`\`\`
config.vm.provision :ansible do |ansible|
  ansible.playbook = "provision/vagrant.yml"
end

\`\`\`

Una vez añadidos todos los requerimientos nuestro Vagrantfile quedará así:

\`\`\`

    # -*- mode: ruby -*-
# vi: set ft=ruby :

API_VERSION = "2"

Vagrant.configure(API_VERSION) do |config|

  config.vm.box = "geerlingguy/ubuntu1604"

  config.vm.network "forwarded_port", guest: 8000, host: 8000
  config.vm.network "public_network"

  config.ssh.forward_agent = true
  config.vm.synced_folder "./", "/var/www/djangoproject"

  config.vm.provision "ansible" do |ansible|
    ansible.playbook = "provision/vagrant.yml"
  end
end

\`\`\`

### Playbooks de Ansible

Un **Playbook** de **Ansible** es un fichero que permite definir todas las tareas que se van a realizar en uno o varios hosts (servidores), en este caso en nuestro servidor de desarrollo.

Las **tareas** equivalen a uno o multiples **comandos bash**, cada una de las mismas hace uso de un modulo de Ansible. **Los módulos** son **librerías** que utiliza **Ansible** para controlar servicios, ficheros, paquetes o comandos, como por ejemplo **apt**, **copy** o **service**.

Veamos como escribir nuestro primer Playbook, lo primero que debemos hacer es crear un directorio provision y dentro de este un fichero denominado vagrant.yml:

\`\`\`
mkdir provision
cd provision
touch vagrant.yml

\`\`\`

Seguidamente añadimos a nuestro playbook los hosts en los que se van a ejecutar las tareas, en este caso como estamos haciendo uso de Vagrant indicaremos que puede ejecutar las tareas en todos los servidores conocidos y además con permisos de usuario root (become yes):

\`\`\`
- hosts: all
  become: yes

\`\`\`

### Tareas de Ansible

Tal como hemos dicho, las tareas (**Tasks**) de **Ansible** realizan su función ejecutando un modulo, son **ejecutadas en orden**, una cada vez **en** **cada uno de los nodos** definidos en la directiva ‘hosts’ (en este caso sólo tenemos el nodo de nuestra máquina virtual).  
 Cada una de las **tareas** tienen como mínimo un **nombre** y el **módulo** que ejecutan. Por ejemplo, instalar python-pip sería tan sencillo como esto:

\`\`\`
- name: Install python pip
  apt: name=python-pip

\`\`\`

En este artículo, para evitar que se haga excesivamente extenso, solo crearemos la tarea “instalar los paquetes básicos”, dejaremos para la próxima entrada las tareas referentes a la configuración de **PosgtgreeSQL**, **Nginx**, **Gunicorn** y **Django**.  
 Dicha tarea quedaría tal que así:

\`\`\`
- name: Install base packages
  apt: name={{ item }} update_cache=yes state=installed
  with_items:
    - build-essential
    - acl
    - ntp
    - htop
    - git
    - libpq-dev
    - python-dev
    - python-pip
    - python-pycurl
    - nginx
    - gunicorn

\`\`\`

En esta tarea estamos ejecutando el modulo apt, le estamos indicando que actualice la caché y que el estado de final de la tarea sea “installed”. La directiva “with\\_items” permite que la tarea se ejecute para cada uno de los paquetes indicados.

Así luce nuestro playbook hasta el momento:

\`\`\`
---
- hosts: all
  become: yes

  tasks:
    - name: Install base packages
      apt: name={{ item }} update_cache=yes state=installed
      with_items:
        - build-essential
        - acl
        - ntp
        - htop
        - git
        - libpq-dev
        - python-dev
        - python-pip
        - python-pycurl
        - nginx
        - gunicorn

\`\`\`

Si a continuación ejecutamos el comando \`vagrant up\` se “levantará” nuestra máquina con la “box” asignada, en este caso Ubuntu 16.04, y la configuración que hemos indicado en el vagrantfile.

Una vez terminado este proceso, y sólo si es la primera vez que se ejecuta, comenzará el aprovisionamiento de la máquina con nuestro playbook de Ansible. Si añadimos tareas a posteriori al playbook podemos volver a ejecutar el aprovisionamiento con el comando \`vagrant provision\`.

### Resumen

En esta entrada hemos visto cómo configurar un servidor de desarrollo casi genérico usando Vagrant y Ansible. He dejado muchas cosas en el tintero, pero el post se estaba haciendo demasiado largo. En el siguiente entraré en materia en lo referente a la configuración del stack de Django y continuaré profundizando en lo que a Ansible se refiere, trateré temas como Roles, Handlers, Vars y demás.

 Si te ha gustado la entrada valora y comparte en tus redes sociales. No dudes en comentar dudas, aportes o sugerencias, estaré encantado de responder.

 Este artículo se distribuye bajo una [Licencia Creative Commons Reconocimiento-CompartirIgual 4.0 Internacional (CC BY-SA 4.0)](https://creativecommons.org/licenses/by-sa/4.0/deed.es%5FES) 

[![licencia-cc](https://res.cloudinary.com/software-crafters/image/upload/v1544181784/licencia-cc.png)](https://creativecommons.org/licenses/by-sa/4.0/deed.es%5FES) ",
    "slug": "servidor-desarrollo-vagrant-ansible",
    "tags": [
      "devops",
    ],
    "title": "Servidor de desarrollo Django con Vagrant y Ansible",
    "userPicture": "",
    "username": "Miguel A. Gómez",
  },
  {
    "category": "devops",
    "cover": "https://res.cloudinary.com/software-crafters/image/upload/v1545047302/posts/cluster-docker-swarm-digital-ocean/docker-swarm-d.png",
    "date": "",
    "description": "",
    "id": "cluster-docker-swarm-digital-ocean",
    "markdownBody": "Docker Swarm es una herramienta integrada en el ecosistema de Docker que permite la gestión de un cluster de servidores. Pone a nuestra disposición una API con la que podemos administrar las tareas y asignación de recursos de cada contenedor dentro de cada una de las máquinas. Dicha API nos permite gestionar el cluster como si se tratase de una sola máquina Docker.

En este artículo veremos cómo construir un cluster de servidores con Docker Swarm, se utilizará Docker Machine con el driver de Digital Ocean para aprovisionar cada una de las máquinas.

![docker-compose](https://res.cloudinary.com/software-crafters/image/upload/v1545047302/posts/cluster-docker-swarm-digital-ocean/docker_compose.png) 

> La mejor manera de orquestar docker es con el propio docker

### Requisitos

Para seguir este tutorial necesitamos los siguiente:

* Tener instalado docker en tu máquina (puedes instalarlo desde [aquí](https://docs.docker.com/engine/installation/))
* Disponer de un token de API de Digital Ocean. Si no lo tienes puedes generar uno siguiendo [esta guía](https://www.digitalocean.com/community/tutorials/how-to-use-the-digitalocean-api-v2).

### Generar el token de Swarm

El sistema de descubrimiento de nodos de Swarm, Discovery Service, se sirve de un _token_ para reconocer todos nodos que forman parte de un clúster. Veamos como generar dicho token para poder hacer uso de Discovery Service.

En primer lugar guardaremos en una variable de sesión el token de Digital Ocean:

\`\`\`
export DO_TOKEN="abcdefghijklmnopqrstuvwxyz1234567890"


\`\`\`

A continuación, creamos una maquina con docker machine llamada swarm-1, dicha máquina servirá simplemente para generar el token de cluster:

\`\`\`
docker-machine create \\
--driver digitalocean \\
--digitalocean-access-token \${DO_TOKEN} \\
--digitalocean-image "ubuntu-16-04-x64" \\
--digitalocean-region "lon1" \\
--digitalocean-size "512mb" \\
swarm-1

\`\`\`

Seleccionamos esta maquina:

\`\`\`
eval $(docker-machine env swarm-1)


\`\`\`

Generamos el token de cluster:

\`\`\`
docker run swarm create


\`\`\`

Almacenamos en una variable de entorno dicho token y lo exportamos:

\`\`\`
export SWARM_TOKEN=61ef79938e5559d480c2841991c49f5d

\`\`\`

Ya podemos eliminar esta instancia de digital ocean, como hemos dicho sólo la necesitabamos para crear el ID.

\`\`\`
docker-machine rm swarm-1

\`\`\`

### Nodo principal (Swarm Master)

Es el encargado de gestionar los recursos del clúster. Para crearlo ejecutaremos el siguiente código:

\`\`\`
docker-machine create \\
--driver digitalocean \\
--digitalocean-access-token \${DO_TOKEN} \\
--digitalocean-image "ubuntu-16-04-x64" \\
--digitalocean-region "lon1" \\
--digitalocean-size "512mb" \\
--swarm --swarm-master \\
--swarm-discovery token://\${SWARM_TOKEN} \\
swarm-master

\`\`\`

### Nodos secundarios

Una vez creado el nodo principal ya podemos añadir los nodos secundarios que necesitemos, en este caso vamos a añadir dos nodos al cluster:  
**Nodo 1:**

\`\`\`
docker-machine create \\
--driver digitalocean \\
--digitalocean-access-token \${DO_TOKEN} \\
--digitalocean-image "ubuntu-16-04-x64" \\
--digitalocean-region "lon1" \\
--digitalocean-size "512mb" \\
--swarm \\
--swarm-discovery token://\${SWARM_TOKEN} \\
swarm-node-1


\`\`\`

**Nodo 2:**

\`\`\`

docker-machine create \\
--driver digitalocean \\
--digitalocean-access-token \${DO_TOKEN} \\
--digitalocean-image "ubuntu-16-04-x64" \\
--digitalocean-region "lon1" \\
--digitalocean-size "512mb" \\
--swarm \\
--swarm-discovery token://\${SWARM_TOKEN} \\
swarm-node-2

\`\`\`

Comprobamos que todos los nodos están funcionan correctamente

\`\`\`
docker-machine ls

\`\`\`

Si seleccionamos unos de los nodos: \`eval $(docker-machine env --swarm swarm-master)\`y, ejecutamos \`docker info,\` podremos ver la información de los dos nodos secundarios y del nodo principal, containers, CPUs, Memoria kernel.

### Contenedores en el clúster

Vamos a ejecutar dos contenedores con la imagen nginx y aplicando una limitación de 400M de memoria a cada uno de los contenedores

\`\`\`
docker run --name web-1 -d -P -m 400M nginx

\`\`\`

Podemos comprobar si el contenedor está ejecutandose correctamente con \`docker ps\`. Observamos que el planificador de docker swarm ha escogido para correr el contenedor web-1 el nodo principal.

Veamos que ocurre si inicializamos otro contenedor denominado “web-2” con las mismas restricciones que el anterior:

\`\`\`
docker run --name web-2 -d -P -m 400M nginx

\`\`\`

En esta ocasión, el planificador ha asignado el contenedor al nodo 1, porque no había suficiente memoria en el nodo principal.

Si lo consideramos necesario podemos ampliar el tamaño del cluster, ejecutando simplemente:

\`\`\`
docker run --name web-2 -d -P -m 400M nginx
docker-machine create \\
--driver digitalocean \\
--digitalocean-access-token \${DO_TOKEN} \\
--digitalocean-image "ubuntu-16-04-x64" \\
--digitalocean-region "lon1" \\
--digitalocean-size "512mb" \\
--swarm \\
--swarm-discovery token://\${SWARM_TOKEN} \\
swarm-node-3

\`\`\`

### Conclusión

Hemos podido ver que orquestar hosts de Docker con Docker Swarm es un proceso relativamente sencillo. Poco a poco el ecosistema de docker se está volviendo más robusto y completo. En el caso concreto de Swarm, personalmente aun no lo utilizaría en entornos de producción, pero como hemos podido ver es una herramienta que promete mucho.

Happy clustering!!

 Si te ha gustado la entrada valora y comparte en tus redes sociales. No dudes en comentar dudas, aportes o sugerencias, estaré encantado de responder.

 Este artículo se distribuye bajo una [Licencia Creative Commons Reconocimiento-CompartirIgual 4.0 Internacional (CC BY-SA 4.0)](https://creativecommons.org/licenses/by-sa/4.0/deed.es%5FES) 

[![licencia-cc](https://res.cloudinary.com/software-crafters/image/upload/v1544181784/licencia-cc.png)](https://creativecommons.org/licenses/by-sa/4.0/deed.es%5FES)",
    "slug": "cluster-docker-swarm-digital-ocean",
    "tags": [
      "devops",
    ],
    "title": "Cluster de servidores con Docker Swarm en Digital Ocean",
    "userPicture": "",
    "username": "Miguel A. Gómez",
  },
  {
    "category": "django",
    "cover": "https://res.cloudinary.com/software-crafters/image/upload/v1545388156/posts/testing-modelos-django/django-testing-1.png",
    "date": "",
    "description": "",
    "id": "testing-modelos",
    "markdownBody": "El testing es una de las partes más importantes de cualquier proyecto de software, ya que aporta calidad y seguridad a nuestro código. En esta entrada voy a tratar de exponer algunas prácticas muy recomendables para testear modelos en Django de forma eficiente y segura.

### Evita los mocks

Por norma general, en la gran mayoría de los errores relacionados con los modelos está involucrada la base de datos y suelen ocurrir por:

* Migraciones obsoletas.
* Tipos de datos erróneos.
* Restricciones de referencia / integridad.
* Errores en las consultas de recuperación de datos.

Dichos errores no se reproducirán si estamos “mockeando” los datos, por lo tanto el mocking en el testing de modelos deberíamos tratar de minimizarlo, ya que las pruebas nos proporcionarían una falsa sensación de seguridad, dejando que las cuestiones anteriores se pasen por alto.

Esto no implica que nunca se deban mockear los objetos de los tests de modelos, simplemente debemos ser cuidadosos a la hora de utilizarlos.

### No testees framework

Los modelos son simplemente una colección de campos que dependen de la funcionalidad estándar de Django. Dicha funcionalidad ya está más que testada, así que no seas redundante.

Utilizaremos como ejemplo el modelo User que utilizamos en [este post](http://miguelgomez.io/python/extender-user-django/):

\`\`\`
from __future__ import unicode_literals

from django.db import models
from django.contrib.auth.models import PermissionsMixin
from django.contrib.auth.base_user import AbstractBaseUser
from django.utils.translation import ugettext_lazy as _

from .managers import UserManager

class User(AbstractBaseUser, PermissionsMixin):
    email = models.EmailField(_('email address'), unique=True)
    first_name = models.CharField(_('first name'), max_length=30, blank=True)
    last_name = models.CharField(_('last name'), max_length=30, blank=True)
    date_joined = models.DateTimeField(_('date joined'), auto_now_add=True)
    is_active = models.BooleanField(_('active'), default=True)
    avatar = models.ImageField(upload_to='avatars/', null=True, blank=True)

    objects = UserManager()

    USERNAME_FIELD = 'email'
    REQUIRED_FIELDS = []

    class Meta:
        verbose_name = _('user')
        verbose_name_plural = _('users')

    def get_full_name(self):
        '''
        Returns the first_name plus the last_name, with a space in between.
        '''
        full_name = '%s %s' % (self.first_name, self.last_name)
        return full_name.strip()

    def get_short_name(self):
        '''
        Returns the short name for the user.
        '''
        return self.first_name


\`\`\`

En muchos tutoriales nos encontraríamos con pruebas como esta:  

\`\`\`
from django.test import TestCase
from .models import User


class UserModelTest(TestCase):

    def test_user_creation(self):
        User(email = "prueba@prueba.com", name='prueba user').save()

        users = User.objects.all()
        self.assertEquals(users.count(), 1)

        user_from_db = users_in_db[0]
        self.assertEquals(user.email, "prueba@prueba.com")
        self.assertEquals(user.name, "prueba user")

\`\`\`

Felicidades, ya has escrito tu primer test de modelos!! (dirían)

Lo único que hemos hecho es comprobar que el ORM de Django puede almacenar un modelo correctamente. Pero, ¿qué sentido tiene realizar este tipo de pruebas? Pues la verdad es que no demasiado, no necesitamos probar la funcionalidad inherente al framework.

### Prueba tu funcionalidad

En lugar de gastar tiempo en crear pruebas inútiles que realmente no son necesarias, tratar de seguir esta regla: Prueba sólo la funcionalidad personalizada que creaste en tu modelo.

> Prueba tu funcionalidad, no las inherentes al framework.

En el modelo User utilizado de ejemplo, no tenemos demasiadas funcionalidades personalizadas. Se me ocurre que podríamos probar que nuestro modelo utiliza una dirección de correo electrónico para el USERNAME\\_FIELD sólo para asegurarnos de que otro desarrollador no lo cambia.

También podríamos añadir una función \`get_by_id(uid)\` que reemplace las llamadas a \`User.objects.get(pk)\`, veamos como quedaría el modelo:

\`\`\`
from __future__ import unicode_literals
from django.db import models
from django.contrib.auth.models import PermissionsMixin
from django.contrib.auth.base_user import AbstractBaseUser
from django.utils.translation import ugettext_lazy as _

from .managers import UserManager

class User(AbstractBaseUser, PermissionsMixin):
    email = models.EmailField(_('email address'), unique=True)
    first_name = models.CharField(_('first name'), max_length=30, blank=True)
    last_name = models.CharField(_('last name'), max_length=30, blank=True)
    date_joined = models.DateTimeField(_('date joined'), auto_now_add=True)
    is_active = models.BooleanField(_('active'), default=True)
    avatar = models.ImageField(upload_to='avatars/', null=True, blank=True)

    objects = UserManager()

    USERNAME_FIELD = 'email'
    REQUIRED_FIELDS = []

    class Meta:
        verbose_name = _('user')
        verbose_name_plural = _('users')

    def get_full_name(self):
        '''
        Returns the first_name plus the last_name, with a space in between.
        '''
        full_name = '%s %s' % (self.first_name, self.last_name)
        return full_name.strip()

    def get_short_name(self):
        '''
        Returns the short name for the user.
        '''
        return self.first_name

    @classmethod
    def get_by_id(cls, uid):
        return User.objects.get(pk=uid)

    def __unicode__(self):
        return self.email


\`\`\`

Nótese que hemos utilizado el decorador @classmethod para definir el método \`get_by_id()\`. Hemos creado un método de clase en vez de instancia porque ya que este no tiene estado y de esta manera lo podemos llamar simplemente escribiendo \`User.get_by_id\`.

Veamos como queda el **test del modelo**:

\`\`\`
from django.test import TestCase
from accounts.models import User

class UserModelTest(TestCase):

    @classmethod
    def setUpClass(cls):
        cls.test_user = User(email="prueba@prueba.com", name='test user')
        cls.test_user.save()

    def test_user_to_string_email(self):
        self.assertEquals(__unicode__(self.test_user), "prueba@prueba.com")

    def test_get_by_id(self):
        self.assertEquals(User.get_by_id(1), self.test_user)


\`\`\`

Hay que prestar atención al método \`setUpClass()\`, ya que todas nuestras pruebas están compartiendo el mismo objeto User, si en alguno de los test modificamos dicho objeto, podríamos provocar que las otras pruebas fallen de forma inesperada. Esto nos puede conducir a sesiones de depuración absurdas ya que los tests fallarían sin razón aparente.

Una estrategia más segura (y más lenta), sería crear el objeto en método \`setup()\`, el cual se ejecuta antes de cada test, y luego destruir dicho objeto al final de la ejecución del mismo usando para ello el método \`tearDown()\`.

Nuestro test quedaría tal que así:

\`\`\`
from django.test import TestCase
from accounts.models import User

class UserModelTest(TestCase):

    def setUp(self):
        self.test_user = User(email="prueba@prueba.com", name='test user')
        self.test_user.save()

    def test_user_to_string_email(self):
        self.assertEquals(str(self.test_user), "prueba@prueba.com")

    def test_get_by_id(self):
        self.assertEquals(User.get_by_id(1), self.test_user)

    def tearDown(self):
        self.test_user.delete()


\`\`\`

### Uso de Fixtures

Django nos proporciona una funcionalidad integrada para cargar automáticamente y rellenar los datos del modelo: las denominadas **fixtures de Django**. No soy demasiado fan de este enfoque, ya que generamos nuevos ficheros en los que buscar a la hora de depurar errores, pero he de reconocer que en un momento dado pueden resultar útil.

Una fixture (accesorio) es una colección de datos en formato XML, YAML o JSON, que Django se encarga de importar a la base de datos, tanto para generar datos por defecto para nuestro proyecto o para nuestro entorno de pruebas.

A continuación un ejemplo de una fixture en formato JSON:

\`\`\`
[
  {
    "model": "accounts.user",
    "pk": 1,
    "fields": {
      "email":"john@lennon.com",
      "first_name": "John",
      "last_name": "Lennon"
    }
  },
  {
    "model": "accounts.user",
    "pk": 2,
    "fields": {
      "email":"paul@mccartney.com",
      "first_name": "Paul",
      "last_name": "McCartney"
    }
  }
]


\`\`\`

Por defecto Django busca las fixtures en el directorio \`app_name/fixtures\`, también podemos definir un directorio personalizado en nuestro fichero de configuración\`settings.FIXTURE_DIRS\`

Veamos como referenciarlas en nuestro fichero de pruebas:

\`\`\`
from django.test import TestCase
from accounts.models import User

class UserModelTest(TestCase):
    fixtures = ['users_fixture.json', ]

...


\`\`\`

Indicar la extensión del fichero es opcional, debemos incluirla si queremos que Django busque sólo ficheros de un tipo en concreto.

### Apps de terceros

Si te apetece seguir engordando el requirements.txt de tu proyecto puedes darle una oportunidad la app [Model Mommy](http://model-mommy.readthedocs.io/) es una alternativa que nos ofrece la comunidad a las fixtures de Django. Nos ofrece una API simple que nos permite crear varios objetos en pocas lineas de código.

Veamos un ejemplo:

\`\`\`

from django.test import TestCase
from model_mommy import mommy
from model_mommy.recipe import Recipe, foreign_key

from accounts.models import User

class UserModelTest(TestCase):
    def setUp(self):
        self.test_user = mommy.make(User)

    def test_user_creation_mommy(self):
        self.assertTrue(isinstance(test_user, User))
        self.assertEqual(test_user.__unicode__(), test_user.email)


\`\`\`

### Conclusiones

Como he dicho al principio, el Testing es una práctica en la cual todo desarrollador debe conocer los conceptos básicos y aplicarlos.

El principal problema del testing es lo sobrevalorado que en algunos casos puede llegar a estar, véase el mito del 100% de cobertura, [este artículo](http://martinfowler.com/bliki/TestCoverage.html) de [Martin Fowler](https://es.wikipedia.org/wiki/Martin%5FFowler) trata sobre ello. Es una locura pretender tener testado el 100% de nuestro código, sería una pérdida de tiempo total y absoluta de nuestro preciado tiempo, como hemos visto hay muchas partes del proyecto que no merece la pena testar. 

 Si te ha gustado el artículo, valora y comparte en tus redes sociales. No dudes en comentar dudas, aportes o sugerencias, estaré encantado de responder.

 Este artículo se distribuye bajo una [Licencia Creative Commons Reconocimiento-CompartirIgual 4.0 Internacional (CC BY-SA 4.0)](https://creativecommons.org/licenses/by-sa/4.0/deed.es%5FES) 

[![licencia-cc](https://res.cloudinary.com/software-crafters/image/upload/v1544181784/licencia-cc.png)](https://creativecommons.org/licenses/by-sa/4.0/deed.es%5FES) ",
    "slug": "testing-modelos",
    "tags": [
      "django",
    ],
    "title": "Testing de modelos en Django, buenas prácticas",
    "userPicture": "",
    "username": "Miguel A. Gómez",
  },
  {
    "category": "devops",
    "cover": "https://res.cloudinary.com/software-crafters/image/upload/v1545389672/posts/configurar-servidor-https-nginx/nginx-ssl.png",
    "date": "",
    "description": "¿Cómo configurar un HTTPS con NGINX? En esta guía expondré los pasos necesarios para crear y configurar un certificado SSL Nginx.",
    "id": "configurar-servidor-https-nginx",
    "markdownBody": "Dudaba sobre si hacer esta entrada o no, ya que hay mucha documentación al respecto en la red (aunque algo desordenada a mi entender), pero la principal motivación del blog es que las entradas me sirvan a mi mismo, así que prefiero publicarlo a que quede perdido en una nota de Evernote.

Bueno vamos a ello, disponer de una conexión https en nuestro sitio web nos brinda varias ventajas, por un lado nos proporciona un plus de seguridad al encriptar la conexión del sitio, y por otro ayuda a mejorar el SEO del mismo, ya que Google premia los sitios que disponen de este tipo de conexión.

Esta entrada no pretende ser una guía muy exhaustiva simplemente expondré los pasos necesarios para crear y configurar un certificado SSL en un servidor Nginx.

### Paso 1: Generar la clave privada (.key)

Nos conectamos a nuestro servidor y generamos la clave privada con openssl en el directorio /etc/ssl. Nos solicitará que creemos una contraseña.

\`\`\`
cd /etc/ssl/
sudo openssl genrsa -des3 -out tudominio.key 2048


\`\`\`

### Paso 2: Crear la solicitud de certificado (.csr)

Para generar una solicitud de firma de certificado lo que se denomina como Certificate Signing Request (CSR), ejecutamos lo siguiente:

\`\`\`
sudo openssl req -new -newkey rsa:2048 -nodes -keyout tudominio.key -out tudominio.csr

\`\`\`

Introducimos la información solicitada:  
**Country Name (AU)**: El formato de dos letras de tu país  
**State or Province (S):** Nombre del estado o provincia en donde se encuentra tu organización. No es obligatorio.  
**Locality or City (L):** Nombre de la ciudad en la que está registrada o se encuentra tu organización. No es obligatorio.  
**Organization (O):** El nombre legalmente registrado para tu negocio. Si te inscribes como un individuo, ingresa el nombre del certificado del solicitante.  
**Organization Unit:** No es obligatorio, se refiera al nombre DBA (Doing Business As).  
**Common Name (CN):** El nombre de dominio completo o dirección URL que quieras asegurar. Si estás solicitando un certificado Wildcard, agrega un asterisco (\\*) a la izquierda del nombre común, por ejemplo, \\*.coolexample.com.  
 Una vez completado el formulario nos solicitará otro password, este es opcional, si lo creamos cada vez que reiniciemos Nginx deberemos introducirlo.

### Paso 3: Generar los certificados intermedios (.crt)

Copia el contenido de todo el fichero CSR generado y pégalo/subelo a la autoridad certificadora. En mi caso lo hice con GoDaddy, ya que tenían los certificados a 5$. En este paso se generán dos certificados intermedios.

### Paso 4: Contatenar los certificados intermedios (.crt)

A continuación debemos concatenar los certificados intermedios generados en el paso anterior. (da igual el orden).

\`\`\`
cat certificado1.crt certificado2.crt >> tudominio.crt

\`\`\`

### Paso 5: Configurar Nginx

Subimos el certficado a nuestro servidor al directorio \`/etc/ssl/\` y editamos nuestro fichero de configuración de Nginx tal que así:

\`\`\`
server {
listen 443;
server_name tudominio.com;

root /var/www/;
index index.html index.htm;

ssl on;
ssl_certificate /etc/ssl/tudominio.crt;
ssl_certificate_key /etc/ssl/tudominio.key;
}


\`\`\`

Si además queremos que todo nuestro trafico http sea redireccionado a https añadimos lo siguiente:

\`\`\`
server {
listen 80;
server_name tudominio.com www.tudominio.com;
return 301 https://$host$request_uri;
}

\`\`\`

En principio esto es todo lo que necesitamos para hacer uso del protocolo seguro de HTTPS en nuestro servidor, cualquier duda que tengais no dudeis en comentarla.

 Si te ha gustado el artículo, valora y comparte en tus redes sociales. No dudes en comentar dudas, aportes o sugerencias, estaré encantado de responder.

 Este artículo se distribuye bajo una [Licencia Creative Commons Reconocimiento-CompartirIgual 4.0 Internacional (CC BY-SA 4.0)](https://creativecommons.org/licenses/by-sa/4.0/deed.es%5FES) 

[![licencia-cc](https://res.cloudinary.com/software-crafters/image/upload/v1544181784/licencia-cc.png)](https://creativecommons.org/licenses/by-sa/4.0/deed.es%5FES)",
    "slug": "configurar-servidor-https-nginx",
    "tags": [
      "devops",
    ],
    "title": "Configurar un servidor HTTPS con Nginx",
    "userPicture": "",
    "username": "Miguel A. Gómez",
  },
]
`;
